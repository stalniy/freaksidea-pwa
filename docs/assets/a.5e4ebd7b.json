{"id":"casl-i-cancan-kak-rassharit-prava-dostupa-mezhdu-ui-i-api","title":"CASL и Cancan. Как расшарить права доступа между UI и API","summary":"В этой статье я хочу раcсказать о том как интегрировать CASL с Rails API.","author":"sstotskyi","categories":["frontend","important","backend"],"createdAt":"2018-06-26T05:00:00.000Z","meta":{"keywords":["права доступа","Ruby","casl"]},"alias":"casl-i-cancan-kak-rassharit-prava-dostupa-mezhdu-ui-i-api","content":"<p><img src=\"/media/assets/casl-vue-rails-logo.png\" alt=\"CASL Vuex + Rails API\" title=\"CASL Vuex + Rails API\" loading=\"lazy\" width=\"754\" style=\"max-height: 679px;\" srcset=\"/media/assets/casl-vue-rails-logo-xs.png 375w,/media/assets/casl-vue-rails-logo.png 1280w\" sizes=\"(max-width: 375px) 375px,1280px\"></p>\n<p>С ростом количества и типов устройств приложения были разделены на два отдельных компонента: UI (front-end, то, что пользователь видит и взаимодействует) и API (back-end, подразумевает бизнес-правила). Эти 2 части могут быть написаны на одном языке (например, JavaScript) или на разных (например, JavaScript на UI и Ruby on API). Такой подход позволяет описать бизнес-правила всего один раз и реализовывать отдельные пользовательские интерфейсы для каждого типа устройства (например, Web, iOS, Android).</p>\n<p>В приложениях, которые поддерживают аутентификацию, мы часто хотим изменить то, что пользователи могут делать в зависимости от их роли. Например, гостевой пользователь может видеть сообщение, но только зарегистрированный пользователь или администратор видит кнопку для удаления этого сообщения.</p>\n<p>Управление этими правами может стать кошмаром для приложений, которые разделены на UI и API. Более того, если есть две разные команды, которые реализуют эти части, они, скорее всего, придут к созданию кода, который будет обрабатывать разрешения для UI и API отдельно. Таким образом, изменения в логике прав доступа back-end-а потребуют изменений на UI и наоборот.</p>\n<p>Это увеличивает время для разработки и увеличивает количество ошибок в приложении. Так как же с этим бороться?</p>\n<h2 id=\"delites-pravami-dostupa\"><a name=\"delites-pravami-dostupa\" class=\"h-link\" href=\"#\"></a>Делитесь правами доступа :)</h2>\n<p>Когда это возможно, определите права доступа на стороне сервера и поделись ими с клиентской стороной. Этот подход работает очень хорошо, если вы используете <em>Node.js</em>, потому что вы можете использовать <a href=\"https://github.com/stalniy/casl\" target=\"_blank\" rel=\"noopener nofollow\">CASL</a> с обеих сторон и легко передавать правила с использованием токена JWT например.</p>\n<p>Также CASL прекрасно работает с Ruby gem-ом <a href=\"https://github.com/ryanb/cancan\" target=\"_blank\" rel=\"noopener nofollow\">cancan</a> (не поддерживаемый, сообщество создало форк под названием <a href=\"https://github.com/CanCanCommunity/cancancan\" target=\"_blank\" rel=\"noopener nofollow\">cancancan</a>). На самом деле этот gen был для меня большим вдохновением для создания CASL :)</p>\n<p><strong>Впервые слышете о CASL?</strong> Рекомендую прочесть <app-link to=\"frontend\" params=\"{&quot;id&quot;:&quot;chto-takoe-casl-ili-kak-vnedrit-proverku-prav-dostupa-v-vashe-prilozhenie&quot;}\">Что такое CASL?</app-link></p>\n<h2 id=\"primer-integraczii\"><a name=\"primer-integraczii\" class=\"h-link\" href=\"#\"></a>Пример интеграции</h2>\n<p><img src=\"/media/assets/vuex-rails-app.gif\" alt=\"CASL Vuex + Rails API\" title=\"CASL Vuex + Rails API\" loading=\"lazy\" width=\"527\" style=\"max-height: 465px;\" srcset=\"/media/assets/vuex-rails-app-xs.gif 375w,/media/assets/vuex-rails-app.gif 1280w\" sizes=\"(max-width: 375px) 375px,1280px\"></p>\n<p>Я создал пример, который показывает, как интегрировать API на базе Rails 5 с пользовательским интерфейсом на базе Vue. Это простое приложение для блога, которое позволяет управлять статьями, входить в приложение и выходить из него.</p>\n<p><strong>Для тех</strong>, кто интересен в конечном результате, перейдите по ссылкам <a href=\"https://github.com/stalniy/casl-vue-api-example\" target=\"_blank\" rel=\"noopener nofollow\">Vue app</a> и <a href=\"https://github.com/stalniy/rails-cancan-api-example\" target=\"_blank\" rel=\"noopener nofollow\">Rails API</a></p>\n<h3 id=\"rest-api\"><a name=\"rest-api\" class=\"h-link\" href=\"#\"></a>REST API</h3>\n<p>На самом деле на серверной стороне нет особо тонкостей, которые требуют объяснений. Это обычное Rails приложение, которое отдает JSON в ответ на запросы. Вся логика авторизации была выполнена с помощью вспомогательной функции <em>load_and_authorize_resource</em> (за деталями обращайтесь к <a href=\"https://github.com/CanCanCommunity/cancancan/wiki\" target=\"_blank\" rel=\"noopener nofollow\">Wiki Cancancan</a> проекта).</p>\n<p>Сессия управляется с помощью JWT токена. Этот токен содержит только поле <em>user_id</em>. Для входа в систему клиент должен отправить запрос <em>POST в /api/session</em> с электронной почтой и паролем (более детально описано в <a href=\"https://github.com/stalniy/rails-cancan-api-example\" target=\"_blank\" rel=\"noopener nofollow\">README проекта</a>). В случае успешного ответа сервер возвращает JWT токен и список правил, совместимых с форматом CASL.</p>\n<p>Это ответ для пользователя с ролью &quot;member&quot;:</p>\n<pre><code class=\"hljs language-javascript\">{\n    <span class=\"hljs-string\">\"token\"</span>: <span class=\"hljs-string\">\"eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyfQ.3MA5pz-JXuSs3YHdIEJcokTpharBLjUmfzXGp1dyYY8\"</span>,\n    <span class=\"hljs-string\">\"rules\"</span>: [\n        {\n            <span class=\"hljs-string\">\"actions\"</span>: [<span class=\"hljs-string\">\"read\"</span>],\n            <span class=\"hljs-string\">\"subject\"</span>: [<span class=\"hljs-string\">\"all\"</span>]\n        },\n        {\n            <span class=\"hljs-string\">\"actions\"</span>: [<span class=\"hljs-string\">\"manage\"</span>],\n            <span class=\"hljs-string\">\"subject\"</span>: [<span class=\"hljs-string\">\"Article\"</span>],\n            <span class=\"hljs-string\">\"conditions\"</span>: {\n                <span class=\"hljs-string\">\"author_id\"</span>: <span class=\"hljs-number\">2</span>\n            }\n        },\n        {\n            <span class=\"hljs-string\">\"actions\"</span>: [<span class=\"hljs-string\">\"read\"</span>, <span class=\"hljs-string\">\"update\"</span>],\n            <span class=\"hljs-string\">\"subject\"</span>: [<span class=\"hljs-string\">\"User\"</span>],\n            <span class=\"hljs-string\">\"conditions\"</span>: {\n                <span class=\"hljs-string\">\"id\"</span>: <span class=\"hljs-number\">2</span>\n            }\n        }\n    ]\n}\n</code></pre>\n<p>Этот ответ говорит, что пользователь может читать все, может управлять статьями, в которых <em>author_id</em> равно <em>2</em>, и может читать и обновлять пользователя <em>id</em> которого равно <em>2</em>. Возможно, Вы уже поняли, что число <em>2</em> является идентификатором залогиненого пользователя. Проще говоря, он может управлять собственными статьями, обновлять собственный профиль и читать все остальное.</p>\n<p>Cancan хранит правила не так, как CASL, поэтому я добавил метод <em>to_list</em> в <em>Ability</em>, что возвращает массив правил, который может использовать CASL:</p>\n<pre><code class=\"hljs language-ruby\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Ability</span></span>\n  <span class=\"hljs-keyword\">include</span> CanCan::Ability\n\n  <span class=\"hljs-comment\"># ....</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">to_list</span></span>\n    rules.map <span class=\"hljs-keyword\">do</span> <span class=\"hljs-params\">|rule|</span>\n      object = { <span class=\"hljs-symbol\">actions:</span> rule.actions, <span class=\"hljs-symbol\">subject:</span> rule.subjects.map{ <span class=\"hljs-params\">|s|</span> s.is_a?(Symbol) ? s : s.name } }\n      object[<span class=\"hljs-symbol\">:conditions</span>] = rule.conditions <span class=\"hljs-keyword\">unless</span> rule.conditions.blank?\n      object[<span class=\"hljs-symbol\">:inverted</span>] = <span class=\"hljs-literal\">true</span> <span class=\"hljs-keyword\">unless</span> rule.base_behavior\n      object\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<h3 id=\"vue-app\"><a name=\"vue-app\" class=\"h-link\" href=\"#\"></a>Vue app</h3>\n<p>CASL поставляется вместе с дополнительным <a href=\"https://github.com/stalniy/casl/tree/master/packages/casl-vue\" target=\"_blank\" rel=\"noopener nofollow\">пакетом для Vue</a>. Этот пакет добавляет метод <em>$can</em> во все компоненты Vue и позволяет легко проверять права доступа в шаблонах. Например:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"$can('create', 'Post')\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"createPost\"</span>&gt;</span>Add Post<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n</code></pre>\n<p>Это приложение использует Vuex для управления локальным состоянием. Все запросы к REST API сделаны с помощью actions в Vuex.Store. Также есть несколько плагинов и модулей, которые Вы можете найти в папке <em>src/store</em>, но самым интересным для нас является <em>src/store/ability.js</em>.</p>\n<p>Этот плагин заполняет экземпляр <em>Ability</em> правами доступа когда пользователь логинится в систему и удаляет его при выходе из системы.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { Ability } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@casl/ability'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> ability = <span class=\"hljs-keyword\">new</span> Ability()\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> abilityPlugin = <span class=\"hljs-function\">(<span class=\"hljs-params\">store</span>) =&gt;</span> {\n  ability.update(store.state.rules)\n\n  <span class=\"hljs-keyword\">return</span> store.subscribe(<span class=\"hljs-function\">(<span class=\"hljs-params\">mutation</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">switch</span> (mutation.type) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'createSession'</span>:\n      ability.update(mutation.payload.rules)\n      <span class=\"hljs-keyword\">break</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">'destroySession'</span>:\n      ability.update([{ <span class=\"hljs-attr\">actions</span>: <span class=\"hljs-string\">'read'</span>, <span class=\"hljs-attr\">subject</span>: <span class=\"hljs-string\">'all'</span> }])\n      <span class=\"hljs-keyword\">break</span>\n    }\n  })\n}\n</code></pre>\n<p>В приведенном выше коде я создаю и экспортирую пустой экземпляр <em>Ability</em> (этот экземпляр будет использоваться позже). Затем я создаю плагин для <em>Vuex</em>, который подписывается на сохранение изменений. Когда коммитится мутация <em>createSession</em> (т. е. вход пользователя), <em>Ability</em> обновляется указанными правами доступа и на <em>destroySession</em> (т.е., выход пользователя), способность сбрасывается в режим только для чтения.</p>\n<p>Позже этот плагин подключается к хранилищу <a href=\"https://github.com/stalniy/casl-vue-api-example/blob/master/src/store/index.js#L19\" target=\"_blank\" rel=\"noopener nofollow\">через свойство <em>plugins</em></a> и что способность реэкспортируется и передается в <a href=\"https://github.com/stalniy/casl-vue-api-example/blob/master/src/main.js#L13\" target=\"_blank\" rel=\"noopener nofollow\">Vue abilitiesPlugin</a>.</p>\n<p>Вот и все!</p>\n<p>Теперь изменения прав доступа на клиента и на сервера синхронизированы, и когда Вы изменяете правила API, Вам не нужно менять код на UI.</p>\n<p><strong>P.S.</strong>: оригинальная статья была опубликована на <a href=\"https://medium.com/dailyjs/casl-and-cancan-permissions-sharing-between-ui-and-api-5f1fa8b4bec\" target=\"_blank\" rel=\"noopener nofollow\">Medium.com</a></p>\n<h2 id=\"vmesto-zaklyucheniya\"><a name=\"vmesto-zaklyucheniya\" class=\"h-link\" href=\"#\"></a>Вместо заключения</h2>\n<p>Как видно из примера, CASL достаточно несложно интегрировать с существующими решениями. Если что-то было не понятно - пишите в комментариях или посмотрите в:</p>\n<ul>\n<li><a href=\"https://stalniy.github.io/casl/\" target=\"_blank\" rel=\"noopener nofollow\">Официальной документации</a></li>\n<li><a href=\"https://medium.com/dailyjs/vue-acl-with-casl-781a374b987a\" target=\"_blank\" rel=\"noopener nofollow\">Менеджмент прав доступа во Vue</a></li>\n<li><a href=\"https://medium.com/dailyjs/managing-user-permissions-in-your-react-app-a93a94ff9b40\" target=\"_blank\" rel=\"noopener nofollow\">Управление ACL в React</a></li>\n<li><a href=\"https://medium.com/@sergiy.stotskiy/casl-based-authorization-in-aurelia-app-3e44c0fe1703\" target=\"_blank\" rel=\"noopener nofollow\">Права доступа пользователей в Aurelia</a></li>\n<li><a href=\"https://medium.com/@sergiy.stotskiy/authorization-with-casl-in-express-app-d94eb2e2b73b\" target=\"_blank\" rel=\"noopener nofollow\">Авторизация в Express.js API</a></li>\n<li><a href=\"https://blog.feathersjs.com/authorization-with-casl-in-feathersjs-app-fd6e24eefbff\" target=\"_blank\" rel=\"noopener nofollow\">Авторизация в Feathers.js API</a></li>\n</ul>","headings":[["delites-pravami-dostupa","Делитесь правами доступа :)"],["primer-integraczii","Пример интеграции"],["rest-api","REST API"],["vue-app","Vue app"],["vmesto-zaklyucheniya","Вместо заключения"]]}