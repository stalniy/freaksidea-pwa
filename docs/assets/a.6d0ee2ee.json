{"title":"CASL. Pursuing Perfection II: New Engine","author":"sstotskyi","categories":["backend","important"],"createdAt":"2020-11-10T08:02:00.000Z","meta":{"keywords":["casl","ucast","javascript","performance"]},"summary":"<p><img src=\"/media/assets/casl-v5-engine.png\" alt=\"CASL. UCAST new engine\" loading=\"lazy\" width=\"1024\" style=\"max-height: 394px;\" srcset=\"/media/assets/casl-v5-engine-xs.png 375w,/media/assets/casl-v5-engine-sm.png 768w,/media/assets/casl-v5-engine-md.png 1024w,/media/assets/casl-v5-engine.png 1280w\" sizes=\"(max-width: 375px) 375px,(max-width: 768px) 768px,(max-width: 1024px) 1024px,1280px\"></p>\n<p>This is the second part in the series of articles where I share my experience building and optimizing CASL v5:</p>\n","content":"<p><img src=\"/media/assets/casl-v5-engine.png\" alt=\"CASL. UCAST new engine\" loading=\"lazy\" width=\"1024\" style=\"max-height: 394px;\" srcset=\"/media/assets/casl-v5-engine-xs.png 375w,/media/assets/casl-v5-engine-sm.png 768w,/media/assets/casl-v5-engine-md.png 1024w,/media/assets/casl-v5-engine.png 1280w\" sizes=\"(max-width: 375px) 375px,(max-width: 768px) 768px,(max-width: 1024px) 1024px,1280px\"></p>\n<p>This is the second part in the series of articles where I share my experience building and optimizing CASL v5:</p>\n<summary-cut/>\n<ul>\n<li><app-link to=\"backend\" params=\"{&quot;id&quot;:&quot;casl-pursuing-perfection-why&quot;}\">CASL. Pursuing Perfection I: Why?</app-link></li>\n<li><strong>CASL. Pursuing Perfection II: New Engine</strong></li>\n<li>CASL. Pursuing Perfection III: Big O</li>\n<li>CASL. Pursuing Perfection IV: Type Safety</li>\n</ul>\n<p>First time you've heard about CASL? You may want to read &quot;<a href=\"https://casl.js.org/v4/en/guide/intro\" target=\"_blank\" rel=\"noopener nofollow\">What is CASL?</a>&quot;.</p>\n<p>As I said in the previous article, to support SQL databases, CASL needed a new checking engine which can evaluate conditions in runtime and can transform them into any database query language. And <strong>this is why <a href=\"https://github.com/stalniy/ucast\" target=\"_blank\" rel=\"noopener nofollow\">UCAST</a> was born!</strong></p>\n<p>But, let's get deeper into what UCAST actually is</p>\n<h2 id=\"the-harness\"><a name=\"the-harness\" class=\"h-link\" href=\"#\"></a>The harness</h2>\n<p>So, the task is <strong>to translate any language to any other language</strong>. Doesn't it sound familiar? Think for a moment, please.</p>\n<p>If we ask Wikipedia <a href=\"https://en.wikipedia.org/wiki/Compiler\" target=\"_blank\" rel=\"noopener nofollow\">&quot;What is compiler?&quot;</a>, we get:</p>\n<blockquote>\n<p>In computing, a compiler is a computer program that <strong>translates computer code written in one programming language</strong> (the source language) <strong>into another language</strong> (the target language).</p>\n</blockquote>\n<p>Aha! The task converts  to writing a compiler that can translate MongoDB into JavaScript and SQL. There is a lot of theory around compilers, I knew I could read some of it but it would take a lot of time which I didn't have. That's why I used Wikipedia as a reference :)</p>\n<p>So, according to Wikipedia:</p>\n<blockquote>\n<p>A compiler is likely to perform many or all of the following operations: <strong>preprocessing, lexical analysis, parsing, semantic analysis</strong> (syntax-directed translation), <strong>conversion of input programs to an intermediate representation, code optimization and code generation</strong>.</p>\n</blockquote>\n<p>Quite a lot right? Hopefully, not all are necessary. The most <strong>3 important operations</strong> we need to concentrate at is:</p>\n<ul>\n<li>parsing</li>\n<li>conversion of input programs to an intermediate representation, usually <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\" target=\"_blank\" rel=\"noopener nofollow\"><strong>A</strong>bstract <strong>S</strong>yntax <strong>T</strong>ree (AST)</a></li>\n<li>code generation or AST interpreter (we do not always need to generate another code)</li>\n</ul>\n<p>So, to translate MongoDB query to something else, it needs to be parsed into an intermediate representation (i.e., AST) which later can be consumed by a code generator (or an interpreter) to do some useful work.</p>\n<p>And you know what? All these I've implemented in <a href=\"https://github.com/stalniy/ucast#ecosystem\" target=\"_blank\" rel=\"noopener nofollow\">@ucast/* ecosystem</a>.</p>\n<h2 id=\"abstract-syntax-tree\"><a name=\"abstract-syntax-tree\" class=\"h-link\" href=\"#\"></a>Abstract Syntax Tree</h2>\n<p>In spite of the somewhat complex naming, Abstract Syntax Tree is a regular <a href=\"https://en.wikipedia.org/wiki/Tree_(data_structure)\" target=\"_blank\" rel=\"noopener nofollow\">tree data structure</a> of objects that contain information about parsed language.</p>\n<p>There are 3 classes in <a href=\"https://github.com/stalniy/ucast/tree/master/packages/core\" target=\"_blank\" rel=\"noopener nofollow\">@ucast/core</a> package that is used to represent any boolean condition in AST:</p>\n<ul>\n<li><code>FieldCondition</code> represents a condition based on an object's field and operator (e.g., <code>x === 3</code> or <code>{ x: 3 }</code> in terms of MongoDB)</li>\n<li><code>DocumentCondition</code> represents condition that restricts a document or a row as whole (e.g., <code>$where</code> operator in MongoDB query language and <code>EXISTS</code> in SQL)</li>\n<li><code>CompoundCondition</code> represents a compound boolean operation (e.g., logical &quot;and&quot;, &quot;or&quot;, etc). This one aggregates other conditions in itself what allows us to represent complex expressions such as\n<code>(x === 5 &amp;&amp; x &lt; 2) || (y &gt; 0 &amp;&amp; status === &quot;available&quot;)</code></li>\n</ul>\n<h2 id=\"mongo-db-query-parser\"><a name=\"mongo-db-query-parser\" class=\"h-link\" href=\"#\"></a>MongoDB query Parser</h2>\n<p>As we already know, the responsibility of parser is to transform code into AST. And this is exactly what <code>MongoQueryParser</code> class from <code>@ucast/mongo</code> package does. Basically, the result of its work of is a tree of <code>FieldCondition</code>, <code>DocumentCondition</code> and <code>CompoundCondition</code> objects. The really cool thing which I like about this class is that it's composite and consists of parsing instructions that allows us to:</p>\n<ol>\n<li>To implement custom operators and extend our own MongoDB-like query language.</li>\n<li>To restrict what operators can be used in our MongoDB-like query language, to prevent usage of complex conditions.</li>\n<li>To use only pieces we need and get rid of unused code using JavaScript bundlers (e.g., rollup, webpack).</li>\n</ol>\n<p>Let’s see a working example to understand how it works:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { MongoQueryParser, $eq } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ucast/mongo'</span>;\n\n<span class=\"hljs-keyword\">const</span> parser = <span class=\"hljs-keyword\">new</span> MongoQueryParser({ $eq });\n<span class=\"hljs-keyword\">const</span> ast = parser.parse({\n  <span class=\"hljs-attr\">authorId</span>: <span class=\"hljs-number\">1</span>\n});\n</code></pre>\n<p>The parser above can parse only <code>$eq</code> operator, so if you try to use <code>$lt</code> for example, it will throw an error. The produced result is a single object of <code>FieldCondition</code> type with <code>eq</code> operator. <code>$eq</code> is actually a special operator which you need to pass in order to use POJO style query.</p>\n<p>To learn more about MongoDB query parser, its optimization logic and customization, please refer to the <a href=\"https://github.com/stalniy/ucast/tree/master/packages/mongo#getting-started\" target=\"_blank\" rel=\"noopener nofollow\"><strong>README file of @ucast/mongo</strong></a>.</p>\n<h2 id=\"interpreter-or-code-generator\"><a name=\"interpreter-or-code-generator\" class=\"h-link\" href=\"#\"></a>Interpreter or Code Generator?</h2>\n<p>UCAST uses word &quot;interpreter&quot; instead of &quot;code generator&quot; as it more clearly explains its purpose. For example, it may interpret it into JavaScript boolean value or into another language.</p>\n<p>There are 2 packages that implements interpreter interface:</p>\n<ul>\n<li><a href=\"https://github.com/stalniy/ucast/blob/master/packages/js\" target=\"_blank\" rel=\"noopener nofollow\">@ucast/js</a> converts AST into boolean value</li>\n<li><a href=\"https://github.com/stalniy/ucast/blob/master/packages/sql\" target=\"_blank\" rel=\"noopener nofollow\">@ucast/sql</a> converts AST into SQL string (also provides integration with major ORM libraries through sub modules)</li>\n</ul>\n<p>An interpreter is designed in very similar way to a parser but instead of using parsing instructions, it consists of more granular interpreters (1 per operator). Frankly speaking, <strong>an interpreter is just a pure function that is composed of other pure functions</strong>:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { createJsInterpreter, eq, lt, gt } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ucast/js'</span>;\n\n<span class=\"hljs-keyword\">const</span> interpret = createJsInterpreter({ eq, lt, gt });\n</code></pre>\n<p>Later, we can use this function to interpret AST into boolean value. So, to mimic <a href=\"https://github.com/crcn/sift.js\" target=\"_blank\" rel=\"noopener nofollow\">sift.js</a> functionality all we need to do is to compose MongoDB query parser and JavaScript interpreter:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { MongoQueryParser, allParsingInstructions } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ucast/mongo'</span>;\n<span class=\"hljs-keyword\">import</span> { createJsInterpreter, allInterpreters } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ucast/js'</span>;\n\n<span class=\"hljs-keyword\">const</span> parser = <span class=\"hljs-keyword\">new</span> MongoQueryParser(allParsingInstructions);\n<span class=\"hljs-keyword\">const</span> interpret = createJsInterpreter(allInterpreters);\n<span class=\"hljs-keyword\">const</span> ast = parser.parse({ <span class=\"hljs-attr\">authorId</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">'published'</span> });\n\n<span class=\"hljs-built_in\">console</span>.log(interpret(ast, { <span class=\"hljs-attr\">authorId</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">'published'</span> })); <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">console</span>.log(interpret(ast, { <span class=\"hljs-attr\">authorId</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">status</span>: <span class=\"hljs-string\">'published'</span> })); <span class=\"hljs-comment\">// false</span>\n</code></pre>\n<p>To reduce boilerplate of building MongoDB query language JavaScript runtime interpreter, I created a separate @ucast/mongo2js package which do this for us. <a href=\"https://github.com/stalniy/ucast/tree/master/packages/mongo2js\" target=\"_blank\" rel=\"noopener nofollow\"><strong>@ucast/mongo2js</strong></a> <strong>is a drop-in replacement for sift.js and actually used by casl v5 to evaluate conditions in runtime!</strong> Moreover, it <strong>speeds up conditions evaluation by ~2x times!</strong></p>\n<p>The only difference between @ucast/mongo2js and sift.js is how they interpret equal operation on objects.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> { guard } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@ucast/mongo2js'</span>;\n<span class=\"hljs-keyword\">import</span> sift <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'sift'</span>;\n\n<span class=\"hljs-keyword\">const</span> test = guard({ <span class=\"hljs-attr\">author</span>: { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span> } });\n<span class=\"hljs-keyword\">const</span> sifter = sift({ <span class=\"hljs-attr\">author</span>: { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span> } });\n\n<span class=\"hljs-built_in\">console</span>.log(test({ <span class=\"hljs-attr\">author</span>: { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span> } })) <span class=\"hljs-comment\">// false</span>\n<span class=\"hljs-built_in\">console</span>.log(sifter({ <span class=\"hljs-attr\">author</span>: { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span> } })) <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>By default, UCAST doesn’t check deep equality of objects but this can be changed by creating a custom <code>guard</code> function and custom <code>compare</code> function.</p>\n<blockquote>\n<p>Refer to documentation of <a href=\"https://github.com/stalniy/ucast/tree/master/packages/js\" target=\"_blank\" rel=\"noopener nofollow\">@ucast/js</a> and <a href=\"https://github.com/stalniy/ucast/tree/master/packages/mongo2js\" target=\"_blank\" rel=\"noopener nofollow\">@ucast/mongo2js</a> for more details</p>\n</blockquote>\n<p>Usually, you don’t even need such capability because it can be rephrased using dot notation which is supported by ucast as well:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> test = guard({ <span class=\"hljs-string\">'author.id'</span>: <span class=\"hljs-number\">1</span> });\n<span class=\"hljs-keyword\">const</span> sifter = sift({ <span class=\"hljs-string\">'author.id'</span>: <span class=\"hljs-number\">1</span> });\n\n<span class=\"hljs-built_in\">console</span>.log(test({ <span class=\"hljs-attr\">author</span>: { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span> } })) <span class=\"hljs-comment\">// true</span>\n<span class=\"hljs-built_in\">console</span>.log(sifter({ <span class=\"hljs-attr\">author</span>: { <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span> } })) <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p><strong>All UCAST packages are written in TypeScript</strong>, so you additionally get type safety and hints in your IDE.</p>\n<h1 id=\"conclusion\"><a name=\"conclusion\" class=\"h-link\" href=\"#\"></a>Conclusion</h1>\n<p>UCAST ecosystem is not only fast, lightweight but also very powerful! By implementing different parsers and interpreters, <strong>we can achieve outstanding results by combining one parser with different interpreters and many parsers with one interpreter.</strong></p>\n<p>For example, by implementing <a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener nofollow\">json-schema</a> parser, we will be able to reuse existing interpreters and convert the result either to JavaScript boolean value or SQL query or MongoDB query or Cassandra query or REST query or GraphQL query or any query language you can imagine!</p>\n<p><strong>How do you feel about that?</strong> I’m excited.</p>\n<hr>\n<p>Did I deserve <a href=\"https://opencollective.com/casljs/contribute/barista-13740/checkout\" target=\"_blank\" rel=\"noopener nofollow\">a cup of coffee</a>?</p>\n<hr>\n<p>In the next article, I'll explain what JavaScript optimization technics allowed me to optimize Ability creation <strong>by more than 15x times</strong>! Stay tuned!</p>","headings":[["the-harness","The harness"],["abstract-syntax-tree","Abstract Syntax Tree"],["mongo-db-query-parser","MongoDB query Parser"],["interpreter-or-code-generator","Interpreter or Code Generator?"],["conclusion","Conclusion"]],"id":"casl-pursuing-perfection-new-engine"}