{"title":"Составные наблюдатели в KnockOut","summary":"Что если одно из свойств View модели зависит от значения других? Опираясь на\nпрофессиональную лень предположу, что было бы хорошо, если бы оно\nпересчитывалось автоматически при изменении одного из свойств от которого\nзависит, без участия посторонних сил. Для этого в KnockOut и реализованы\nсоставные свойства\n","author":"sstotskyi","categories":["frontend"],"createdAt":"2012-04-09T11:14:00.000Z","meta":{"keywords":["javascript","knockout","observables"]},"alias":"sostavnye-nablyudateli-v-knockout","content":"<p>Представим ситуацию, ViewModel имеет 2 <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;javascript/show-66-knockout-nabliudaem-za-vsem-i-vezde&quot;}\">наблюдаемых свойства</app-link>: (<em>firstName</em>, <em>lastName</em>) и нужно вывести <em>fullName</em> (<em>firstName</em> + <em>lastName</em>). Т.е. при изменении <em>lastName</em> или <em>firstName</em>, <em>fullName</em> должен автоматически обновится. В этом деле помогут составные наблюдатели</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AppViewModel</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.firstName = ko.observable(<span class=\"hljs-string\">'Bob'</span>);\n    <span class=\"hljs-keyword\">this</span>.lastName  = ko.observable(<span class=\"hljs-string\">'Smith'</span>);\n\n    <span class=\"hljs-keyword\">this</span>.fullName  = ko.computed(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.firstName() + <span class=\"hljs-string\">\" \"</span> + <span class=\"hljs-keyword\">this</span>.lastName();\n    }, <span class=\"hljs-keyword\">this</span>);\n}\n</code></pre>\n<p>Теперь можно сделать байнд свойства к тегу</p>\n<pre><code class=\"hljs language-html\">The name is <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"text: fullName\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n</code></pre>\n<p>и <em>View</em> будет обновляться при изменении <em>firstName</em> или <em>lastName в соответствии</em> с анонимной функцией, которая передана в качестве первого аргумента.</p>\n<h2 id=\"upravlenie-skoupom\"><a name=\"upravlenie-skoupom\" class=\"h-link\" href=\"#\"></a>Управление скоупом</h2>\n<p>Если Вы не опытный <em>JavaScript</em> разработчик, то может показаться странным, что вторым параметром в метод <strong>computed</strong> передана переменная <strong>this</strong>. На самом деле здесь нет ничего странного, потому как в <em>JavaScript</em> функции являются полноценными объектами не привязанными к какому-то конкретному контексту (если же конечно не указать его прямо). А это значит, что если бы мы не передали <strong>this</strong> в качестве второго параметра, то не было бы возможности обратится к свойствам <em>ViewModel</em>.</p>\n<p>Если все это кажется напряжным, то можно создать замыкание на <strong>this</strong> следующим образом и забыть о скоупах</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AppViewModel</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\n\n    self.firstName = ko.observable(<span class=\"hljs-string\">'Bob'</span>);\n    self.lastName = ko.observable(<span class=\"hljs-string\">'Smith'</span>);\n    self.fullName = ko.computed(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-keyword\">return</span> self.firstName() + <span class=\"hljs-string\">\" \"</span> + self.lastName();\n    });\n}\n</code></pre>\n<h2 id=\"napisanie-sostavnyh-svojstv\"><a name=\"napisanie-sostavnyh-svojstv\" class=\"h-link\" href=\"#\"></a>Написание составных свойств</h2>\n<p>Так как составные свойства состоят из нескольких наблюдаемых, то логично было бы предположить, что их можно только читать. Но в KO предусмотрен <strong>callback</strong>, с помощью которого можно сделать что-то полезное со значениями из которого оно состоит.</p>\n<p>Например, если нужно отобразить цену для пользователя со знаком валюты, округленное до второй цифры после комы, но чтобы само значение хранилось в модели, как число с плавающей точкой (<strong>float</strong>).</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">MyViewModel</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.price = ko.observable(<span class=\"hljs-number\">25.99</span>);\n\n    <span class=\"hljs-keyword\">this</span>.formattedPrice = ko.computed({\n        <span class=\"hljs-attr\">read</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"$\"</span> + <span class=\"hljs-keyword\">this</span>.price().toFixed(<span class=\"hljs-number\">2</span>);\n        },\n        <span class=\"hljs-attr\">write</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>{\n            <span class=\"hljs-comment\">// Strip out unwanted characters, parse as float, then write the raw data back to the underlying \"price\" observable</span>\n            value = <span class=\"hljs-built_in\">parseFloat</span>(value.replace(<span class=\"hljs-regexp\">/[^\\.\\d]/g</span>, <span class=\"hljs-string\">\"\"</span>));\n            <span class=\"hljs-keyword\">this</span>.price(<span class=\"hljs-built_in\">isNaN</span>(value) ? <span class=\"hljs-number\">0</span> : value); <span class=\"hljs-comment\">// Write to underlying storage</span>\n        },\n        <span class=\"hljs-attr\">owner</span>: <span class=\"hljs-keyword\">this</span>\n    });\n}\n\nko.applyBindings(<span class=\"hljs-keyword\">new</span> MyViewModel());\n</code></pre>\n<p>Чаще всего в качестве параметра в метод computed передается анонимная функция, которая отвечает за чтение свойства, но также можно передать и объект со следующими параметрами</p>\n<ul>\n<li><strong>read</strong> -  обязательный, <em>callback</em> для чтения свойства</li>\n<li><strong>write</strong> - необязательный, <em>callback</em> для записи свойства</li>\n<li><strong>owner</strong> - необязательный, объект в скоупе, которого будут запускаться <em>read</em> и <em>write</em> анонимный функции</li>\n</ul>\n<p>Теперь можно привязать цену к элементу на странице</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Enter bid price: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"value: formattedPrice\"</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></pre>\n<p>Когда пользователь изменит цену и уберет фокус с поля, значение в модели автоматически обновится и будет числом с плавающей точкой, а не строкой благодаря <strong>write</strong> <em>callback</em>-у.</p>\n<p>Другой пример с валидацией пользовательских данных. Например, нужно проверять, чтобы пользователь обязательно ввел число в текстовое поле. Для этого понадобится 2 свойства: <em>numericValue</em>, <em>isLasInputValid</em>. Оба наблюдаемые</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">AppViewModel</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.numericValue = ko.observable(<span class=\"hljs-number\">123</span>);\n    <span class=\"hljs-keyword\">this</span>.isLastInputValid = ko.observable(<span class=\"hljs-literal\">true</span>);\n\n    <span class=\"hljs-keyword\">this</span>.attemptedValue = ko.computed({\n        <span class=\"hljs-attr\">read</span>: <span class=\"hljs-keyword\">this</span>.numericValue,\n        <span class=\"hljs-attr\">write</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>{\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">isNaN</span>(value)) {\n                <span class=\"hljs-keyword\">this</span>.isLastInputValid(<span class=\"hljs-literal\">false</span>);\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">this</span>.isLastInputValid(<span class=\"hljs-literal\">true</span>);\n                <span class=\"hljs-keyword\">this</span>.numericValue(value)\n            }\n        },\n        <span class=\"hljs-attr\">owner</span>: <span class=\"hljs-keyword\">this</span>\n    });\n}\n\nko.applyBindings(<span class=\"hljs-keyword\">new</span> AppViewModel());\n</code></pre>\n<p>Привяжем свойства к странице</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Enter a numeric value: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"value: attemptedValue\"</span>/&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"visible: !isLastInputValid()\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"error\"</span>&gt;</span>That's not a number!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>Теперь <strong>numericValue</strong> будет иметь только валидное числовые значение, а если пользователь введет не число, то увидит сообщение об ошибке. Но для таких простых проверок лучше использовать <em>jQuery Validation</em>, установив полю класс <strong>number</strong>. КО отлично работает с <em>jQuery</em> и  примером тому является <a href=\"http://knockoutjs.com/examples/gridEditor.html\" target=\"_blank\" rel=\"noopener nofollow\">редактируемая таблица</a>.</p>\n<p>А алгоритм с КО следует использовать когда валидация или фильтрация данных более сложная чем та которая реализована в <em>jQuery Validation</em>.</p>\n<h2 id=\"princzip-raboty-mehanizma-otslezhivaniya-zavisimostej\"><a name=\"princzip-raboty-mehanizma-otslezhivaniya-zavisimostej\" class=\"h-link\" href=\"#\"></a>Принцип работы механизма отслеживания зависимостей</h2>\n<p>В общем алгоритм очень простой и довольно красивый</p>\n<ol>\n<li>Когда определено составное свойство, КО сразу же вызывает <em>callback</em>, чтобы получить начальное значение свойства.</li>\n<li>Во время работы <em>callback</em>-а, КО логирует все наблюдаемые (или составные) свойства, которые используются в нем.</li>\n<li>Когда <em>callback</em> закончит работу, КО подпишет это составное свойство на все наблюдаемые (или составные) атрибуты <strong>ViewModel</strong>, к которым обращались. Так же устанавливается обратный подписчик, чтобы вызвать повторный запуск <em>callback</em>, замыкая весь процесс на 1-ый шаг, чтобы удалить все старые подписки.</li>\n<li>КО уведомит всех подписчиков о новом значении составного свойства.</li>\n</ol>\n<p>То есть КО определяет зависимости не только во время первого вызова <strong>callback</strong>, а каждый раз заново. А это значит, что зависимости могут быть динамическими. Зависимости не нужно определять они вычисляются автоматически во время работы скрипта.</p>\n<p>Декларативные байндинги реализованы как составные наблюдаемые свойства. А это значит, что когда банйдинг читает зависимое значение свойства, то он становится зависимым от последнего.  И это в свою очередь означает, что значение байндинга будет изменятся при изменении свойства.</p>\n<p><strong>P.S.</strong>: все примеры можно попробовать запустить <a href=\"http://learn.knockoutjs.com/\" target=\"_blank\" rel=\"noopener nofollow\">здесь</a></p>\n<p><strong>По материалам</strong>: <a href=\"http://knockoutjs.com/documentation/computedObservables.html\" target=\"_blank\" rel=\"noopener nofollow\">KnockOut</a></p>","headings":[["upravlenie-skoupom","Управление скоупом"],["napisanie-sostavnyh-svojstv","Написание составных свойств"],["princzip-raboty-mehanizma-otslezhivaniya-zavisimostej","Принцип работы механизма отслеживания зависимостей"]],"id":"sostavnye-nablyudateli-v-knockout"}