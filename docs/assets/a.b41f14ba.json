{"title":"Best practisies в Knockout: упрощаем view","summary":"Одним из моих подручных инструментов для реализации single page application-ов\nстал Knockout. И я хочу поделится некоторыми трюками для написания хорошего\nкода с использованием этого чудесного фреймворка.\n","author":"sstotskyi","categories":["frontend","important"],"createdAt":"2013-03-25T12:29:00.000Z","meta":{"keywords":["knockout","MVVM","view","template"]},"alias":"best-practisies-v-knockout-uproschaem-view","content":"<p>Последний год я имел удовольствие работать над созданием так называемых <em>single page application</em>-ов, используя новейшие технологии, такие как: <strong>MV*</strong> <em>based frameworks</em>, <strong>HTML5</strong>, <strong>CSS3</strong>.</p>\n<p>Одним из моих подручных инструментов стал <strong>Knockout</strong>. Это удивительный фреймворк: когда думаешь, что уже все о нем знаешь, пишешь код достаточно долго, изменяешь стандартное поведение, создаешь вложенные <em>View Model</em>-и - найдется, что-то новое, загадочное и до трепета программистских чувств волнительное полезное.</p>\n<p>К сожалению, существует не так уж много хороших примеров по применению <em>Knockout</em> (есть один <a href=\"http://www.knockmeout.net/\" target=\"_blank\" rel=\"noopener nofollow\">хороший блог</a>). Вот и я узнав пару тройку трюков, хочу ими поделиться.</p>\n<h2 id=\"sozdavajte-chitabelnoe-view\"><a name=\"sozdavajte-chitabelnoe-view\" class=\"h-link\" href=\"#\"></a>Создавайте читабельное View</h2>\n<p><em>Knockout</em>, так сказать, рекомендует декларативный стиль для создания шаблонов, более того он дает для этого все инструменты. Это значит, что <em>data-bind</em> должен быть максимально простым и максимально читабельным. Чтобы шаблоны можно было &quot;читать&quot; добавляйте <em>dependent observable</em>-ы. Допустим у есть <em>view model</em>:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> ViewModel = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.items = ko.observableArray();\n};\n</code></pre>\n<p>Плохо:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"visible: !items().length\"</span>&gt;</span>There are no items<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>Если читать код, упуская синтаксические конструкции, получается: <em>&quot;There are no items&quot; visible not items length</em> или <em>&quot;There are no items&quot;</em> <em>visible items length equals 0</em>. Хотя и понятно, но не читабельно. Всегда читайте свой код, если код прозрачный, эффективный и может быть переиспользован - его можно прочесть, как обычное предложение на английском (понятно, что без сахара не обойтись, но лучше добавить сахар чем потом писать кучу документации). Придерживайтесь правила: никаких комментариев, минимум документации.</p>\n<p>Чтобы улучшить предыдущий пример, нужно добавить новое <em>computed</em> свойство - <em>hasItems</em>. Логично, что модель которая имеет массив айтемов имеет метод <em>hasItems</em>. Тем более, любую логику относящуюся к внутренней реализации нужно прятать от вьюхи. В будущем внутренняя реализация модели может изменяться и при таких условиях хотелось бы оставить шаблон без изменений.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> ViewModel = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.items = ko.observableArray();\n  <span class=\"hljs-keyword\">this</span>.hasItems = ko.computed(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.items().length &gt; <span class=\"hljs-number\">0</span>\n  }, <span class=\"hljs-keyword\">this</span>);\n};\n</code></pre>\n<p>Хорошо:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"ifnot: hasItems\"</span>&gt;</span>There are no items<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>Попробуем прочитать: <em>&quot;There are no items&quot; if not has items</em>. Уже на много лучше!</p>\n<h2 id=\"unichtozhajte-zlo\"><a name=\"unichtozhajte-zlo\" class=\"h-link\" href=\"#\"></a>Уничтожайте зло</h2>\n<p>Никогда не используйте анонимные ф-ции внутри байндингов, если так хочется передать параметры в метод используйте метод <em>bind</em>, а лучше - <em>data-*</em> атрибуты, они для этого и были придуманы.</p>\n<p>Плохо:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"click: function(vm, event) { $data.doSmth(event, 'param_1', 'param_2') }\"</span>&gt;</span>Click Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></pre>\n<p>Чуть лучше, но ставит в зависимость от последовательности передаваемых аргументов:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"click: doSmth.bind($data, 'param_1', 'param_2')\"</span>&gt;</span>Click Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></pre>\n<p>Хорошо:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"clickWithData: doSmth\"</span> <span class=\"hljs-attr\">data-param1</span>=<span class=\"hljs-string\">\"param_1\"</span> <span class=\"hljs-attr\">data-param2</span>=<span class=\"hljs-string\">\"param_2\"</span>&gt;</span>Click Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n</code></pre>\n<p><em>clickWithData</em> байндинг - нестандартный (его реализация занимает пару минут): первым аргументом в метод <em>doSmth</em> передается хэш <em>data</em> атрибутов. Такой подход намного более гибкий: нет зависимости от последовательности передаваемых аргументов и делает шаблон более прозрачным.</p>\n<h2 id=\"umenshajte-kolichestvo-bajndingov\"><a name=\"umenshajte-kolichestvo-bajndingov\" class=\"h-link\" href=\"#\"></a>Уменьшайте количество байндингов</h2>\n<p>Допустим есть таблица. Нужно сделать, чтобы по нажатию на названия колонок происходила сортировка и соответственно колонка по которой отсортирована таблица должна иметь стрелочку вверх/вниз. Конечно же, первое что приходит в голову:</p>\n<p>Плохо:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"table\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">thead</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"click: sortBy.bind($data, 'name'), css: classForColumn('name')\"</span>&gt;</span>Name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span> \n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"click: sortBy.bind($data, 'status'), css: classForColumn('status')\"</span>&gt;</span>Status<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"click: sortBy.bind($data, 'created_at'), css: classForColumn('created_at')\"</span>&gt;</span>Created At<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">thead</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tbody</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tbody</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span>\n</code></pre>\n<p>С увеличением колонок, код мягко говоря станет ужасным, а что если надо будет добавить еще какой-то байндинг... Здесь существует 3 проблемы:</p>\n<ul>\n<li>во-первых, слишком много байндингов на сантиметр квадратный</li>\n<li>во-вторых, метод <strong>bind</strong> ухудшает чтение, используйте его в самом крайнем случае (к тому же создает замыкание на каждую колонку)</li>\n<li>в третьих, дублирование названий колонок</li>\n</ul>\n<p>Чтобы решить эту проблему придется написать 2 собственных байндинга. Первый решает проблему с читабельностью, а второй с множеством <em>event handler</em>-ов и <em>bind</em> методом. Помните, кастомные байндинги должны быть максимально абстрактными, чтобы можно было использовать в любом месте.</p>\n<p>Создадим байндинг <strong>setChildrenCss</strong>, который пройдет по всем дочерним элементам и применит на них стандартный <em>css binding</em>:</p>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">cssBinding</span>) </span>{\n  ko.bindingHandlers.setChildrenCss = {\n    <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">element, valueAccessor, allBindingsAccessor, viewModel</span>) </span>{\n      <span class=\"hljs-keyword\">var</span> rules = ko.utils.unwrapObservable(valueAccessor());\n      <span class=\"hljs-keyword\">var</span> children = ko.utils.arrayFilter(element.childNodes, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">child</span>) </span>{\n        <span class=\"hljs-keyword\">return</span> child.nodeType == <span class=\"hljs-number\">1</span>;\n      });\n\n      <span class=\"hljs-keyword\">var</span> updater;\n      <span class=\"hljs-keyword\">if</span> (rules.call) {\n        rules = rules.bind(viewModel);\n        updater = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">child</span>) </span>{\n          <span class=\"hljs-keyword\">var</span> nodeName = child.getAttribute(<span class=\"hljs-string\">'data-name'</span>);\n          cssBinding.update(child, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{ <span class=\"hljs-keyword\">return</span> rules(nodeName) });\n        };\n      } <span class=\"hljs-keyword\">else</span> {\n        updater = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">child</span>) </span>{ cssBinding.update(child, valueAccessor) };\n      }\n      ko.utils.arrayForEach(children, updater);\n    }\n  };\n})(ko.bindingHandlers.css);\n</code></pre>\n<p>Этот байндинг в качестве параметра может принимать, такие же значения как и его ровесник <em>css</em>, а также ф-цию, в которую передает атрибут <em>data-name</em> - имя <em>DOM</em> элемента. Используя этот байндинг предыдущий пример можно записать:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"table\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">thead</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"setChildrenCss: classForColumn\"</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span> <span class=\"hljs-attr\">data-name</span>=<span class=\"hljs-string\">\"name\"</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"click: sortBy.bind($data, 'name')\"</span>&gt;</span>Name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span> \n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span> <span class=\"hljs-attr\">data-name</span>=<span class=\"hljs-string\">\"status\"</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"click: sortBy.bind($data, 'status')\"</span>&gt;</span>Status<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span> <span class=\"hljs-attr\">data-name</span>=<span class=\"hljs-string\">\"created_at\"</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"click: sortBy.bind($data, 'created_at')\"</span>&gt;</span>Created At<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">thead</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tbody</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tbody</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span>\n</code></pre>\n<p>Стало чуть лучше, но <em>click</em> байндинг все еще портит весь пейзаж. Для решения этой проблемы напишем новый <em>on data-binding</em> c использованием <strong>jquery</strong> и его метода <strong>on</strong>.</p>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">$</span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">lookupMethodIn</span>(<span class=\"hljs-params\">context, methodName</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> scopes = [ context.$data ].concat(context.$parents), i = <span class=\"hljs-number\">0</span>, count = scopes.length;\n      \n    <span class=\"hljs-keyword\">do</span> {\n      <span class=\"hljs-keyword\">var</span> scope = scopes[i];\n    } <span class=\"hljs-keyword\">while</span> (++i &lt; count &amp;&amp; !(scope[methodName] &amp;&amp; scope[methodName].call));\n      \n    <span class=\"hljs-keyword\">if</span> (!scope[methodName] || !scope[methodName].call) {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'Unknown method \"'</span> + methodName + <span class=\"hljs-string\">'\" in context'</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> scope[methodName].bind(scope);\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createEventHandlerFor</span>(<span class=\"hljs-params\">config, rule</span>) </span>{\n    <span class=\"hljs-keyword\">var</span> methodName = config[rule], dataKey = ko.utils.unwrapObservable(config.data);\n    \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>{\n      <span class=\"hljs-keyword\">var</span> context = ko.contextFor(<span class=\"hljs-keyword\">this</span>), data = $(<span class=\"hljs-keyword\">this</span>).data(dataKey);\n      <span class=\"hljs-keyword\">if</span> (data.bind) {\n        <span class=\"hljs-keyword\">delete</span> data.bind;\n      }\n      <span class=\"hljs-keyword\">var</span> method = lookupMethodIn(context, methodName);\n      <span class=\"hljs-keyword\">var</span> result = method(data, context.$data, event);\n      <span class=\"hljs-keyword\">if</span> (result !== <span class=\"hljs-literal\">true</span>) {\n        event.preventDefault();\n      }\n    };\n  }\n\n  ko.bindingHandlers.on = {\n    <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">element, valueAccessor, allBindings, viewModel</span>) </span>{\n      <span class=\"hljs-keyword\">var</span> config = valueAccessor(), domNode = $(element);\n      \n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> rule <span class=\"hljs-keyword\">in</span> config) {\n        <span class=\"hljs-keyword\">if</span> (config.hasOwnProperty(rule)) {\n          <span class=\"hljs-keyword\">var</span> handler = createEventHandlerFor(config, rule);\n          rule = rule.split(<span class=\"hljs-regexp\">/\\s+/</span>, <span class=\"hljs-number\">2</span>);\n          <span class=\"hljs-keyword\">if</span> (rule[<span class=\"hljs-number\">1</span>]) {\n            domNode.on(rule[<span class=\"hljs-number\">0</span>], rule[<span class=\"hljs-number\">1</span>], handler);\n          } <span class=\"hljs-keyword\">else</span> {\n            domNode.on(rule[<span class=\"hljs-number\">0</span>], handler);\n          }\n        }\n      }\n    }\n  };\n})(jQuery);\n</code></pre>\n<p>Байндинг принимает в качестве параметра хэш событий и обработчиков. Имя события может быть расширено <em>css</em> селектором (&quot;<em>click a</em>&quot;, &quot;<em>mouseenter .item</em>&quot;). В конечном итоге первоначальный шаблон выглядит так:</p>\n<p>Хорошо:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"table\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">thead</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"on: { 'click th': 'sortBy', data: 'name' }, setChildrenCss: classForColumn\"</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span> <span class=\"hljs-attr\">data-name</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>Name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span> \n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span> <span class=\"hljs-attr\">data-name</span>=<span class=\"hljs-string\">\"status\"</span>&gt;</span>Status<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n     <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span> <span class=\"hljs-attr\">data-name</span>=<span class=\"hljs-string\">\"created_at\"</span>&gt;</span>Created At<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">thead</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tbody</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tbody</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span>\n</code></pre>\n<p>Можно прочесть: <em>on click - th sort by data name and set children css class for column</em>.</p>\n<p>Созданный байндинг <strong>on</strong> решает как минимум 3 задачи:</p>\n<ul>\n<li>делает шаблоны более простыми и читабельными (чистота и порядок - свойства качественного кода)</li>\n<li>уменьшает к-во создаваемых обработчиков событий (уменьшение используемых ресурсов)</li>\n<li>реализовывает механизм передачи параметров в хэндлеры посредством <em>data-*</em> атрибутов (гибкость для методов <em>view model</em>-и)</li>\n</ul>\n<p>На счет делегирования событий можно ознакомится и с <a href=\"http://www.knockmeout.net/2012/11/revisit-event-delegation-in-knockout-js.html\" target=\"_blank\" rel=\"noopener nofollow\">другой реализацией</a>.</p>\n<p><strong>P.S.</strong>: <em>Knockout</em> предоставляет очень мощные инструменты, не бойтесь их использовать, усовершенствовать и добавлять свои.</p>","headings":[["sozdavajte-chitabelnoe-view","Создавайте читабельное View"],["unichtozhajte-zlo","Уничтожайте зло"],["umenshajte-kolichestvo-bajndingov","Уменьшайте количество байндингов"]],"id":"best-practisies-v-knockout-uproschaem-view"}