{"title":"Magento модели от А до Я: модели ядра","summary":"Поскольку Magento построена, как MVC приложение, то было бы логичным найти в\nбазовом функционале подобие ORM или ActiverRecord. Для четкого разделения\nфункицонала модели разделены на 2 типа: отвечающие за бизнес логику и за\nпредоставление данных.\n","author":"sstotskyi","categories":["backend","important"],"createdAt":"2012-02-24T18:49:00.000Z","meta":{"keywords":["magento","модели"]},"alias":"magento-modeli-ot-a-do-ya-modeli-yadra","content":"<p>Поскольку Magento построена, как MVC приложение, то было бы логичным найти в базовом функционале подобие <em><a href=\"http://ru.wikipedia.org/wiki/ORM\" target=\"_blank\" rel=\"noopener nofollow\">ORM</a></em> или <em><a href=\"http://ru.wikipedia.org/wiki/ActiveRecord\" target=\"_blank\" rel=\"noopener nofollow\">ActiverRecord</a></em>. Для четкого разделения функицонала модели разделены на 2 типа: отвечающие за бизнес логику и за предоставление данных. Последние обычно работают с базой данных, но это может быть и что угодно другое (<em>csv</em>, <em>plain text</em>, <em>etc</em>.). Бизнес и ресурс модели связаны между собой посредством <app-link to=\"page\" title=\"Magento module configuration\" params=\"{&quot;id&quot;:&quot;php_and_somethings/show-59-magento-konfighuratsiia-ot-a-do-ia-bazovye-nastroiki-modulia&quot;}\">конфигурации модуля</app-link>. Для работы с базой и определения бизнес логики существуют 3 абстрактных класса: <strong>Mage_Core_Model_Abstract</strong>, <strong>Mage_Core_Model_Mysql4_Abstract</strong>, <strong>Mage_Core_Model_Mysql4_Collection_Abstract</strong>. Начиная с версии 1.6 в именах моделей <em>Mysql4</em> заменено на <em>Resource</em> в связи с реализацией поддержки разных СУБД в Magento.</p>\n<h2 id=\"biznes-modeli\"><a name=\"biznes-modeli\" class=\"h-link\" href=\"#\"></a>Бизнес модели</h2>\n<p>Обычно все бизнес модели наследуются от <em>Mage_Core_Model_Abstract.</em> Поскольку в последнем реализован базовый функционал работы с ресурс моделью. Сам же класс наследует весь функционал <em>Varien_Object.</em> Это очень удобно, потому что он реализовывает магические методы доступа к данным. Любая таблица имеет набор полей и строк. Одна бизнес модель - одна строка в базе. Например для блоков сайта существует таблица <strong>cms_block</strong>. Она имеет поле <em>title</em>. Чтобы получить его значение для определенного блока достаточно написать</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-keyword\">echo</span> $cmsBlock-&gt;getTitle();\n</code></pre>\n<p>Аналогично со всеми другими полями. Нужно придерживаться правила: в базе, в именах сложных полей, слова разделять при помощи нижнего подчеркивания, каждое слово с маленькой буквы, например <em>is_active</em>. Тогда в коде через бизнес моделей к этому полю можно обратится при помощи выражения</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-keyword\">echo</span> $cmsBlock-&gt;getIsActive();\n</code></pre>\n<p>Класс имеет несколько интересных свойств: <strong>$_eventPrefix</strong>, <strong>$_eventObject</strong> и <strong>$_isObjectNew</strong>. Первый позволяет задать префикс для событий в классе наследнике (по умолчанию значение равно <em>core_abstract</em>), второй задает имя параметра в объекте события для получения модели (по умолчанию <em>object</em>), а третий определяет является ли объект новым созданным или загруженым из ресурс модели (обычно это база данных).</p>\n<p>Класс выбрасывает следующие события:</p>\n<ul>\n<li><em>model_load_before</em>, <em>$_eventPrefix + ' _load_before</em>' - вызываются в момент загрузки модели, вызов метода <strong>load</strong></li>\n<li><em>model_load_after, $_eventPrefix + '+load_after'</em> - вызываются после загрузки модели</li>\n<li><em>model_save_commit_after, $_eventPrefix + '_save_commit_after'</em> - вызывается внутри ресурс модели, перед комитом транзакции</li>\n<li><em>model_save_before, $_eventPrefix + '_save_before'</em> - вызывается перед сохранением данных, вызов метода <strong>save</strong></li>\n<li>model_save_after, $_eventPrefix + '_save_after' - вызывается после сохранения модели</li>\n<li><em>model_delete_before, $_eventPrefix + '_delete_before'</em> - вызывается перед удалением данных, вызов метода <strong>delete</strong></li>\n<li><em>model_delete_after, $_eventPrefix + 'delete_after'</em> - вызывается после удаление данных</li>\n<li><em>$_eventPrefix + '_clear'</em> - вызывается во время очистки объекта от циклических ссылок, вызов метода <strong>clearInstance</strong> (появился с версии 1.5.1.0)</li>\n</ul>\n<p>Во всех случаях когда подряд вызывается 2 события, во втором в качестве параметров передается массив, который можно изменять при помощи защищенной ф-ции <em>_getEventData</em> в каждом классе наследнике отдельно.</p>\n<p>Бизнес модель имеет несколько основных открытых методов, о которых я уже упомянул:</p>\n<ul>\n<li><strong>load</strong> - загружает данные в модель. Принимает 2 параметра: значение по которому нужно искать (primary или unique поле) и второй, необязательный, имя поля по которому нужно искать, по умолчанию используется поле primary key</li>\n<li><strong>save</strong> - сохраняет данные</li>\n<li><strong>delete</strong> - удаляет данные, в случае с СУБД, строку из базы</li>\n<li><strong>isObjectNew</strong> - проверяет является ли объект загруженым из базы или создан. Не рекомендую использовать его для проверки! По скольку он возвращает установлено ли значение идентификатора для модели (строки базы, primary key). Для проверки лучше использовать метод <strong>getOrigData()</strong> - возвращает массив  реальных не измененных данных, которые находятся в базе для этой модели. Если массив пуст значит объект &quot;новый&quot;, если нет - значит нет</li>\n<li><strong>hasDataChanges</strong> - проверяет изменились ли данные</li>\n<li><strong>cleanModelCache</strong> - чистит кэш для этой модели по тегам</li>\n<li><strong>clearInstance</strong> - удаляет циклические ссылки для модели (в основном используется для моделей продуктов). Когда Вы уверенны, что объект продукта больше не нужен вызывайте этот метод. Это предотвратит возможные утечки памяти (метод доступный с версии 1.5.1.0)</li>\n<li><strong>getResource</strong> - возвращает ресурс модель</li>\n</ul>\n<p>Например, для моделей <em>CMS</em> блоков</p>\n<pre><code class=\"hljs language-php\">$block = Mage::getModel(<span class=\"hljs-string\">'cms/block'</span>)\n    -&gt;setStoreId(Mage::app()-&gt;getStore()-&gt;getId())\n    -&gt;load(<span class=\"hljs-number\">12</span>);\n\n<span class=\"hljs-keyword\">echo</span> $block-&gt;getId(); <span class=\"hljs-comment\"># 12</span>\n\n$block-&gt;setTitle(<span class=\"hljs-string\">'Test CMS Block'</span>)\n    -&gt;save();\n\n$block = Mage::getModel(<span class=\"hljs-string\">'cms/block'</span>)-&gt;setId(<span class=\"hljs-number\">33</span>);\n\nvar_dump($block-&gt;isObjectNew()); <span class=\"hljs-comment\"># false, ERROR!</span>\n\n$isObjectNew = <span class=\"hljs-keyword\">empty</span>($block-&gt;getOrigData());\nvar_dump($isObjectNew); <span class=\"hljs-comment\"># true</span>\n</code></pre>\n<h2 id=\"resurs-modeli\"><a name=\"resurs-modeli\" class=\"h-link\" href=\"#\"></a>Ресурс модели</h2>\n<p>Ресурс модели предоставляют интерфейс для получения данных. Для выборки данных используется <a href=\"http://framework.zend.com/manual/ru/zend.db.select.html\" target=\"_blank\" rel=\"noopener nofollow\"><em>Zend_Db_Select</em></a>. Для инициализации модели в классе есть защищенный метод <strong>_init</strong>, который принимает 2 параметра: <em>table-path</em> (например <em>catalog/product</em>) и имя <em>PRIMARY</em> поля (уникального идентификатора строки в таблице).</p>\n<p>В качестве примера можно посмотреть, как это сделано в модуле <em>Mage_Cms</em> для блоков</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Mage_Cms_Model_Mysql4_Block</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Mage_Core_Model_Mysql4_Abstract</span>\n</span>{\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_construct</span><span class=\"hljs-params\">()</span>\n    </span>{\n        <span class=\"hljs-keyword\">$this</span>-&gt;_init(<span class=\"hljs-string\">'cms/block'</span>, <span class=\"hljs-string\">'block_id'</span>);\n    }\n............................................................\n}\n</code></pre>\n<p>Получить реальное имя таблицы (так как она называется в базе данных) можно при помощи метода <strong>getTable()</strong>, который принимает единственный параметр <em>table-path</em>.</p>\n<p>В <em>Magento</em> за чтение и запись отвечают разные объекты соединений. Получить доступ к ним внутри класса можно при помощи методов <strong>_getReadAdapter</strong> и <strong>_getWriteAdapter</strong> соответственно. Объект <em>SELECT</em>-а можно получить только при помощи <em>read</em> соединения, а вставка и обновление данных происходит при участии <em>write</em> соединения. Например, класс имеет защищенный метод <strong>_getLoadSelect</strong>, который возвращает объект <em>SELECT</em>-а, так давайте посмотрим что там внутри</p>\n<pre><code class=\"hljs language-php\">$select = <span class=\"hljs-keyword\">$this</span>-&gt;_getReadAdapter()-&gt;select()\n   -&gt;from(<span class=\"hljs-keyword\">$this</span>-&gt;getMainTable())\n   -&gt;where(<span class=\"hljs-keyword\">$this</span>-&gt;getMainTable().<span class=\"hljs-string\">'.'</span>.$field.<span class=\"hljs-string\">'=?'</span>, $value);\n</code></pre>\n<p>Эта строка вызывается для загрузки данных в методе <strong>load</strong>, который принимает 3 параметра: объект бизнес модели, значение поля, по-которому ищем и третий необязательный имя поля по-которому ищем. Если последний параметр не передать, то в качестве поля по-которому будет происходить поиск будет использован <em>PRIMARY KEY</em>.</p>\n<p>Также класс имеет метод <strong>save</strong> с единственным параметром - объект бизнес модели. Внутри него происходят разные проверки, например, на уникальность некоторых полей, что нужно делать <em>update</em> или <em>insert</em>, определяются поля таблицы при помощи запроса <em>DESCRIBE TABLE</em> (выполнение запроса кэшируется). Метод <strong>delete</strong> также принимает только один параметр - бизнес модель.</p>\n<p>В отличии от бизнес модели, ресурс модель предоставляет не события при выполнении <a href=\"http://ru.wikipedia.org/wiki/CRUD\" target=\"_blank\" rel=\"noopener nofollow\"><em>CRUD</em></a> методов, а хуки. Каждый из последних в качестве параметра принимают бизнес модель. Просто перечислим их, по названиях можно догадаться когда они вызываются</p>\n<ul>\n<li><em>_afterLoad</em></li>\n<li><em>_beforeSave</em></li>\n<li><em>_afterSave</em></li>\n<li><em>_beforeDelete</em></li>\n<li><em>_afterDelete</em></li>\n</ul>\n<p>Данный класс также имеет еще одно полезное свойство - <strong>$_serializableFields</strong>. Это массив. В нем можно указать, какие поля в базе хранятся в сериализированом виде и при загрузке модели они автоматически будут десереализированы. Структура массива следующая</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-comment\">/**\n * Structure: array(\n *     &lt;field_name&gt; =&gt; array(\n *         &lt;default_value_for_serialization&gt;,\n *         &lt;default_for_unserialization&gt;,\n *         &lt;whether_to_unset_empty_when serializing&gt; // optional parameter\n *     ),\n * )\n *\n */</span>\n</code></pre>\n<p>При сохранении данных будет произведено обратное действие над такими полями. Это позволяет не думать о формате хранения и сосредоточится на бизнес логике.</p>\n<p>Также при помощи метода <strong>addUniqueField</strong> можно добавить имена уникальных полей и при сохранении <em>Magento</em> проверит их уникальность. Но это не очень удобный способ.</p>\n<h2 id=\"psevdo-resurs-modeli\"><a name=\"psevdo-resurs-modeli\" class=\"h-link\" href=\"#\"></a>Псевдо-ресурс модели</h2>\n<p>К этому типу было решено (мною) отнести классы коллекций. Так как они находятся среди ресурс моделей (по причине того, что они делают запрос в базу на выборку множества строк), но по сути являются контейнером для бизнес моделей, которые в свою очередь зависят от ресурс моделей. Какой-то замкнутый круг. Я думаю, что это кодоляп. Разработчики не захотели усложнять коллекции, по-этому в таких классах можно увидеть смешанную бизнес и ресурс логику.</p>\n<p>Класс коллекции <strong>Mage_Core_Model_Mysql4_Collection_Abstract</strong> является потомком <strong>Varien_Data_Collection_Db</strong>, который рассматривался <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;php_and_somethings/show-61-magento-modeli-ot-a-do-ia-3-kita&quot;}\">в предыдущей статье</app-link>. Как и ресурс модель он инициализируется при помощи метода <strong>_init</strong>, который принимает один обязательный параметр <em>Magento-path</em> бизнес модели и второй необязательный <em>Magento-path</em> ресурс модели, если не задан, то второй равен первому.</p>\n<p>Имя основной таблицы можно получить при помощи метода <strong>getMainTable()</strong> (аналогичный существует в классе ресурс модели). Объект запроса можно получить вызвав метод <strong>getSelect()</strong>. В классе <em>Zend_Db_Select</em> реализован магический метод <strong>__toString</strong>, который превращает объект в строку <em>SQL</em> запроса.</p>\n<p>Для выборки значения в котором присутствуют <em>SQL</em> ф-ции реализован интересный метод <strong>addExpressionFieldToSelect</strong>. Но использовать его я не рекомендую. Лучше написать отдельный метод для коллекции чем мешать логику. Приведу <em>php-doc</em> из источников</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-comment\">/**\n * Add attribute expression (SUM, COUNT, etc)\n *\n * Example: ('sub_total', 'SUM({{attribute}})', 'revenue')\n * Example: ('sub_total', 'SUM({{revenue}})', 'revenue')\n *\n * For some functions like SUM use groupByAttribute.\n *\n * <span class=\"hljs-doctag\">@param</span> string $alias\n * <span class=\"hljs-doctag\">@param</span> string $expression\n * <span class=\"hljs-doctag\">@param</span> array $fields\n * <span class=\"hljs-doctag\">@return</span> Mage_Eav_Model_Entity_Collection_Abstract &lt;- кодоляп =)\n */</span>\n</code></pre>\n<p>Есть метод <strong>removeFieldFromSelect</strong> при помощи которого можно удалить поле из запроса.</p>\n<p>Получить ресурс модель можно вызвав метод <strong>getResource</strong>. Получить все идентификаторы можно при помощи метода <strong>getAllIds</strong>. Также существует метод <strong>save</strong>, который в цикле вызывает сохранение для всех моделей находящихся в коллекции.</p>\n<p>Класс выбрасывает 4 события:</p>\n<ul>\n<li><em>core_collection_abstract_load_before</em>, <em>$_eventPrefix + '_load_before'</em></li>\n<li><em>core_collection_abstract_load_after, $_eventPrefix + '_load_after'</em></li>\n</ul>\n<h2 id=\"magento-path\"><a name=\"magento-path\" class=\"h-link\" href=\"#\"></a>Magento path</h2>\n<p>Несколько раз я уже упомянул о таком понятии как <em>Magento path</em>. На самом деле это что-то на подобии <em>xpath</em> к настройкам модуля в зависимости от метода, которому он передается. Помним что в настройках модуля есть такие директивы как: <em>blocks</em> и <em>models</em>. И обычно в параметре <em>class</em> прописано что-то вроде %module_name%_Block и %module_name%_Model соответственно. Таким образом мы указываем Magento префиксы для классов моделей и блоков.</p>\n<p><em>Magento path</em> состоит из 2 частей: названия модуля и пути к объекту. Рассмотрим пример</p>\n<pre><code class=\"hljs language-php\">$product = Mage::getModel(<span class=\"hljs-string\">'catalog/product'</span>); <span class=\"hljs-comment\"># create model</span>\n$block   = Mage::app()-&gt;getLayout()-&gt;createBlock(<span class=\"hljs-string\">'core/template'</span>); <span class=\"hljs-comment\"># create block</span>\n</code></pre>\n<p>И в настройках для моделей модуля <em>Mage_Catalog</em></p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">models</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">catalog</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">class</span>&gt;</span>Mage_Catalog_Model<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">class</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">resourceModel</span>&gt;</span>catalog_resource_eav_mysql4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">resourceModel</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">catalog</span>&gt;</span>\n............................................................\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">models</span>&gt;</span>\n</code></pre>\n<p><em>Magento</em> смотрит секцию моделей (<em>models</em>) и ищет там директиву <strong>catalog</strong>. Если нашла берет то, что внутри параметра <strong>class</strong>, как префикс имени класса. Все первые буквы слов после слэша, которые разделены символом нижнего подчеркивания, приводятся к верхнему регистру и конкатенируются с префиксом, т.е. в данном примере получается, что имя класса равно <em>Mage_Catalog_Model_Product</em>. Аналогично все происходит и с блоками.</p>\n<p><em>Magento path</em> был придуман для уменьшения имен классов и удобности написания. Имена классов являются такими длинными, потому что по сути указывают путь на файловой системе где они лежат (если заменить символ нижнего подчеркивания на слэш), а это в свою очередь удобно для реализации простого автолоадера классов.</p>\n<h2 id=\"skoupy-magento\"><a name=\"skoupy-magento\" class=\"h-link\" href=\"#\"></a>Скоупы Magento</h2>\n<p>В <em>Magento</em> существует 3 скоупа (3 разные директории) для кода: <em>app/code/community</em>, <em>app/code/core</em>, <em>app/code/local</em>. Первый предназначен для сторонних расширений скаченных и установленных при помощи <em>magento connect</em> менеджера. Второй - это ядро <em>Magento,</em> классы в этом скоупе не рекомендуется менять. И третий для своих локальных наработок и модификаций. Наличие этих скоупов дает возможность переопределять (при необходимости) классы ядра или расширения.</p>\n<p>Каждый из этих скоупов также имеет под область видимости. Наверно так сложно все было придумано во избежание конфликтов имен. Обычно эта под область имеет сокращенное имя компании, которая разработала данный код или псевдоним автора. В общем никакой особой смысловой нагрузки это имя не несет.</p>\n<p><strong>P.S.</strong>: в следующей статье рассмотрим возможность перезаписи классов и проблемы связанные с этим</p>","headings":[["biznes-modeli","Бизнес модели"],["resurs-modeli","Ресурс модели"],["psevdo-resurs-modeli","Псевдо-ресурс модели"],["magento-path","Magento path"],["skoupy-magento","Скоупы Magento"]],"id":"magento-modeli-ot-a-do-ya-modeli-yadra"}