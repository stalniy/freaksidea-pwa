{"title":"Введение в KnockOut - новый взгляд на построение JavaScript приложений","summary":"Являясь пользователем Хабра очень часто видел статьи и обзоры фреймворков\nKnockout и Backbone. Честно говоря, не смотря на все прелести о которых писали\nоб этих \"штуках\", интереса изучать их не было. Но когда у меня появилась\nзадача создания сложных пользовательских интерфейсов, первое что я подумал -\nэто использовать один из них.\n","author":"sstotskyi","categories":["frontend","important"],"createdAt":"2012-04-04T17:55:00.000Z","meta":{"keywords":["javascript","knockout","jQuery","MVVM"]},"alias":"vvedenie-v-knockout---novyj-vzglyad-na-postroenie-javascript-prilozhenij","content":"<p>Являясь пользователем <a href=\"http://habrahabr.ru\" title=\"Habr\" target=\"_blank\" rel=\"noopener nofollow\">Хабра</a> очень часто видел статьи и обзоры фреймворков <strong>Knockout</strong> и <strong>Backbone</strong>. Честно говоря, не смотря на все прелести о которых писали об этих &quot;штуках&quot;, интереса изучать их не было. Но когда у меня появилась задача создания сложных пользовательских интерфейсов, первое что я подумал - это использовать один из них. Так уж сложилось благодаря профессиональной лени, что я быстрее нагуглил <em><a href=\"http://knockoutjs.com\" title=\"Кнокаут\" target=\"_blank\" rel=\"noopener nofollow\">Knockout</a></em> нежели <em>Backbone</em>, зашел в <a href=\"http://learn.knockoutjs.com/\" target=\"_blank\" rel=\"noopener nofollow\">туториалы</a>, попробовал повторить и мне снесло башку. Большой интерес захватил мой мозг и я начал жадно поглощать всю документацию, которая доступна на официальном сайте.</p>\n<p>Перевода на русский язык я не нашел и подумал: почему бы не опубликовать ее у себя в блоге. Предполагается перевести всю документацию с офф. сайта в вольном стиле.</p>\n<h2 id=\"vvedenie-v-knockout\"><a name=\"vvedenie-v-knockout\" class=\"h-link\" href=\"#\"></a>Введение в Knockout</h2>\n<p><em>Knockout</em> - это <em>JavaScript</em> библиотека, которая позволяет создавать сложные пользовательские интерфейсы и при этом оставляет код &quot;чистым&quot;, расширяемым и хорошо читабельным. Основная задача, которую выполняет эта чудо-коробка - это автоматическое обновление пользовательского интерфейса при обновлении свойства в <em>JavaScript</em> модели.</p>\n<p>Основные преимущества:</p>\n<ul>\n<li><strong>отслеживание зависимостей</strong> - автоматически обновляет нужные части интерфейса, когда данные в модели изменяются;</li>\n<li><strong>декларативное связывание</strong> - простой и понятный способ привязки (байндинга) определенных частей интерфейса к модели. Можно создать сложные динамические интерфейсы используя только вложенные привязки;</li>\n<li><strong>расширяемость</strong> - можно создавать нестандартные байндинги написав всего нескольких строк кода.</li>\n<li><strong>совместимость</strong> - может работать с любыми клиентскими и серверными технологиями;</li>\n<li><strong>компактность</strong> - всего 13Кб после gzip сжатия;</li>\n<li><strong>кроссбраузерность</strong> - IE 6+, Firefox 2+, Chrome, Safari и другие;</li>\n<li><strong>независимость</strong> от других библиотек;</li>\n<li><strong>хорошая документация</strong>.</li>\n</ul>\n<p>В основе фреймворка лежит <em>MVVM</em> патерн разработанный в компании <em>Microsoft</em>. Последний, как и <em>MVC</em> используется для разделения логики и представления и также состоит из трех частей:</p>\n<ul>\n<li><em>Model</em> - как и в <em>MVC</em> представляет собой фундаментальные данные, необходимые для работы приложения;</li>\n<li><em>View</em> - отображение модели;</li>\n<li><em>View Model</em> - замена контроллеру, является посредником между первым и вторым. Включает в себе <em>Model</em> и команды, которые может использовать <em>View</em> не влияя непосредственно на саму модель.</li>\n</ul>\n<p><em>ViewModel</em> связывает модель и отображение при помощи событий. Если что-то поменялось в модели, то нужно изменить отображение и наоборот.</p>\n<h2 id=\"knockout-ne-zamena-j-query\"><a name=\"knockout-ne-zamena-j-query\" class=\"h-link\" href=\"#\"></a>Knockout не замена jQuery!</h2>\n<p>Наверное все знают и любят <em>jQuery</em>. Это очень удобная обертка для роботы с <em>DOM API</em>, которая решает множество кроссбраузерных проблем. <em>jQuery</em> используется для изменения страницы при помощи низкоуровневого <em>API</em>, тогда как <em>Knockout</em> решает другие задачи!</p>\n<p>Сложно использовать <em>jQuery</em>, когда создание пользовательского интерфейса становится нетривиальным: количество кода возрастает, он находится во все возможных частях вашего приложения, а фикс бага с каждой фичей занимает все больше времени. Например, нужно отобразить список сущностей, с указанием количества элементов в списке и кнопкой &quot;<em>Add Item</em>&quot;, которая включена только если в списке меньше чем 5 элементов. Допустим количество строк будет хранится в каком-то <em>span</em>-e, тогда при изменении количества нужно не забыть обновить его содержимое подсчитывая при этом количество <em>tr</em> тегов или каких-то элементов с определенным классом. Также нужно не забыть выключить кнопку после того как к-во элементов станет равным 5. Потом конечно же захочется создать кнопку &quot;<em>Delete</em>&quot;, при нажатии на которую, нужно также обновить весь пользовательский интерфейс.</p>\n<p><em>Knockout</em> решает подобные проблемы в несколько строк. Он позволяет расширять приложение и не боятся за последствия. Все что нужно сделать - это представить сущности как <em>JavaScript</em> массив и потом использовать <strong>foreach</strong> байндинг для того, чтобы представить его в виде таблицы или списка. Если он изменится отображение автоматически изменится, т.е. пользовательский интерфейс остается в актуальном состоянии без лишних телодвижений. Например, чтобы выводить к-во элементов в <em>span</em>-e, достаточно сделать на него <strong>bind</strong></p>\n<p><strong><code>There are &lt;span data-bind=&quot;text: myItems().count&quot;&gt;&lt;/span&gt; items</code></strong></p>\n<p>И все теперь можно вообще забыть о представлении и работать только с моделью. При каждом изменении модели <em>Knockout</em> сам обновит <em>DOM</em> элементы. Аналогично создать кнопку добавления нового элемента очень просто</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"click: addItem, enable: myItems().count &lt; 5\"</span>&gt;</span>Add<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></pre>\n<p>На кнопку прописано 2 байнда: <strong>click</strong> и <strong>enable</strong>. Первый - это функция обработчик на событие нажатия кнопки, а вторая - фильтр: как только к-во элементов станет равным 5, кнопка выключится автоматически.</p>\n<p>И позже при создании кнопки удаления не придется думать о том что, где и как нужно обновить, <em>Knockout</em> сделает это за нас.</p>\n<h2 id=\"v-zaklyuchenie\"><a name=\"v-zaklyuchenie\" class=\"h-link\" href=\"#\"></a>В заключение</h2>\n<p><em>Knockout</em> (KO) не конкурент <em>jQuery</em> или другой библиотеки, которая предоставляет <em>API</em> для низкоуровневого управления элементами страницы. KO предоставляет высокоуровневый путь самурая способ связывания модели данных с ее отображением. KO не зависит от <em>jQuery</em>, но это не значит что их нельзя использовать вместе, это даже нужно делать поскольку в последнем реализовано очень много функционала, который позволяет делать отображение элементов более приятным.</p>\n<p><strong>P.S.</strong>: кого заинтересовало быстро идем <a href=\"http://learn.knockoutjs.com/\" target=\"_blank\" rel=\"noopener nofollow\">на страничку туториалов</a>. После изучения KO <em>Gmail</em> уже не покажется таким уж сложным <em>AJAX</em> приложением.</p>\n<p><strong>По материалам</strong>: <a href=\"http://knockoutjs.com/documentation/introduction.html\" target=\"_blank\" rel=\"noopener nofollow\">Knockout</a></p>","headings":[["vvedenie-v-knockout","Введение в Knockout"],["knockout-ne-zamena-j-query","Knockout не замена jQuery!"],["v-zaklyuchenie","В заключение"]],"id":"vvedenie-v-knockout-novyj-vzglyad-na-postroenie-javascript-prilozhenij"}