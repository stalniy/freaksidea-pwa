{"title":"Что такое CASL или как внедрить проверку прав доступа в ваше приложение?","summary":"В наше время почти каждое приложение предусматривает различный функционал для разных групп пользователей (например таких как admin, member, subscriber и т.д. ). Эти группы обычно называются \"ролями\".\r\n\r\nПо своему опыту, могу сказать, что у большинства приложений логика построеа вокруг ролей (например, если у пользователя есть эта роль, тогда он может это сделать)  и в итоге имеем массивную систему с множеством сложных проверок, которую трудно поддерживать. Эту проблему можно решить при помощи CASL.","author":"sstotskyi","categories":["frontend","important"],"createdAt":"2017-08-14T09:00:00.000Z","meta":{"keywords":["права доступа","javascript","nodejs","acl","casl"]},"alias":"chto-takoe-casl-ili-kak-vnedrit-proverku-prav-dostupa-v-vashe-prilozhenie","content":"<p><a href=\"https://stalniy.github.io/casl/\" title=\"CASL\" target=\"_blank\" rel=\"noopener nofollow\">CASL</a> - это библиотека для авторизации в JavaScript, которая заставляет задумываться о том, что пользователь может делать в системе, а не какую роль он имеет (проверка звучит так: если пользователь имеет эту способность, то он может сделай это). Например, в приложении для блогов пользователь может создавать, редактировать, удалять, просматривать статьи и комментарии. Давайте разделим эти способности между двумя группами пользователей: анонимными пользователями (теми, кто не вошел в систему) и писателями (теми, кто вошел в систему).</p>\n<p><strong>Анонимные пользователи</strong> могут только читать посты и комментарии. <strong>Писатели</strong> могут делать тоже самое и не только, а именно управлять своими статьями и комментариями (“управлять” означает создавать, читать, обновлять и удалять их). При помощи <a href=\"https://github.com/stalniy/casl\" target=\"_blank\" rel=\"noopener nofollow\">CASL</a> это можно записать вот так:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { AbilityBuilder } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'casl'</span>\n\n<span class=\"hljs-keyword\">const</span> user = whateverLogicToGetUser()\n<span class=\"hljs-keyword\">const</span> ability = AbilityBuidler.define(<span class=\"hljs-function\"><span class=\"hljs-params\">can</span> =&gt;</span> {\n  can(<span class=\"hljs-string\">'read'</span>, [<span class=\"hljs-string\">'Post'</span>, <span class=\"hljs-string\">'Comment'</span>])\n\n  <span class=\"hljs-keyword\">if</span> (user.isLoggedIn) {\n    can(<span class=\"hljs-string\">'create'</span>, <span class=\"hljs-string\">'Post'</span>)\n    can(<span class=\"hljs-string\">'manage'</span>, [<span class=\"hljs-string\">'Post'</span>, <span class=\"hljs-string\">'Comment'</span>], { <span class=\"hljs-attr\">authorId</span>: user.id })\n  }\n})\n</code></pre>\n<p>Таким образом, можно определить, что пользователь может делать не только на основе ролей, но и на базе любых других критериев. Например, мы можем разрешить пользователям модерировать другие комментарии или статьи на основе их репутации, разрешить просмотр некоторого контента только для людей, которые подтвердили, что им исполнилось 18 лет и т.д. С <a href=\"https://stalniy.github.io/casl/\" target=\"_blank\" rel=\"noopener nofollow\">CASL</a> можно определить всю эту логику доступа в одном месте!</p>\n<p>Кроме того, с помощью библиотеки можно использовать базовые операторы запросов MongoDB для определения прав доступа. Подробнее об этом смотрите <a href=\"https://stalniy.github.io/casl/abilities/2017/07/20/define-abilities.html\" target=\"_blank\" rel=\"noopener nofollow\">в документации</a>.</p>\n<h2 id=\"proveryaem-vozmozhnosti\"><a name=\"proveryaem-vozmozhnosti\" class=\"h-link\" href=\"#\"></a>Проверяем возможности</h2>\n<p>Экземпляр класса Ability имеет 3 метода, которые позволяют проверять права доступа пользователя:</p>\n<pre><code class=\"hljs language-javascript\">ability.can(<span class=\"hljs-string\">'update'</span>, <span class=\"hljs-string\">'Post'</span>)\nability.cannot(<span class=\"hljs-string\">'update'</span>, <span class=\"hljs-string\">'Post'</span>)\nability.throwUnlessCan(<span class=\"hljs-string\">'update'</span>, <span class=\"hljs-string\">'Post'</span>)\n</code></pre>\n<p>Первый метод возвращает false, второй возвращает true, а третий выбрасывает ForbiddenError для анонимных пользователей.</p>\n<p>В качестве второго аргумента эти методы могут принимать экземпляр класса. Они определяют тип объекта на основе constructor.name или любой другой логики, которую можно указать с помощью параметра subjectName конструктора Ability:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> post = <span class=\"hljs-keyword\">new</span> Post({ <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'What is CASL?'</span> })\n\nability.can(<span class=\"hljs-string\">'read'</span>, post)\n</code></pre>\n<p>В этом случае can ('read', post) возвращает true, потому что выше мы определили, что каждый пользователь может читать все статьи. Давайте проверим случай, когда пользователь пытается изменить чужую статью (я буду ссылаться на идентификатор другого автора как <strong>anotherId</strong>, а к  идентификатору текущего пользователя как <strong>myId</strong>):</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> post = <span class=\"hljs-keyword\">new</span> Post({ <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'What is CASL?'</span>, <span class=\"hljs-attr\">authorId</span>: <span class=\"hljs-string\">'anotherId'</span> })\n\nability.can(<span class=\"hljs-string\">'update'</span>, post)\n</code></pre>\n<p>В этом случае can ('update', post) возвращает false, поскольку он может изменять только свои собственные статьи. Очевидно, что для собственной статьи метод возвращает true:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> post = <span class=\"hljs-keyword\">new</span> Post({ <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'What is CASL?'</span>, <span class=\"hljs-attr\">authorId</span>: <span class=\"hljs-string\">'myId'</span> })\nability.can(<span class=\"hljs-string\">'update'</span>, post)\n</code></pre>\n<p>Более детально о <a href=\"https://stalniy.github.io/casl/abilities/2017/07/21/check-abilities.html\" target=\"_blank\" rel=\"noopener nofollow\">Проверке Прав</a> можно найти в официальной документации.</p>\n<h2 id=\"integracziya-s-bazoj-dannyh\"><a name=\"integracziya-s-bazoj-dannyh\" class=\"h-link\" href=\"#\"></a>Интеграция с базой данных</h2>\n<p>CASL предоставляет функции, которые позволяют преобразовывать правила допуска в запрос к базе данных. В настоящее время CASL поддерживает только MongoDB, но библиотеку можно интегрировать с другими базами данных. Чтобы конвертировать права доступа в запрос MongoDB, используйте функцию <strong>toMongoQuery</strong> и метод <strong>rulesFor</strong> экземпляра Ability.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> { toMongoQuery } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'casl'</span>\n</code></pre>\n<p>В этом случае query будет пустым объектом, потому что пользователь может читать все статьи. Давайте проверим, что будет на выходе для операции обновления:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> query = toMongoQuery(ability.rulesFor(<span class=\"hljs-string\">'update'</span>, <span class=\"hljs-string\">'Post'</span>))\n<span class=\"hljs-comment\">// { $or: [{ authorId: 'myId' }] }</span>\n</code></pre>\n<p>Теперь query содержит запрос, который должен возвращать статьи, созданные только мной. Все обычные правила проходят через логическое OR, поэтому вы видите $or оператор в результате запроса. Подробности об <a href=\"https://stalniy.github.io/casl/abilities/2017/07/20/define-abilities.html#combining-abilities\" target=\"_blank\" rel=\"noopener nofollow\">Объединении Правил</a> можно найти в документации.</p>\n<p>Также CASL предоставляет плагин для <a href=\"http://mongoosejs.com/\" target=\"_blank\" rel=\"noopener nofollow\">mongoose</a>, который добавляет accessibleBy метод к моделям. Этот метод под капотом вызывает функцию <strong>toMongoQuery</strong> и передает результат в метод <code>find</code> mongoose-a.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> { mongoosePlugin, AbilityBuilder } = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'casl'</span>)\n<span class=\"hljs-keyword\">const</span> mongoose = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'mongoose'</span>)\n\nmongoose.plugin(mongoosePlugin)\n\n<span class=\"hljs-keyword\">const</span> Post = mongoose.model(<span class=\"hljs-string\">'Post'</span>, mongoose.Schema({\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">author</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">content</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">createdAt</span>: <span class=\"hljs-built_in\">Date</span>\n}))\n\n<span class=\"hljs-comment\">// by default it asks for `read` rules and returns mongoose Query, so you can chain it</span>\nPost.accessibleBy(ability).where({ <span class=\"hljs-attr\">createdAt</span>: { <span class=\"hljs-attr\">$gt</span>: <span class=\"hljs-built_in\">Date</span>.now() - <span class=\"hljs-number\">24</span> * <span class=\"hljs-number\">3600</span> } })\n\n<span class=\"hljs-comment\">// also you can call it on existing query to enforce visibility.</span>\n<span class=\"hljs-comment\">// In this case it returns empty array because rules does not allow to read Posts of `someoneelse` author</span>\nPost.find({ <span class=\"hljs-attr\">author</span>: <span class=\"hljs-string\">'someoneelse'</span> }).accessibleBy(ability, <span class=\"hljs-string\">'update'</span>).exec()\n</code></pre>\n<p>По умолчанию <code>accessibleBy</code> создаст запрос на базе <code>read</code> прав доступа. Чтобы построить запрос для другого действия, просто передайте его вторым аргументом. Более детальная информация в разделе <a href=\"https://stalniy.github.io/casl/abilities/database/integration/2017/07/22/database-integration.html\" target=\"_blank\" rel=\"noopener nofollow\">Интеграция с базой данных</a>.</p>\n<h2 id=\"i-eshhe-odno\"><a name=\"i-eshhe-odno\" class=\"h-link\" href=\"#\"></a>И еще одно...</h2>\n<p>CASL написан на чистом ES6, поэтому его можно использовать в любой среде JavaScript. Это означает, что Вы можете использовать одну и ту же библиотеку авторизации как на API так и на UI стороне. Благодаря этому UI может запросить все права доступа пользователя с API, и отобразить или скрыть какой-то функционал приложения.</p>\n<p>Примеры интеграции с популярными фреймворками можно найти в правом меню официальной документации, <a href=\"https://stalniy.github.io/casl/\" target=\"_blank\" rel=\"noopener nofollow\">секция &quot;Examples and Integrations&quot;</a>.</p>","headings":[["proveryaem-vozmozhnosti","Проверяем возможности"],["integracziya-s-bazoj-dannyh","Интеграция с базой данных"],["i-eshhe-odno","И еще одно..."]],"id":"chto-takoe-casl-ili-kak-vnedrit-proverku-prav-dostupa-v-vashe-prilozhenie"}