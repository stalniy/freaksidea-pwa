{"title":"Создание custom байндингов в Knockout","summary":"Knockout позволяет расширять свой функционал, а это значит, что конечный\nпользователь не ограничен использованием только стандартных байндингов, таких\nкак click, value, text, etc. Даже не используя своих сверхспособностей\nпрограммиста, можно без особых усилий написать байндинг, который реализует\nстандартное grid поведение (сортировка, удаление, добавление, пейджинг).\n","author":"sstotskyi","categories":["frontend"],"createdAt":"2012-09-06T12:12:00.000Z","meta":{"keywords":["knockout","observables"]},"alias":"sozdanie-custom-bajndingov-v-knockout","content":"<p>Вы не поверите, но <em>Knockout</em> позволяет расширять свой функционал, а это значит, что конечный пользователь не ограничен использованием только стандартных байндингов, таких как <em>click</em>, <em>value</em>, <em>text</em>, etc. Даже не используя своих сверхспособностей программиста, можно без особых усилий написать байндинг, который реализует стандартное <strong>grid</strong> <a href=\"http://knockoutjs.com/examples/grid.html\" title=\"Knockout Grid\" target=\"_blank\" rel=\"noopener nofollow\">поведение</a> (сортировка, удаление, добавление, пейджинг).</p>\n<h2 id=\"registracziya-bajndinga\"><a name=\"registracziya-bajndinga\" class=\"h-link\" href=\"#\"></a>Регистрация байндинга</h2>\n<p>Как обычно это бывает, новый функционал нужно где-то зарегистрировать, чтобы потом можно было им пользоваться. КО не является исключением, поэтому чтобы создать новый байндинг, достаточно добавить новое свойство в объект <strong>ko.bindingHandlers</strong>:</p>\n<pre><code class=\"hljs language-javascript\">ko.bindingHandlers.yourBindingName = {\n    <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">element, valueAccessor, allBindingsAccessor, viewModel, bindingContext</span>) </span>{\n        <span class=\"hljs-comment\">// This will be called when the binding is first applied to an element</span>\n        <span class=\"hljs-comment\">// Set up any initial state, event handlers, etc. here</span>\n    },\n    <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">element, valueAccessor, allBindingsAccessor, viewModel, bindingContext</span>) </span>{\n        <span class=\"hljs-comment\">// This will be called once when the binding is first applied to an element,</span>\n        <span class=\"hljs-comment\">// and again whenever the associated observable changes value.</span>\n        <span class=\"hljs-comment\">// Update the DOM element based on the supplied values here.</span>\n    }\n};\n</code></pre>\n<p>И потом его можно использовать в <strong>data-bind</strong> атрибуте</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"yourBindingName: someValue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>Выглядит достаточно привлекательно ибо просто. Также стоит упомянуть, что не обязательно реализовывать оба метода, достаточно указать только один, если это то что подходит для конкретной задачи.</p>\n<h2 id=\"kopaem-glubzhe\"><a name=\"kopaem-glubzhe\" class=\"h-link\" href=\"#\"></a>Копаем глубже</h2>\n<p>Чтобы писать собственные байндинги достаточно понять когда вызываются методы <strong>init</strong> и <strong>update</strong>. Первый вызывается один раз для каждого <em>DOM</em> элемента на который он привязан. В основном в этом методе происходит инициализация <em>View</em> начальным значением или устанавливаются обработчики событий. Для примера напишем байндинг <em>slideVisible</em>, который показывает и скрывает элементы плавно, используя анимацию. В качестве параметра он принимает <em>true/false</em> значение, которое указывает скрывать или показывать элемент. Стоит учитывать, что нужно скрыть элемент, если начальное значение байндинга равно <em>false</em> и показать его если <em>true</em>. Это и нужно реализовать в <strong>init</strong> методе:</p>\n<pre><code class=\"hljs language-javascript\">ko.bindingHandlers.slideVisible = {\n    <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">element, valueAccessor</span>) </span>{\n        <span class=\"hljs-keyword\">var</span> value = ko.utils.unwrapObservable(valueAccessor()); <span class=\"hljs-comment\">// Get the current value of the current property we're bound to</span>\n        element.style.display = value ? <span class=\"hljs-string\">'block'</span> : <span class=\"hljs-string\">'none'</span>\n    }\n};\n</code></pre>\n<p>Первый параметр - это <em>DOM</em> элемент и <em>valueAccessor</em> - функция, которая возвращает <em>accessor ViewModel</em>-и.</p>\n<p>Если привязанное к байндингу свойство <em>ViewModel</em>-и является наблюдаемым, то при каждом его изменении будет вызываться метод <strong>update</strong>. Этот метод принимает немного больше параметров:</p>\n<ul>\n<li><em>element</em> - <em>DOM</em> элемент</li>\n<li><em>valueAccessor</em> - функция, которая возвращает <em>accessor ViewModel</em></li>\n<li><em>allBindingsAccessor</em> - объект через который можно получить доступ ко всем байндингам на том же DOM элементе</li>\n<li><em>currentContext</em> - текущий контекст выполнения байндинга (т.е., внутри <em>with: person</em>, <em>currentContext</em> = <em>person</em>)</li>\n<li><em>bindingContext</em> - объект, который содержит контекст байндинга. Имеет такие свойства, как <em>$parent</em>, <em>$root</em>, <em>$parents</em></li>\n</ul>\n<p>Приступим к реализации используя <em>jQuery</em> куда же без него ибо цель топика в другом:</p>\n<pre><code class=\"hljs language-javascript\">ko.bindingHandlers.slideVisible = {\n    <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">element, valueAccessor</span>) </span>{\n        <span class=\"hljs-comment\">// leave as it is</span>\n    },\n    <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">element, valueAccessor, allBindingsAccessor</span>) </span>{\n        <span class=\"hljs-comment\">// First get the latest data that we're bound to</span>\n        <span class=\"hljs-keyword\">var</span> value = valueAccessor(), allBindings = allBindingsAccessor();\n\n        <span class=\"hljs-comment\">// Next, whether or not the supplied model property is observable, get its current value</span>\n        <span class=\"hljs-keyword\">var</span> valueUnwrapped = ko.utils.unwrapObservable(value);\n\n        <span class=\"hljs-comment\">// Grab some more data from another binding property</span>\n        <span class=\"hljs-keyword\">var</span> duration = allBindings.slideDuration || <span class=\"hljs-number\">400</span>; <span class=\"hljs-comment\">// 400ms is default duration unless otherwise specified</span>\n\n        <span class=\"hljs-comment\">// Now manipulate the DOM element</span>\n        <span class=\"hljs-keyword\">if</span> (valueUnwrapped) {\n            $(element).slideDown(duration); <span class=\"hljs-comment\">// Make the element visible</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            $(element).slideUp(duration);   <span class=\"hljs-comment\">// Make the element invisible</span>\n        }\n    }\n};\n</code></pre>\n<p>Теперь можно использовать сколько влезет по назначению:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"slideVisible: giftWrap, slideDuration:600\"</span>&gt;</span>You have selected the option<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"checked: giftWrap\"</span> /&gt;</span> Gift wrap<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span>&gt;</span><span class=\"actionscript\">\n    <span class=\"hljs-keyword\">var</span> viewModel = {\n        giftWrap: ko.observable(<span class=\"hljs-literal\">true</span>)\n    };\n    ko.applyBindings(viewModel);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>Дополнительный байндинг <strong>slideDuration</strong> является просто настройкой для <strong>slideVisible</strong>, которая указывает длительность анимации (если внимательно посмотреть на код метода <em>update</em>, то можно увидеть строку allBindings.slideDuration || 400). Все же, это еще не все. КО позволяет применять байндинги не только на <em>DOM</em> элементы, но и на &quot;виртуальные&quot; (специальный формат <em>HTML</em> комментариев). Сама реализация байндинга не дает возможности применять его на виртуальных элементах ибо для поддержки этой фичи нужно немного изменить реализацию.</p>\n<h2 id=\"bajnding-na-virtualnyh-elementah\"><a name=\"bajnding-na-virtualnyh-elementah\" class=\"h-link\" href=\"#\"></a>Байндинг на виртуальных элементах</h2>\n<p>Допустим есть байндинг <em>randomOrder</em>, который все <em>DOM</em> элементы внутри себя перемешивает в произвольном порядке:</p>\n<pre><code class=\"hljs language-javascript\">ko.bindingHandlers.randomOrder = {\n    <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">elem, valueAccessor</span>) </span>{\n        <span class=\"hljs-comment\">// Pull out each of the child elements into an array</span>\n        <span class=\"hljs-keyword\">var</span> childElems = [];\n        <span class=\"hljs-keyword\">while</span>(elem.firstChild)\n            childElems.push(elem.removeChild(elem.firstChild));\n\n        <span class=\"hljs-comment\">// Put them back in a random order</span>\n        <span class=\"hljs-keyword\">while</span>(childElems.length) {\n            <span class=\"hljs-keyword\">var</span> randomIndex = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * childElems.length),\n                chosenChild = childElems.splice(randomIndex, <span class=\"hljs-number\">1</span>);\n            elem.appendChild(chosenChild[<span class=\"hljs-number\">0</span>]);\n        }\n    }\n};\n</code></pre>\n<p>Он отлично будет работать на простом элементе:</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-bind</span>=<span class=\"hljs-string\">\"randomOrder: true\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>First<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Second<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Third<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>Но если его применить к виртуальному, то получим ошибку (<em>The binding 'randomOrder' cannot be used with virtual elements</em>)</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&lt;!-- ko randomOrder: true --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>First<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Second<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>Third<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- /ko --&gt;</span>\n</code></pre>\n<p>Исправить это недоразумение не составляет труда, достаточно просто написать:</p>\n<pre><code class=\"hljs language-javascript\">ko.virtualElements.allowedBindings.randomOrder = <span class=\"hljs-literal\">true</span>;\n</code></pre>\n<p>Но все же ничего не работает. Причина конечно же очевидна, в метод <strong>init</strong> передается не обычный <em>DOM</em> элемент, а виртуальный (и броузер ничего не знает о наличии в нем дочерних элементов ибо это не является стандартным <em>DOM API</em>). Чтобы это исправить достаточно использовать КО API для работы с виртуальными DOM элементами. Т.е., вместо element.firstChild писать ko.virtualElements.firstChild(element), вместо element.nextSibling писать ko.virtualElements.nextSibling(element) и так далее по аналогии. Используя эти методы, байндинг будет поддерживать как обычные, так и виртуальные <em>DOM</em> элементы. Перепишем метод <strong>init</strong>, чтобы этот байндинг заработал</p>\n<pre><code class=\"hljs language-javascript\">ko.bindingHandlers.randomOrder = {\n    <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">elem, valueAccessor</span>) </span>{\n        <span class=\"hljs-comment\">// Build an array of child elements</span>\n        <span class=\"hljs-keyword\">var</span> child = ko.virtualElements.firstChild(elem),\n            childElems = [];\n        <span class=\"hljs-keyword\">while</span> (child) {\n            childElems.push(child);\n            child = ko.virtualElements.nextSibling(child);\n        }\n\n        <span class=\"hljs-comment\">// Remove them all, then put them back in a random order</span>\n        ko.virtualElements.emptyNode(elem);\n        <span class=\"hljs-keyword\">while</span>(childElems.length) {\n            <span class=\"hljs-keyword\">var</span> randomIndex = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * childElems.length),\n                chosenChild = childElems.splice(randomIndex, <span class=\"hljs-number\">1</span>);\n            ko.virtualElements.prepend(elem, chosenChild[<span class=\"hljs-number\">0</span>]);\n        }\n    }\n};\n</code></pre>\n<h2 id=\"virtual-element-api\"><a name=\"virtual-element-api\" class=\"h-link\" href=\"#\"></a>Virtual Element API</h2>\n<p>KO предоставляет несколько полезных функций для работы с элементами, применимы как к обычным, так и к виртуальным элементам:</p>\n<ul>\n<li>ko.virtualElements.allowedBindings - объект, ключи которого определяют какие байндинги можно использовать с виртуальными элементами</li>\n<li>ko.virtualElements.emptyNode(container) - удаляет все дочерние элементы из <em>container</em></li>\n<li>ko.virtualElements.firstChild(container) - возвращает первый элемент <em>container</em></li>\n<li>ko.virtualElements.insertAfter(container, nodeToInsert, insertAfterNode) - вставляет элемент <em>nodeToInsert</em> внутрь контейнера сразу за <em>insertAfterNode</em> (последний должен быть дочерним элементом <em>container</em>)</li>\n<li>ko.virtualElements.nextSibling(container) - возвращает следующий элемент после указанного</li>\n<li>ko.virtualElements.prepend(container, nodeToPrepend) - вставляет <em>nodeToPrepend</em> первым дочерним элементом внутрь контейнера</li>\n<li>ko.virtualElements.setDomNodeChildren(container, arrayOfNodes) - удаляет все дочерние элементы из контейнера и вставляет новые из <em>arrayOfNodes</em></li>\n</ul>\n<p><strong>По материалам</strong>: <a href=\"http://knockoutjs.com/documentation/custom-bindings.html\" title=\"Knockout Custom Bindings\" target=\"_blank\" rel=\"noopener nofollow\">Knockout</a></p>","headings":[["registracziya-bajndinga","Регистрация байндинга"],["kopaem-glubzhe","Копаем глубже"],["bajnding-na-virtualnyh-elementah","Байндинг на виртуальных элементах"],["virtual-element-api","Virtual Element API"]],"id":"sozdanie-custom-bajndingov-v-knockout"}