{"title":"Прогрессивный интернет магазин. Service Worker в Magento","summary":"Не так давно стало популярным создавать PWA - Progressive Web Applications.\nНаибольший плюс таких сайтов, в том, что они работают не хуже, чем обычные\nдесктопные программы. И в этой статье я покажу, как сделать с обычного Magento\nмагазина - быстрый, прогрессивный :)\n","author":"sstotskyi","categories":["frontend","important"],"createdAt":"2017-05-30T09:35:00.000Z","meta":{"keywords":["magento","javascript","оптимизация","pwa"]},"alias":"progressivnyj-internet-magazin-service-worker-v-magento","content":"<p><a href=\"https://developers.google.com/web/progressive-web-apps/\" target=\"_blank\" rel=\"noopener nofollow\">Progressive Web Applications</a> - это новый подход для создания Single Page Applications, с поддержкой offline режима. Такие сайты грузятся со скоростью обычных десктопных программ.</p>\n<p>Максимальной пользы от PWA получить у нас не получится, поскольку пришлось бы переписать множество кода. Но даже в таком случае, можно кэшировать статьи из блога, все картинки, JavaScript и CSS файлы. Есть правда одно ограничение, Service Worker, который является частью нового стандарта, работает только на localhost домене или же на доменах с SSL поддержкой (или другими словами сайтами с поддержкой HTTPS). Но для моих эксперементов это подходит.</p>\n<h2 id=\"chto-zhe-takoe-service-worker\"><a name=\"chto-zhe-takoe-service-worker\" class=\"h-link\" href=\"#\"></a>Что же такое Service Worker?</h2>\n<p>Service Worker на самом деле просто JavaScript файл, который браузер запускает отдельным процессом (т.е., веб страницы никак не могут взаимодействовать с этим скриптом на прямую). Основная идея этого скрипта - это позволить перехватить все запросы и дополнительно их обработать, в самом простом случае кэшировать. Это в конечном итоге позволят использовать закэшированные файлы, для просмотра сайта на offline устройстве или в случае если сайт упал.</p>\n<p>До Service Worker-а был стандарт, который называется <a href=\"https://www.html5rocks.com/en/tutorials/appcache/beginner/\" target=\"_blank\" rel=\"noopener nofollow\">AppCache</a>. Хотя он и позволял кэшировать файлы для использования в offline режиме, но также имел и ряд серьезных ограничений. Поэтому и был полностью заменен на Service Worker.</p>\n<p>Стоит упомянуть несколько важных вещей:</p>\n<ul>\n<li>Service Worker не имеет доступа к DOM напрямую. Но страницы связанные с Service Worker скриптом, могут обмениваться сообщениями с ним при помощи метода postMessage, получать какой-то результат и в соответствии с этим обновлять DOM.</li>\n<li>Service Worker - это программируемый сетевой прокси, который позволяет перехватывать любые запросы с сайта и обрабатывать их как угодно</li>\n<li>Он может быть остановлен, если не используется, и перезапущен позже, так что нельзя полагаться на глобальное состояние скрипта. Если есть информация, которую нужно сохранить между перезапусками, то Service Worker имеет доступ к <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\" target=\"_blank\" rel=\"noopener nofollow\">IndexedDB API</a></li>\n<li>Service Worker построен на Promise-ах, так что без знаний как правильно использовать последние, написать скрипт будет непросто</li>\n<li>Service Worker использует новый <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"noopener nofollow\">Fetch API</a> стандарт</li>\n</ul>\n<h2 id=\"kak-zaregistrirovat-service-worker\"><a name=\"kak-zaregistrirovat-service-worker\" class=\"h-link\" href=\"#\"></a>Как зарегистрировать Service Worker</h2>\n<p>Чтобы запустить скрипт, его нужно зарегистрировать с любой страницы сайта. Следующий код определяет поддерживает ли браузер Service Worker-a и если да, то указывает где находится скрипт:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">'serviceWorker'</span> <span class=\"hljs-keyword\">in</span> navigator) {\n  <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'load'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    navigator.serviceWorker.register(<span class=\"hljs-string\">'/serviceworker.js'</span>).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">registration</span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'ServiceWorker registration successful with scope: '</span>, registration.scope);\n    }, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">error</span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'ServiceWorker registration failed: '</span>, error);\n    });\n  });\n}\n</code></pre>\n<p>Функцию navigator.serviceWorker.register можно вызывать сколько угодно раз, браузер сам проверит был ли запущен этот скрипт ранее или нет. Также стоит обратить внимание, на то что worker находится в корне сайта, поэтому он будет обрабатывать все сетевые запросы. Если поместить скрипт например в папку media/, то он будет обрабатывать только те запросы, которые начинаются с /media.</p>\n<p>Проверить был ли запущен worker в браузере Chrome, можно перейдя по ссылке chrome://inspect/#service-workers , там же его можно и остановить.</p>\n<h2 id=\"czikl-zhizni-service-worker-a\"><a name=\"czikl-zhizni-service-worker-a\" class=\"h-link\" href=\"#\"></a>Цикл жизни Service Worker-a</h2>\n<p>Service Worker оживет в момент, когда пользователь впервые зашел на сайт. Фаза оживания начинается с события install, в этом событии рекомендуют кэшировать любые статические ресурсы. Если в этот момент сайт будет недоступен или же по любым другим причинам worker не сможет закэшировать указанные URL, то он не запустится. Но Вы не переживайте, он попробует это сделать еще, но чуть позже (на сколько позже документация умалчивает). Например, это то что я укажу закэшировать для Magento:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateStaticCache</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> caches.open(version)\n        .then(<span class=\"hljs-function\"><span class=\"hljs-params\">cache</span> =&gt;</span> {\n            <span class=\"hljs-keyword\">return</span> cache.addAll([\n                offlinePageUrl,\n                <span class=\"hljs-string\">'/'</span>\n            ]);\n        });\n}\n\nself.addEventListener(<span class=\"hljs-string\">'install'</span>, event =&gt; {\n    event.waitUntil(\n        updateStaticCache()\n    );\n});\n</code></pre>\n<p>В случае же успеха, запускается фаза activate. В это время рекомендуют удалить старый кэш</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">clearOldCaches</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">return</span> caches.keys().then(<span class=\"hljs-function\"><span class=\"hljs-params\">keys</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.all(\n            keys\n                .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> key.indexOf(version) !== <span class=\"hljs-number\">0</span>)\n                .map(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> caches.delete(key))\n        );\n    });\n}\n\nself.addEventListener(<span class=\"hljs-string\">'activate'</span>, event =&gt; {\n    event.waitUntil(\n        clearOldCaches()\n            .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> self.clients.claim())\n    );\n});\n</code></pre>\n<p>Потом Service Worker переходит в режим ожидания сообщений fetch или message. fetch - вызывается на любой сетевой запрос, а message предназначен для любого общения между воркером и основной страницей. В данном случае меня больше интересует fetch, потому что именно в нем я и буду кэшировать все запросы.</p>\n<pre><code class=\"hljs language-javascript\">self.addEventListener(<span class=\"hljs-string\">'fetch'</span>, event =&gt; {\n    <span class=\"hljs-keyword\">const</span> request = event.request;\n\n    <span class=\"hljs-keyword\">if</span> (request.method !== <span class=\"hljs-string\">'GET'</span>) {\n        <span class=\"hljs-keyword\">return</span>;\n    }\n\n    <span class=\"hljs-keyword\">if</span> (isHtmlRequest(request)) {\n        event.respondWith(\n            fetchAndCache(request)\n                .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n                    <span class=\"hljs-keyword\">return</span> caches.match(request)\n                        .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n                            <span class=\"hljs-keyword\">if</span> (!response &amp;&amp; request.mode == <span class=\"hljs-string\">'navigate'</span>) {\n                                <span class=\"hljs-keyword\">return</span> caches.match(offlinePage);\n                            }\n                            <span class=\"hljs-keyword\">return</span> response;\n                        });\n                })\n        );\n    } <span class=\"hljs-keyword\">else</span> {\n        event.respondWith(\n            caches.match(request)\n                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> response || fetchAndCache(request))\n        );\n    }\n});\n</code></pre>\n<p>В данном примере я кэширую только GET запросы и также разделяю логику обработки HTML страниц и всех других запросов: если приходит запрос на HTML страницу, то пробуем ее запросить из сервера и кэшировать, если я в offline, то взять из кэша, и для всего другого сначала попробовать взять с кэша, если там пусто, то запросить из сервера и закэшировать. Логика достаточно простая, но для полноты картины приведу код всех функций, которые используются в примере выше:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isHtmlRequest</span>(<span class=\"hljs-params\">request</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> request.headers.get(<span class=\"hljs-string\">'Accept'</span>).indexOf(<span class=\"hljs-string\">'text/html'</span>) !== <span class=\"hljs-number\">-1</span>;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isBlacklisted</span>(<span class=\"hljs-params\">url</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> urlBlacklist.some(<span class=\"hljs-function\"><span class=\"hljs-params\">bl</span> =&gt;</span> url.indexOf(bl) === <span class=\"hljs-number\">0</span>);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isCachableResponse</span>(<span class=\"hljs-params\">response</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> response &amp;&amp; response.ok;\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fetchAndCache</span>(<span class=\"hljs-params\">request</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> fetch(request)\n        .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> {\n            <span class=\"hljs-keyword\">if</span> (!isCachableResponse(response) || isBlacklisted(request.url)) {\n                <span class=\"hljs-keyword\">return</span> response;\n            }\n\n            <span class=\"hljs-keyword\">const</span> copy = response.clone();\n            <span class=\"hljs-keyword\">return</span> caches.open(version)\n                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">cache</span> =&gt;</span> cache.put(request, copy))\n                .then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> response);\n        })\n}\n</code></pre>\n<h2 id=\"kak-otladit-service-worker\"><a name=\"kak-otladit-service-worker\" class=\"h-link\" href=\"#\"></a>Как отладить Service Worker?</h2>\n<p>Отладить worker очень просто. Каждый раз когда браузер зайдя на страницу, браузер запросит скрипт worker и если в скрипте помялся хотя бы 1 байт, то он остановит старый и запустит новый.</p>\n<p>Для отладки скрипта можно использовать Chrome Developers Tools. На странице где он запущен, откройте devtools и фильтре по фрэймах появится новое значение &quot;serviceworker&quot;.</p>\n<p><img src=\"/media/assets/service-worker-devtool-min.png\" alt=\"Service Worker in Developer Tools\" width=\"720\" height=\"502\"></p>\n<p>Дальше просто пользуется панелью как обычно. Так же можно перейти по ссылке chrome://inspect/#service-workers и нажать на ссылку Inspect для соответствующего воркера.</p>\n<h2 id=\"integracziya-service-worker-v-magento\"><a name=\"integracziya-service-worker-v-magento\" class=\"h-link\" href=\"#\"></a>Интеграция Service Worker в Magento</h2>\n<p>В Magento уже есть <a href=\"https://github.com/meanbee/magento-meanbee-pwa\" target=\"_blank\" rel=\"noopener nofollow\">готовый модуль</a>, который все сделает за нас. Так что скачиваем, копируем в папку с Magento и обновляем кэш.</p>\n<p>Этот модуль позволяет:</p>\n<ul>\n<li>настраивать Service Worker через админку</li>\n<li>кэшировать рисунки, файлы CSS, JavaScript и шрифтов</li>\n<li>кэширование каталога, CMS страниц и блога</li>\n<li>отобразить страницу с объяснением, если пользователь перешел по URL, который не был кэширован</li>\n</ul>\n<p>Все это увеличивает скорость последующей загрузки сайта, а так же позволяет просматривать уже посещенные страницы без подключения к интернету, при условиях плохого покрытия сети и даже когда Ваш сервер упал или находится на обслуживании. Так же это снимет нагрузку с Вашего сервера, что тоже может быть очень важным при большом количестве трафика.</p>\n<p>Основные настройки можно найти в Система &gt; Конфигурация &gt; Общие &gt; Интернет &gt; Progressive Web App Settings. В настройки игнорирования, я также добавляю URL на разную аналитику</p>\n<p><img src=\"/media/assets/magento-pwa-min.png\" alt=\"Magento PWA settings\" width=\"832\" height=\"496\"></p>\n<p>К сожалению, работать с модулем не очень удобно с выключенным кэшом для блоков (автор модуля решил использовать PHP функцию time() для создания версии кэша). Поэтому я изменил одну строчку кода внутри метода getVersion()</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-meta\">&lt;?php</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Meanbee_PWA_Block_Serviceworker_Js</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Mage_Core_Block_Template</span>\n</span>{\n    <span class=\"hljs-keyword\">const</span> VERSION = <span class=\"hljs-string\">\"v1\"</span>;\n\n    <span class=\"hljs-comment\">/**\n     * Get the service worker version string.\n     *\n     * <span class=\"hljs-doctag\">@return</span> string\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getVersion</span><span class=\"hljs-params\">()</span>\n    </span>{\n        <span class=\"hljs-keyword\">return</span> implode(<span class=\"hljs-string\">\"-\"</span>, <span class=\"hljs-keyword\">array</span>(\n            <span class=\"hljs-keyword\">static</span>::VERSION,\n            md5_file(<span class=\"hljs-keyword\">$this</span>-&gt;_viewDir . DS . <span class=\"hljs-keyword\">$this</span>-&gt;getTemplateFile()), <span class=\"hljs-comment\">// changed</span>\n        ));\n    }\n\n    <span class=\"hljs-comment\">//.....</span>\n}\n</code></pre>\n<p>Вместо вызова функции time() я использую md5_file(), которая возвращает md5 hash для файла, и пока файл не изменится, то не изменится и его md5 hash, и соответственно будет использоваться одна версия кэша. Для ротации это не очень удобно, но позволяет работать с отключенным кэшом для блоков в Magento. Но как, я уже говорил в статье <app-link to=\"frontend\" params=\"{&quot;id&quot;:&quot;vklyuchaem-http-keshirovanie-v-nginx-i-apache2&quot;}\">о HTTP кэшировании</app-link> - нужно чтобы каждый ресурс имел уникальный URL, и если меняется ресурс/файл, то должен изменится и его URL, что позволит получить максимум от кэширования.</p>","headings":[["chto-zhe-takoe-service-worker","Что же такое Service Worker?"],["kak-zaregistrirovat-service-worker","Как зарегистрировать Service Worker"],["czikl-zhizni-service-worker-a","Цикл жизни Service Worker-a"],["kak-otladit-service-worker","Как отладить Service Worker?"],["integracziya-service-worker-v-magento","Интеграция Service Worker в Magento"]],"id":"progressivnyj-internet-magazin-service-worker-v-magento"}