{"title":"Что такое Zone.js?","summary":"Zone.js - это библиотека позволяющая отслеживать асинхронные операции. Angular\n2+ использует ее для того, чтобы запускать dirty checking после всех\nасинхронных операций: будь-то запрос на сервер, таймер или же событие мыши. Но\nмало кто понимает как это работает... Поэтому давайте разбираться вместе!\n","author":"sstotskyi","categories":["frontend","important"],"createdAt":"2017-07-03T08:06:00.000Z","meta":{"keywords":["angular","zone.js","change detection"]},"alias":"chto-takoe-zonejs","content":"<p>Zone - это контекст выполнения, который сохраняется между выполнением асинхронных задач и позволяет наблюдать и контролировать выполнение кода внутри зоны.</p>\n<p>Прочитав это в первый раз у меня был вопрос: зачем? И в последствии поиски привели меня к нескольким ответам:</p>\n<ul>\n<li>Zone удобная для отладки (зона может показать stack trace начиная с самого начала, т.е. можно увидеть даже код, который запустил асинхронную операцию!)</li>\n<li>Zone полезная для фреймворков (с ее помощью можно понимать, когда все асинхронные операции закончены и можно отображать пользовательский интерфейс)</li>\n<li>Zone полезна для отслеживания и автоматического удаления ресурсов, которые сохраняются между асинхронными операциями</li>\n<li>Zone-ы являются составными</li>\n</ul>\n<p>Все это я разберу более подробно, но сначала давайте разберемся с общими понятиями</p>\n<h2 id=\"vhodim-v-prostranstvo-zone\"><a name=\"vhodim-v-prostranstvo-zone\" class=\"h-link\" href=\"#\"></a>Входим в пространство Zone</h2>\n<p>Для того, чтобы использовать Zone, нужно подключить ее, преждевременно скачав или же <a href=\"https://cdn.rawgit.com/angular/zone.js/v0.8.11/dist/zone.js\" target=\"_blank\" rel=\"noopener nofollow\">использовав CDN</a>. Для своих тестов я буду использовать <a href=\"http://plnkr.co\" target=\"_blank\" rel=\"noopener nofollow\">plunker</a>.</p>\n<p>И так, после подключения zone.js, появляется новая глобальная функция конструктор Zone. Также, сразу создается корневая зона, в которой по умолчанию выполняются все асинхронные операции и она доступна как readonly свойство Zone.current (или же Zone.root). Каждая зона имеет свойство name, которое используется исключительно в целях отладки. Корневая зона имеет имя <root>.</p>\n<p>Зоны могут порождать новые зоны. Рассмотрим пример:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> rootZone = Zone.current\n<span class=\"hljs-keyword\">const</span> newZone = rootZone.fork({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'new'</span> })\n\n<span class=\"hljs-built_in\">console</span>.log(rootZone.name, newZone.parent.name) <span class=\"hljs-comment\">// &lt;root&gt; &lt;root&gt;</span>\n\nnewZone.run(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(Zone.current.name, Zone.current === newZone) <span class=\"hljs-comment\">// new true</span>\n})\n</code></pre>\n<p>Метод fork создает новую зону, она связана с родительской зоной при помощи свойства parent (зона не имеет доступа к дочерним зонам).</p>\n<p>Как видно из примера внутри newZone.run Zone.current ссылается на newZone. Соответственно из этого делаем вывод, что единственный способ изменить Zone.current - это вызвать метод run на одной из зон (Zone.current readonly, если Вы вдруг забыли).</p>\n<p>Теперь давайте попробуем запустить асинхронную операцию, внутри зоны:</p>\n<pre><code class=\"hljs language-javascript\">Zone.current.fork({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'new'</span> }).run(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(Zone.current.name) <span class=\"hljs-comment\">// new</span>\n  }, <span class=\"hljs-number\">100</span>)\n  \n  Zone.current.fork({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'anotherOne'</span> }).run(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      <span class=\"hljs-built_in\">console</span>.log(Zone.current.name) <span class=\"hljs-comment\">// anotherOne</span>\n    }, <span class=\"hljs-number\">50</span>)\n  })\n})\n</code></pre>\n<p>Долгое время один вопрос не давал мне покоя: как так, глобальное значение Zone.current разное для разных асинхронных операций? Ведь после вызова метода run, Zone.current перезаписывается новым значением. Но этот пример работает, как ожидается.</p>\n<p>А ответ на самом деле очень прост: оказывается, что все асинхронные операции запоминают зону, в которой они были вызваны и потом вызывают соответствующий callback в той же зоне. Выглядит это примерно так:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">setTimeout</span>(<span class=\"hljs-params\">callback, timeout</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> currentZone = Zone.current\n\n  <span class=\"hljs-keyword\">return</span> originalSetTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> currentZone.run(callback), timeout)\n}\n\nZone.current.fork({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'new'</span> }).run(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(Zone.current.name)\n  }, <span class=\"hljs-number\">100</span>)\n})\n</code></pre>\n<p>ОК, скажете Вы, но ведь мы не пишем никаких setTimeout функций, как тогда zone.js знает, что в браузере произошло событие, или пришел ответ от сервера? И здесь ответ очень прост: zone.js патчит <a href=\"https://github.com/angular/zone.js/blob/master/STANDARD-APIS.md#browser\" target=\"_blank\" rel=\"noopener nofollow\">почти все асинхронные функции и методы доступные в браузере</a>.</p>\n<p>В это время, любой себя уважающий программист назвал бы это все, большим костылем и он был бы прав :) Но команда Angular пошла дальше и предложила внедрить Zone.js как часть <a href=\"https://domenic.github.io/zones/\" target=\"_blank\" rel=\"noopener nofollow\">нового JavaScript стандарта</a>. Так что этот костыль со временем может стать вполне реальным инструментом, который нужно уметь использовать.</p>\n<p>Здесь важно понимать, что асинхронная функция запоминает зону в момент регистрации callback-а. Давайте рассмотрим пример с Promise:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> delay = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve</span>) =&gt;</span> {\n  setTimeout(resolve, <span class=\"hljs-number\">100</span>)\n})\n\ndelay.then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  <span class=\"hljs-built_in\">console</span>.log(Zone.current.name) <span class=\"hljs-comment\">// &lt;root&gt;</span>\n})\n\nZone.current.fork({ <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'test'</span> }).run(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  delay.then(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(Zone.current.name) <span class=\"hljs-comment\">// test</span>\n  })\n}) \n</code></pre>\n<p>Как видно из примера, один и тот же Promise имеет 2 callback-а, которые запускаются в тех зонах, в которых они были добавлены. Функция resolve/reject не влияет на то в какой зоне будут запущены callback-и!</p>\n<p>Разобрав эти детали, мы теперь можем вернутся и рассмотреть способы применения указанные в начале статьи.</p>\n<h2 id=\"dlinnyj-stack-trace\"><a name=\"dlinnyj-stack-trace\" class=\"h-link\" href=\"#\"></a>Длинный stack trace</h2>\n<p>Создатели zone.js утверждают, что при помощи зон можно получить исчерпывающий stack trace, который сохраняется даже между асинхронными операциями. Для того, чтобы это проверить давайте напишем маленький скрипт. Также нам понадобится подключить dist/long-stack-trace-zone.js файл, который предоставляет longStackTrace функциональность.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> counter = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'click-me'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, () =&gt; {\n    counter++\n    \n    <span class=\"hljs-keyword\">if</span> (counter &gt; <span class=\"hljs-number\">5</span>) {\n      setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'test'</span>)\n      }, <span class=\"hljs-number\">100</span>)\n    }\n  })\n}\n\nmain()\n</code></pre>\n<p>И в HTML добавим просто кнопку с id=&quot;click-me&quot;. Идея в том, что после 5 нажатий скрипт асинхронно выбросит ошибку. Давайте запустим этот код и попробуем нажать на кнопку 5 раз:</p>\n<p><img src=\"/media/assets/zonejs-smalltrace.png\" alt=\"Zonejs Short stack trace\" loading=\"lazy\" width=\"579\" style=\"max-height: 141px;\" srcset=\"/media/assets/zonejs-smalltrace-xs.png 375w,/media/assets/zonejs-smalltrace.png 1280w\" sizes=\"(max-width: 375px) 375px,1280px\"></p>\n<p>А теперь запустим тот же код, но с длинным stack trace:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">Error</span>.stackTraceLimit = <span class=\"hljs-literal\">Infinity</span>\nZone.current.fork(Zone.longStackTraceZoneSpec).run(main)\n</code></pre>\n<p>И получили:</p>\n<p><img src=\"/media/assets/zonejs-longtrace.png\" alt=\"Zonejs Long stack trace\" loading=\"lazy\" width=\"652\" style=\"max-height: 553px;\" srcset=\"/media/assets/zonejs-longtrace-xs.png 375w,/media/assets/zonejs-longtrace.png 1280w\" sizes=\"(max-width: 375px) 375px,1280px\"></p>\n<p>Как видите в последнем случае мы имеем куда больше информации, stack trace показывает, что была запущена зона, потом установлен event listener, в котором был установлен таймер и что ошибка произошла именно в таймере. Согласитесь, это очень удобно для отлаживания и понимания откуда пришла ошибка (если не брать во внимание ту часть, которая относится к стеку выполнения внутри zone.js).</p>\n<h2 id=\"otslezhivanie-asinhronnyh-zadach\"><a name=\"otslezhivanie-asinhronnyh-zadach\" class=\"h-link\" href=\"#\"></a>Отслеживание асинхронных задач</h2>\n<p>До сих пор мы рассматривали как создавать и разветвлять зоны, теперь давайте перейдем к более интересным возможностям - отслеживанию асинхронных задач. Но для начала немного теории.</p>\n<p>Во-первых, в zone.js есть понятие &quot;задача&quot;. Существует <a href=\"https://github.com/angular/zone.js/blob/master/doc/task.md\" target=\"_blank\" rel=\"noopener nofollow\">3 вида задач</a>:</p>\n<ol>\n<li><strong>MicroTask</strong>: задача, которая выполнится в первую очередь. Обычно это не отменяемая задача, которая выполняется только один раз (Promise.then).</li>\n<li><strong>MacroTask</strong>: эти задачи гарантированно будут выполняться хотя бы один раз и могут быть отменены (setTimeout, setInterval).</li>\n<li><strong>EventTask</strong>: задачи событий аналогичны макрозадачам, за исключением того, что они могут никогда не запустится (addEventListener и подобные)</li>\n</ol>\n<p>Во-вторых, объект, который передается в метод zone.fork называется zone spec. Zone spec может перехватить выполнение асинхронной операции или же всей зоны. Существует <a href=\"https://github.com/angular/zone.js/blob/master/dist/zone.js.d.ts#L288\" target=\"_blank\" rel=\"noopener nofollow\">несколько хуков</a>:</p>\n<ul>\n<li><strong>onInvoke</strong>: вызывается в момент вызова zone.run (можно отслеживать время выполнения каждой зоны)</li>\n<li><strong>onFork</strong>: вызывается в момент вызова zone.fork</li>\n<li><strong>onScheduleTask</strong>: вызывается при создании новой задачи любого типа (new Promise, XHR, setTimeout, т.д.)</li>\n<li><strong>onInvokeTask</strong>: вызывается во время выполнения задачи</li>\n<li><strong>cancelTask</strong>: вызывается если задача отменяется (cancelTimeout, xhr.abort, т.д.)</li>\n<li><strong>onHasTask</strong>: вызывается каждый раз когда меняется количество задач (задача создается или заканчивается)</li>\n<li><strong>onHandleError</strong>: вызывается когда в зоне выбрасывается исключение</li>\n</ul>\n<p>onHandlerError как раз и используется в longStackTraceZoneSpec, благодаря чему и создается составной, длинный stack trace.</p>\n<h2 id=\"predotvrashhenie-neskolkih-nazhatij-na-knopku\"><a name=\"predotvrashhenie-neskolkih-nazhatij-na-knopku\" class=\"h-link\" href=\"#\"></a>Предотвращение нескольких нажатий на кнопку</h2>\n<p>onHasTask хук, можно использовать для блокировки кнопки после того как был послан запрос на сервер. Для этого нужно создать OncePerTask zone spec.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OncePerTaskSpec</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">this</span>.hasTasks = <span class=\"hljs-literal\">false</span>\n  }\n  \n  onHasTask(delegate, currentZone, targetZone, hasTask) {\n    delegate.hasTask(targetZone, hasTask)\n    <span class=\"hljs-keyword\">this</span>.hasTasks = hasTask.macroTask || hasTask.microTask\n  }\n}\n</code></pre>\n<p>Теперь напишем функцию, которая возвращает wrapper функцию, что вызывает переданный event listener только один раз и только если в его зоне нет задач в ожидании.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callOncePerTask</span>(<span class=\"hljs-params\">listener</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> spec = <span class=\"hljs-keyword\">new</span> OncePerTaskSpec()\n  <span class=\"hljs-keyword\">const</span> zone = Zone.current.fork(spec)\n  \n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\">(<span class=\"hljs-params\">...args</span>) =&gt;</span> {\n    <span class=\"hljs-keyword\">return</span> zone.run(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">if</span> (!spec.hasTasks) {\n        <span class=\"hljs-keyword\">return</span> listener(...args)\n      }\n    })\n  }\n}\n</code></pre>\n<p>Теперь это можно использовать для блокировки вызова event listener-ов пока выполняются асинхронные операции, такие как запрос на сервер, таймеры и прочие.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> form = <span class=\"hljs-built_in\">document</span>.forms.user\n  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>\n  \n  form.addEventListener(<span class=\"hljs-string\">'submit'</span>, event =&gt; event.preventDefault(), <span class=\"hljs-literal\">false</span>)\n  form.addEventListener(<span class=\"hljs-string\">'submit'</span>, callOncePerTask(<span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> {\n    form.name.nextElementSibling.textContent = ++i\n    \n    <span class=\"hljs-keyword\">const</span> originalText = form.save.textContent\n    form.save.textContent = <span class=\"hljs-string\">'Loading...'</span>\n    \n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      localStorage.name = form.name.value\n      form.save.textContent = originalText\n    }, <span class=\"hljs-number\">1500</span>)\n  }), <span class=\"hljs-literal\">false</span>)\n  \n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'this does not block clicks on Save button'</span>), <span class=\"hljs-number\">10000</span>)\n}\n</code></pre>\n<p>Рабочий <a href=\"http://embed.plnkr.co/AvggGgXb4VwuGtfTn3My/\" target=\"_blank\" rel=\"noopener nofollow\">пример можно посмотреть на plnkr.co</a>. Аналогичным способом protractor проверяет закончена отрисовка страницы или нет (NgZone предоставляет информацию о задачах в ожидании на уровне всего приложения).</p>\n<h2 id=\"avtomaticheskogo-ochishhenie-podpisok\"><a name=\"avtomaticheskogo-ochishhenie-podpisok\" class=\"h-link\" href=\"#\"></a>Автоматического очищение подписок</h2>\n<p>Zone.js также может помочь с автоматическим удалением event-listener-ов. Например, можно создавать отдельную зону для каждого компонента, запускать его lifecycle методы внутри этой зоны и на этапе уничтожения вызвать функцию которая удалит все event listener-ы. И больше никогда не беспокоится об очищении глобального состояния (event listener-ов на body или html элемента).</p>\n<p>Мы рассмотрим более упрощенный пример: я создам 3 кнопки - Events On, Events Off и Click me. При нажатии на первую будут включатся 2 последние кнопки, при нажатии на вторую - выключаются 2 последние кнопки и при нажатии на последнюю будет отображаться счетчик нажатий.</p>\n<p>Для начала напишем TrackEventListenerSpec класс, который будет собирать все EventTask-и и предоставлять метод cleanup для очистки всех подписок.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TrackEventListenerSpec</span> </span>{\n  <span class=\"hljs-keyword\">constructor</span>() {\n    <span class=\"hljs-keyword\">this</span>.name = <span class=\"hljs-keyword\">this</span>.constructor.name\n    <span class=\"hljs-keyword\">this</span>.properties = {\n      <span class=\"hljs-attr\">eventTracker</span>: <span class=\"hljs-keyword\">this</span>\n    }\n    <span class=\"hljs-keyword\">this</span>.tasks = []\n  }\n  \n  onScheduleTask(delegate, currentZone, targetZone, task) {\n    <span class=\"hljs-keyword\">if</span> (task.type === <span class=\"hljs-string\">'eventTask'</span>) {\n      <span class=\"hljs-keyword\">this</span>.tasks.push(task)\n    }\n    \n    <span class=\"hljs-keyword\">return</span> delegate.scheduleTask(targetZone, task)\n  }\n  \n  cleanup() {\n    <span class=\"hljs-keyword\">this</span>.tasks.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">task</span> =&gt;</span> Zone.current.cancelTask(task))\n    <span class=\"hljs-keyword\">this</span>.tasks.length = <span class=\"hljs-number\">0</span>\n  }\n}\n</code></pre>\n<p>Создаем HTML:</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"events-on\"</span>&gt;</span>Events On<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"events-off\"</span>&gt;</span>Events Off<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    \n    \n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"margin-top: 20px\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"click-me\"</span>&gt;</span>Click me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  Counter: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n</code></pre>\n<p>И запускаем зону:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> btn = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'click-me'</span>)\n  <span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>\n  \n  btn.addEventListener(<span class=\"hljs-string\">'click'</span>, () =&gt; {\n    btn.nextElementSibling.textContent = ++i\n  }, <span class=\"hljs-literal\">false</span>)\n  \n  <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'events-off'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.previousElementSibling.disabled = <span class=\"hljs-literal\">false</span>\n    Zone.current.get(<span class=\"hljs-string\">'eventTracker'</span>).cleanup()\n  })\n}\n\n<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'events-on'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">this</span>.disabled = <span class=\"hljs-literal\">true</span>\n  Zone.current.fork(<span class=\"hljs-keyword\">new</span> TrackEventListenerSpec()).run(main)\n})\n</code></pre>\n<p>Event listener на кнопку Events On я добавляю за пределами зоны, которая следит за всеми подписками, потому что эта кнопка должна работать всегда. Если бы я добавил подписчика внутри зоны, то при нажатии на кнопку Events Off, кнопка Events On тоже перестала бы работать. Рабочий пример такого механизма можно найти <a href=\"http://embed.plnkr.co/hoTCEtPRNBVnrYW0BG43/\" target=\"_blank\" rel=\"noopener nofollow\">здесь</a>.</p>\n<h2 id=\"sostavnye-zone-y\"><a name=\"sostavnye-zone-y\" class=\"h-link\" href=\"#\"></a>Составные Zone-ы</h2>\n<p>Zone-ы являются составными, потому что дочерняя зона может переопределять часть поведения родительской. Например, родительская зона может обрабатывать все ошибки, а дочерние зоны каким-то образом обрабатывать задачи. Логика здесь работает приблизительно как и в наследовании, если зона не определяет собственного обработчика, то будет вызван обработчик по умолчанию или же тот, который определен в родительской зоне. Также во все хуки первым аргументом передается parentZoneDelegate, который по сути является аналогом super в ES6 классах.</p>\n<p>Давайте рассмотрим пример с обработкой ошибок, где все ошибки кроме UserError обрабатываются родительской зоной:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Error</span> </span>{\n}\n\nZone.current.fork({ \n  onHandleError(parent, currentZone, targetZone, error) {\n    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'all-messages'</span>).textContent += error.message + <span class=\"hljs-string\">'\\n'</span>\n  }\n}).run(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n  Zone.current.fork({ \n    onHandleError(parent, currentZone, targetZone, error) {\n      <span class=\"hljs-keyword\">if</span> (error <span class=\"hljs-keyword\">instanceof</span> UserError) {\n        <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'user-messages'</span>).textContent += error.message + <span class=\"hljs-string\">'\\n'</span>\n      } <span class=\"hljs-keyword\">else</span> {\n        parent.handleError(targetZone, error)\n      }\n    }\n  }).run(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'gen-error'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'general error '</span> + <span class=\"hljs-built_in\">Date</span>.now())\n    }, <span class=\"hljs-literal\">false</span>)\n    \n    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'user-error'</span>).addEventListener(<span class=\"hljs-string\">'click'</span>, () =&gt; {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> UserError(<span class=\"hljs-string\">'user error '</span> + <span class=\"hljs-built_in\">Date</span>.now())\n    }, <span class=\"hljs-literal\">false</span>)\n  })\n})\n</code></pre>\n<p>В конкретном примере, ошибки которые являются экземплярами класса UserError, отображаются в блоке &quot;user-messages&quot;, все другие ошибки обрабатываются родительской зоной. В конкретном случае, ошибки отображаются в блоке &quot;all-messages&quot;. Рабочий пример можно посмотреть <a href=\"http://embed.plnkr.co/ocPxH2qYxzg69aOOipXW/\" target=\"_blank\" rel=\"noopener nofollow\">здесь</a>.</p>\n<h2 id=\"zaklyuchenie\"><a name=\"zaklyuchenie\" class=\"h-link\" href=\"#\"></a>Заключение</h2>\n<p>В Интернете достаточно мало информации о Zone.js, надеюсь моя статья хоть немного пролила свет на темном пути изучения Angular 2+ :) Если остались вопросы - задавайте их в комментариях.</p>\n<p><strong>По материалам</strong>:</p>\n<ul>\n<li><a href=\"https://docs.google.com/document/d/1F5Ug0jcrm031vhSMJEOgp1l-Is-Vf0UCNDY-LsQtAIY/edit#\" target=\"_blank\" rel=\"noopener nofollow\">Zone Primer</a></li>\n<li><a href=\"https://github.com/angular/zone.js/blob/master/dist/zone.js.d.ts\" target=\"_blank\" rel=\"noopener nofollow\">Zone.js Typescript definition</a></li>\n</ul>","headings":[["vhodim-v-prostranstvo-zone","Входим в пространство Zone"],["dlinnyj-stack-trace","Длинный stack trace"],["otslezhivanie-asinhronnyh-zadach","Отслеживание асинхронных задач"],["predotvrashhenie-neskolkih-nazhatij-na-knopku","Предотвращение нескольких нажатий на кнопку"],["avtomaticheskogo-ochishhenie-podpisok","Автоматического очищение подписок"],["sostavnye-zone-y","Составные Zone-ы"],["zaklyuchenie","Заключение"]],"id":"chto-takoe-zonejs"}