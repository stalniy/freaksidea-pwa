{"title":"Учимся программировать в Shell: управляющие конструкции. Часть 2","summary":"Те кто работал командами Linux очень часто видели команды, которым можно\nпередавать флаги и аргументы. Такой функционал можно организовать при помощи\nуправляющих конструкций, таких как while и case. Давайте знакомится ближе\n","author":"sstotskyi","categories":["linux","important"],"createdAt":"2011-10-16T13:24:00.000Z","meta":{"keywords":["Bash"]},"alias":"uchimsya-programmirovat-v-shell-upravlyayuschie-konstruktsii-chast-2","content":"<p>Для тех кто в танке начало <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;linux/show-45-uchimsia-proghrammirovat-v-shell-upravliaiushchie-konstruktsii&quot;}\">здесь</app-link>. Итак, продолжаем рассматривать управляющие конструкции, осталось: case, for, while, until, break, continue.</p>\n<p>Мы уже знаем команду <strong>if</strong> и то, что с ее помощью можно делать ветвление логики в программе. Но если нужно проверить несколько вариантов, то можно получить очень не читаемый код, так называемое нагромождение if-ов</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">if</span> [ <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$type</span>\"</span> = <span class=\"hljs-string\">\"1\"</span> ]; <span class=\"hljs-keyword\">then</span>\n    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'$type = 1'</span>\n<span class=\"hljs-keyword\">else</span>\n    <span class=\"hljs-keyword\">if</span> [ <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$type</span>\"</span> = <span class=\"hljs-string\">\"2\"</span> ]; <span class=\"hljs-keyword\">then</span>\n        <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'$type = 2'</span>\n    <span class=\"hljs-keyword\">else</span>\n        <span class=\"hljs-keyword\">if</span> [ <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$type</span>\"</span> = <span class=\"hljs-string\">\"3\"</span> ]; <span class=\"hljs-keyword\">then</span>\n            <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'$type = 3'</span>\n        <span class=\"hljs-keyword\">else</span>\n            <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"WTF?\"</span>\n        <span class=\"hljs-keyword\">fi</span>\n    <span class=\"hljs-keyword\">fi</span>\n<span class=\"hljs-keyword\">fi</span>\n</code></pre>\n<p>Выглядит мягко говоря не очень. По-этому, как и в большинстве других языков, <strong>Bash</strong> имеет более изящную конструкцию множественного ветвления <strong>case</strong></p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$type</span>\"</span> <span class=\"hljs-keyword\">in</span>\n    1 ) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'type = 1'</span>\n        ;;\n    2 ) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'type = 2'</span>\n        ;;\n    3 ) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'type = 3'</span>\n        ;;\n    * ) <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">'WTF?'</span>\n<span class=\"hljs-keyword\">esac</span>\n</code></pre>\n<p>Синтаксис команды следующий</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">case</span> word <span class=\"hljs-keyword\">in</span>\n    patterns ) statements ;;\n<span class=\"hljs-keyword\">esac</span>\n</code></pre>\n<p>Команда выполняет действия из той ветки, в которой <em>word</em> подходит под <em>patterns</em> (шаблоны). Шаблон может быть просто строкой или более сложным вроде <strong>[A-Z] | [0-9]</strong>, <strong>[!abc]</strong>. Более детально о шаблонах можно почитать <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;linux/show-33-chto-nuzhno-znat-novichku-v-linux-manipuliatsiia-failami&quot;}\">здесь</app-link>. Нужно понимать, что проверка на совпадения начинается с первого шаблона и потом идет к следующему, по-этому <em>pattern</em> <strong>*</strong>, который совпадает со всем, нужно писать в последнем случае. Это что-то вроде <em>default</em> в <strong>case</strong> из других языков программирования вроде PHP.</p>\n<h2 id=\"arifmeticheskie-operaczii\"><a name=\"arifmeticheskie-operaczii\" class=\"h-link\" href=\"#\"></a>Арифметические операции</h2>\n<p>Прежде чем идти дальше нужно рассмотреть арифметические операции, т.е. работу с числами. Для работы с целыми числами <strong>Bash</strong> предоставляет конструкцию <strong>$((arifmetic_operation))</strong>, например</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\nnum=0\n<span class=\"hljs-built_in\">echo</span> $((num + 1));\n</code></pre>\n<p>Выведет 1 на экран. Чтобы убедится, что с дробными числами эта конструкция не работает запустим такой скрипт</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\nnum=5\n<span class=\"hljs-built_in\">echo</span> $((num / 2));\n</code></pre>\n<p>На экране увидим <strong>2</strong>, вместо <strong>2.5</strong>.</p>\n<p>Но не стоит волноваться. Для работы с числами в Linux есть полноценная команда, она даже предоставляет возможности для программирования. Называется она <strong>bc</strong> (An arbitrary precision calculator language). Благодаря тому, что команда умеет читать данные из стандартного ввода, на нее можно отправлять арифметические операции в виде простого текста. Перепишем предыдущий пример</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\nnum=5\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"scale = 5; <span class=\"hljs-variable\">$num</span> / 2\"</span> | bc;\n</code></pre>\n<p>где <strong>scale</strong> - это внутренняя переменная в <strong>bc</strong>, которая указывает количество знаков после запятой. Получаем желаемый результат</p>\n<pre><code class=\"hljs language-bash\">enej@linux:~/tmp$ /bin/bash test.sh\n2.50000\n</code></pre>\n<h2 id=\"czikly-i-povtoryayushhiesya-dejstviya\"><a name=\"czikly-i-povtoryayushhiesya-dejstviya\" class=\"h-link\" href=\"#\"></a>Циклы и повторяющиеся действия</h2>\n<p>Это последняя группа управляющих конструкций в <strong>Bash</strong>. Циклы позволяют выполнять одни и те же команды несколько раз до наступления определенного условия. Например, команда <strong>while</strong> выполняется до тех пор пока условие не станет истинным</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\nnumber=0\n<span class=\"hljs-keyword\">while</span> [ <span class=\"hljs-variable\">$number</span> -lt 10 ]; <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Number = <span class=\"hljs-variable\">$number</span>\"</span>\n    number=$((number + 1))\n<span class=\"hljs-keyword\">done</span>\n</code></pre>\n<p>Обратите внимание, что блок кода, который нужно повторить несколько раз нужно заключить между словами <strong>do</strong> и <strong>done</strong>. В большинстве случаев повторяющийся блок кода как-то влияет на условие в цикле, в нашем случае увеличивает значение <em>number</em> на единицу, иначе бы получился бесконечный цикл. Но бесконечные цикли - это тоже хорошо, большинство <a href=\"http://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BC%D0%BE%D0%BD_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0)\" target=\"_blank\" rel=\"noopener nofollow\">программ-демонов</a> работают постоянно благодаря бесконечным циклам. Условия цикла проверяется каждый раз перед тем как выполнить тело цикла.</p>\n<p>Следующий цикл <strong>until</strong> - работает по точно такому же принципу за исключением того, что что выполняется до того момента пока условие остается ложным, например</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\nnumber=0\nuntil [ <span class=\"hljs-variable\">$number</span> -ge 10 ]; <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Number = <span class=\"hljs-variable\">$number</span>\"</span>\n    number=$((number + 1))\n<span class=\"hljs-keyword\">done</span>\n</code></pre>\n<p>Более интересным является цикл <strong>for</strong></p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">for</span> variable <span class=\"hljs-keyword\">in</span> words; <span class=\"hljs-keyword\">do</span>\n    statements\n<span class=\"hljs-keyword\">done</span>\n</code></pre>\n<p>Выполняется до тех пор пока есть слова. Каждая часть из <strong>words</strong> присваивается переменной, например</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\n<span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> word1 word2 word3; <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$i</span>\n<span class=\"hljs-keyword\">done</span>\n</code></pre>\n<p>Получим</p>\n<pre><code class=\"hljs language-bash\">enej@linux:~/tmp$ /bin/bash test.sh\nword1\nword2\nword3\n</code></pre>\n<p>Благодаря тому, что этот цикл работает со словами, его можно использовать во многих случаях. Например, пройтись по все файлам из директории, заменить в каждом из них что-то и записать назад</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\n<span class=\"hljs-keyword\">for</span> file <span class=\"hljs-keyword\">in</span> $(ls); <span class=\"hljs-keyword\">do</span>\n    cat <span class=\"hljs-variable\">$file</span> | sed <span class=\"hljs-string\">'s/bla/pra/'</span> &gt; /tmp/$(basename <span class=\"hljs-variable\">$file</span>);\n    mv /tmp/$(basename <span class=\"hljs-variable\">$file</span>) <span class=\"hljs-variable\">$file</span>;\n<span class=\"hljs-keyword\">done</span>\n</code></pre>\n<p>Будьте осторожны! Если Вы заменяете какой-то текст в файле, то запись сначала нужно сделать во временный файл, иначе Ваш файл окажется пустым.</p>\n<h2 id=\"praktikuemsya\"><a name=\"praktikuemsya\" class=\"h-link\" href=\"#\"></a>Практикуемся</h2>\n<p>В качестве примера давайте рассмотрим написание скрипта, который умеет работать с переданными ему опциями и аргументами.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\napache_vhost_dir=<span class=\"hljs-string\">\"/var/www\"</span>;\nhostname=<span class=\"hljs-string\">'default'</span>;\ndocument_root=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$hostname</span>\"</span>;\nhost_sufix=<span class=\"hljs-string\">'.local'</span>;\nargs=();\ncount=0;\n\n<span class=\"hljs-keyword\">while</span> [ -n <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$1</span>\"</span> ];<span class=\"hljs-keyword\">do</span>\n   <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$1</span>\"</span> <span class=\"hljs-keyword\">in</span>\n      -h )\n         hostname=<span class=\"hljs-variable\">$2</span>;\n      ;;\n      -r )\n         document_root=<span class=\"hljs-variable\">$hostname</span>/<span class=\"hljs-variable\">$2</span>;\n      ;;\n      -s )\n         host_sufix=<span class=\"hljs-variable\">$2</span>;\n      ;;\n      *  )\n         args[<span class=\"hljs-variable\">$count</span>]=<span class=\"hljs-variable\">$1</span>;\n         args[$((count+1))]=<span class=\"hljs-variable\">$2</span>;\n         count=$((count+2));\n   <span class=\"hljs-keyword\">esac</span>;\n   <span class=\"hljs-built_in\">shift</span>; <span class=\"hljs-built_in\">shift</span>;\n<span class=\"hljs-keyword\">done</span>;\n\ndocument_root=<span class=\"hljs-string\">\"<span class=\"hljs-variable\">$apache_vhost_dir</span>/<span class=\"hljs-variable\">$document_root</span>\"</span>;\n\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Host name: <span class=\"hljs-variable\">$hostname</span>\"</span>;\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Document root: <span class=\"hljs-variable\">$document_root</span>\"</span>;\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Host sufix: <span class=\"hljs-variable\">$host_sufix</span>\"</span>;\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Arguments: <span class=\"hljs-variable\">${args[@]}</span>\"</span>;\n\n<span class=\"hljs-built_in\">exit</span> 0;\n</code></pre>\n<p>Это часть скрипта, который я написал для автоматизация создания проектов. Запустим его</p>\n<pre><code class=\"hljs language-bash\">enej@linux:~/tmp$ ./test.sh -h <span class=\"hljs-built_in\">test</span> -r www arg1 arg2 arg3\nHost name: <span class=\"hljs-built_in\">test</span>\nDocument root: /var/www/<span class=\"hljs-built_in\">test</span>/www\nHost sufix: .<span class=\"hljs-built_in\">local</span>\nArguments: arg1 arg2 arg3\n</code></pre>\n<p>Как видим наш скрипт поддерживает как опции так и аргументы. Проанализируем его работу.</p>\n<p>Сначала создаем переменные со значениями по умолчанию, это позволяет не указывать все опции. Дальше начинаем цикл до тех пор пока первый аргумент скрипта не равен пустой строке. Дальше проверяем его, если это одна из допустимых опций, то записываем ее значение в специальную переменную, если же нет - то считаем, что это аргумент и записываем его в массив. Потом вызываем два раза команду <strong>shift</strong>. Эта команда удаляет первый элемент из массива аргументов <strong>$@</strong>. Поскольку первый аргумент - это имя опции и хранить его нам не нужно, а второй, значение опции - мы записали в переменную, то удаляем два первых элемента из массива.</p>\n<p>По мотивам <a href=\"http://linuxcommand.org\" target=\"_blank\" rel=\"noopener nofollow\">http://linuxcommand.org</a></p>","headings":[["arifmeticheskie-operaczii","Арифметические операции"],["czikly-i-povtoryayushhiesya-dejstviya","Циклы и повторяющиеся действия"],["praktikuemsya","Практикуемся"]],"id":"uchimsya-programmirovat-v-shell-upravlyayuschie-konstruktsii-chast-2"}