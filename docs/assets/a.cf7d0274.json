{"title":"Чтение директорий и поиск файлов в PHP","summary":"Для чтения содержимого директории в PHP есть старые проверенные функции\nreaddir, opendir и closedir. Не все до сих пор знают, но в 5 версии появилось\nнечто более мощное - итераторы. С их помощью рутинная работа по поиску файлов\nнамного упростилась и стала в несколько раз быстрее.\n","author":"sstotskyi","categories":["backend","important"],"createdAt":"2011-10-20T09:20:00.000Z","meta":{"keywords":["файлы","symfony","поиск","iterrators"]},"alias":"chtenie-direktorij-i-poisk-fajlov-v-php","content":"<p>Для чтения содержимого директории в PHP есть старые проверенные функции <em>readdir</em>, <em>opendir</em> и <em>closedir</em>. Не все до сих пор знают, но в 5 версии появилось нечто более мощное - <a href=\"http://www.php.net/manual/en/spl.iterators.php\" target=\"_blank\" rel=\"noopener nofollow\">итераторы</a>. С их помощью рутинная работа по поиску файлов намного упростилась и стала в несколько раз быстрее. Рассмотрим пример, как с помощью итератора прочитать все содержимое каталога</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-comment\">// some flags to filter . and .. and follow symlinks</span>\n$flags = FilesystemIterator::SKIP_DOTS | FilesystemIterator::FOLLOW_SYMLINKS;\n \n<span class=\"hljs-comment\">// create a simple recursive directory iterator</span>\n$iterator = <span class=\"hljs-keyword\">new</span> RecursiveDirectoryIterator($dir, $flags);\n \n<span class=\"hljs-comment\">// make it a truly recursive iterator</span>\n$iterator = <span class=\"hljs-keyword\">new</span> RecursiveIteratorIterator($iterator, RecursiveIteratorIterator::SELF_FIRST, RecursiveIteratorIterator::CATCH_GET_CHILD);\n \n<span class=\"hljs-comment\">// iterate over it</span>\n<span class=\"hljs-keyword\">foreach</span> ($iterator <span class=\"hljs-keyword\">as</span> $file)\n{\n  <span class=\"hljs-comment\">// do something with $file (a SplFileInfo instance)</span>\n}\n</code></pre>\n<p>Как видим все просто, нужно только знать когда какой итератор использовать, его разрешенные флаги и как их можно совмещать. Рассмотрим основные флаги</p>\n<ul>\n<li>FilesystemIterator::SKIP_DOTS - указывает, что нужно пропустить текущую (<strong>.</strong>) и родительскую директории (<strong>..</strong>)</li>\n<li>FilesystemIterator::FOLOW_SYMLINKS - указывает, что нужно идти по символьным ссылкам и выводить их содержимое</li>\n<li>RecursiveIteratorIterator::SELF_FIRST - указывает на то, что нужно показать сначала родительские элементы, а потом дочерние</li>\n<li>RecursiveIteratorIterator::CATCH_GET_CHILD - если у итератора не будет прав на чтение какой-либо директории, он просто пропустит ее</li>\n<li>RecursiveIteratorIterator::LEAVES_ONLY - показывает только файлы</li>\n<li>RecursiveIteratorIterator::CHILD_FIRST - указывает на то, что нужно показать сначала дочерние элементы, а потом родительские</li>\n</ul>\n<p>К сожалению есть небольшая проблема - все слишком объекто-ориентировано. Для обычной фильтрации итераторов нужно создать специальный класс-фильтр. Но не смотря на это итераторы в PHP очень гибкие и мощные. Допустим нужно отфильтровать все html файлы</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OnlyHtmlFilesFilterIterator</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">FilterIterator</span> </span>{\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">accept</span><span class=\"hljs-params\">()</span> </span>{\n    $fileinfo = <span class=\"hljs-keyword\">$this</span>-&gt;getInnerIterator()-&gt;current();\n \n    <span class=\"hljs-keyword\">return</span> preg_match(<span class=\"hljs-string\">'/\\.html$/'</span>, $fileinfo);\n}\n</code></pre>\n<p>В этом специальном классе пишется метод <strong>accept</strong>, в котором содержится логика отсечения не нужных файлов и директорий. Применить фильтр очень просто</p>\n<pre><code class=\"hljs language-php\">$iterator = <span class=\"hljs-keyword\">new</span> OnlyHtmlFilesFilterIterator($recursiveIterator);\n</code></pre>\n<h2 id=\"iteratory-v-symfony\"><a name=\"iteratory-v-symfony\" class=\"h-link\" href=\"#\"></a>Итераторы в Symfony</h2>\n<p>В <em>Symfony</em> начиная из первых версий был компонент <strong>sfFinder</strong>, думаю он многим знакомый. Этот класс очень удобный для поиска файлов и каталогов по заданным критериям. По своей сути он похож на команду <strong>find</strong> в Linux. А основной плюс, что его можно использовать отдельно от <em>Symfony</em>. Например, что-то вроде этого</p>\n<pre><code class=\"hljs language-php\">sfFinder::type(<span class=\"hljs-string\">'file'</span>) \n  -&gt;name(<span class=\"hljs-string\">'*Table.class.php'</span>)\n  -&gt;ignore_version_control()\n</code></pre>\n<p>Интерфейс простой и понятный, возвращает массива файлов и директорий соответствуючих критерию поиска. Но он использует старый механизм <em>opendir</em>, <em>readdir</em>, <em>closedir</em>.</p>\n<p>Думаю именно по-этому он был переписан во второй версии <em>Symfony</em> - теперь он использует итераторы и работает быстрее. Поскольку Symfony 2.0 написан на PHP 5.3, то нужно помнить про неймспейсы. Например</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-keyword\">use</span> <span class=\"hljs-title\">Symfony</span>\\<span class=\"hljs-title\">Components</span>\\<span class=\"hljs-title\">Finder</span>\\<span class=\"hljs-title\">Finder</span>;\n \n$finder = <span class=\"hljs-keyword\">new</span> Finder();\n$iterator = $finder-&gt;files()-&gt;in(<span class=\"hljs-keyword\">__DIR__</span>);\n \n<span class=\"hljs-keyword\">foreach</span> ($iterator <span class=\"hljs-keyword\">as</span> $file) {\n  <span class=\"hljs-keyword\">print</span> $file-&gt;getRealpath().<span class=\"hljs-string\">\"\\n\"</span>;\n}\n</code></pre>\n<p>Пример выше выведет рекурсивно на экран все файлы из текущей директории. Почти все методы класса возвращают экземпляр объекта, исключением является метод <strong>in</strong>, который возвращает итератор для заданного каталога. Рассмотрим пример</p>\n<pre><code class=\"hljs language-php\">$iterator = $finder\n  -&gt;files()\n  -&gt;name(<span class=\"hljs-string\">'test.*'</span>)\n  -&gt;notName(<span class=\"hljs-string\">'*.rb'</span>)\n  -&gt;exclude(<span class=\"hljs-string\">'ruby'</span>)\n  -&gt;followLinks()\n  -&gt;size(<span class=\"hljs-string\">'&gt;= 1K'</span>)\n  -&gt;size(<span class=\"hljs-string\">'&lt;= 2K'</span>)\n  -&gt;ignoreVCS()\n  -&gt;in(<span class=\"hljs-keyword\">__DIR__</span>)\n;\n</code></pre>\n<p>Этот код исчет файлы, имя которых <strong>test</strong> с любым расширением, кроме файлов <em>ruby</em>, идет по символьным ссылкам, фильтрует по размеру и пропускает файлы систем контроля версий (svn например). Фильтровать можно также при помощи анонимной функции</p>\n<pre><code class=\"hljs language-php\">$filter = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(\\SplFileInfo $fileinfo)</span> </span>{\n  <span class=\"hljs-keyword\">return</span> strlen($fileinfo) &gt; <span class=\"hljs-number\">10</span>);\n};\n \n$finder\n  -&gt;files()\n  -&gt;name(<span class=\"hljs-string\">'*.php'</span>)\n  -&gt;filter($filter);\n</code></pre>\n<p>Как видим итераторы очень гибкое и мощное дополнение в PHP и доказательством этого есть класс <strong>Finder</strong> в <em>Symfony 2.0</em></p>","headings":[["iteratory-v-symfony","Итераторы в Symfony"]],"id":"chtenie-direktorij-i-poisk-fajlov-v-php"}