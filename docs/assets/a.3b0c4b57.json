{"title":"One by one или парсим HUGE XML","summary":"При написании импорта столкнулся с проблемой парсинга больших XML файлов. Если\nнужно импортировать 100к сущностей, то SimpleXML к сожалению не сможет помочь\nв этом деле, так как съест много памяти только для одного разбора...\n","author":"sstotskyi","categories":["backend","important"],"createdAt":"2011-08-19T12:27:00.000Z","meta":{"keywords":["XML","import"]},"alias":"one-by-one-ili-parsim-huge-xml","content":"<p>На очередном фрилансе при создании синхронизации между 1с и интернет магазином, столкнулся с проблемой чтения и разбора больших XML файлов (~ 500Мб). Нужно было импортировать несколько сотен тысяч продуктов, они кстати выгружались в xml виде. Как настоящий лентяй честный программист поискал готовые решения в гугле, к моему огорчению ничего подходящего не нашлось.</p>\n<p>Передо мной стояла дилема: наговнокодить использовать для решения проблемы <a href=\"http://php.net/manual/en/book.simplexml.php\" target=\"_blank\" rel=\"noopener nofollow\">SimpleXMLElement</a>, прочитав весь файл за раз (у клиента свой, достаточно мощный сервер) или же прислушаться к призыву совести и реализовать полноценный класс для чтения xml построчно. Упрощенный пример импортируемого файла выглядит так:</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-meta\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">products</span>&gt;</span>\n............................................................\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">product</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ImageFile</span>&gt;</span>MD00454.jpg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ImageFile</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Show</span>&gt;</span>1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Show</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Articul</span>&gt;</span>MD00454<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Articul</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Name</span>&gt;</span>Таблетки для сливного бачка<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Name</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">TradeName</span>&gt;</span>Мебель<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">TradeName</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">PriceUAH</span>&gt;</span>11.52<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">PriceUAH</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DiscountPrice</span>&gt;</span>8.64<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">DiscountPrice</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">product</span>&gt;</span>\n............................................................\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">products</span>&gt;</span>\n</code></pre>\n<h2 id=\"evrika\"><a name=\"evrika\" class=\"h-link\" href=\"#\"></a>Эврика</h2>\n<p>Решение пришло само собой. Нужно было читать не весь файл, а частями (как не странно) и разбирать в этих кусочках xml данные, т.е. одна строка - это один узел (+ вся информация в нем) product. На счастье в PHP уже был <a href=\"http://www.php.net/manual/en/ref.xml.php\" target=\"_blank\" rel=\"noopener nofollow\">инструментарий</a> для реализации моих планов по захвату мира. Осталось завернуть все это в подарочную коробку, чтобы потом использовать без лишних мыслей. Кому стало скучно скачать код можно <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;backend/2011-08/one-by-one-ili-parsim-huge-xml/xml.class.zip&quot;}\">здесь</app-link>.</p>\n<p>Что же умеем и где кроются подводные камни???</p>\n<ul>\n<li>\n<p>итерирование по xml с помощью цикла foreach (реализует SeekableIterator)</p>\n<pre><code class=\"hljs language-php\">$parser = <span class=\"hljs-keyword\">new</span> sjXmlParser(<span class=\"hljs-string\">'/path/to/test.xml'</span>);\n$parser-&gt;setRowTagName(<span class=\"hljs-string\">'product'</span>);\n\n<span class=\"hljs-keyword\">foreach</span> ($parser <span class=\"hljs-keyword\">as</span> $row) {\n    print_r($row);\n}\n</code></pre>\n</li>\n<li>\n<p>чтение строки по порядковому номеру</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-comment\">// read 255 row</span>\n$row_255 = $parser-&gt;seekTo(<span class=\"hljs-number\">255</span>)-&gt;current();\n\n<span class=\"hljs-comment\">// go to the first row</span>\n$firstRow = $parser-&gt;rewind()-&gt;current();\n\n<span class=\"hljs-comment\">// go to next row</span>\n$nextRow = $parser-&gt;next()-&gt;current();\n</code></pre>\n</li>\n<li>\n<p>mapping и игнорирование данных на которых нет мапинг</p>\n<pre><code class=\"hljs language-php\">$parser = <span class=\"hljs-keyword\">new</span> sjXmlParser(<span class=\"hljs-string\">'/path/to/test.xml'</span>);\n\n<span class=\"hljs-comment\">// if you want to ignore all data except mapped</span>\n$parser-&gt;setIgnoreNotMappingTags(<span class=\"hljs-keyword\">true</span>);\n\n$parser-&gt;setRowTagName(<span class=\"hljs-string\">'product'</span>)\n    -&gt;addTagMap(<span class=\"hljs-string\">'ImageFile'</span>, <span class=\"hljs-string\">'image'</span>)\n    -&gt;addTagMap(<span class=\"hljs-string\">'PriceUAH'</span>, <span class=\"hljs-string\">'price'</span>)\n    -&gt;addTagMap(<span class=\"hljs-string\">'Show'</span>, <span class=\"hljs-string\">'status'</span>);\n</code></pre>\n</li>\n<li>\n<p>экономия оперативной памяти</p>\n</li>\n</ul>\n<h2 id=\"izyuminka\"><a name=\"izyuminka\" class=\"h-link\" href=\"#\"></a>Изюминка</h2>\n<p>Все это работает благодаря функции xml_parse и ее сообщникам: xml_parser_create, xml_set_object, xml_set_element_handler, xml_set_character_data_handler. Для инициализации разбора в контексте класса нужно сделать как-то так</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-keyword\">$this</span>-&gt;_parser = xml_parser_create(<span class=\"hljs-keyword\">$this</span>-&gt;_charset);\nxml_set_object(<span class=\"hljs-keyword\">$this</span>-&gt;_parser, <span class=\"hljs-keyword\">$this</span>);\nxml_set_element_handler(<span class=\"hljs-keyword\">$this</span>-&gt;_parser, <span class=\"hljs-string\">'_parseOpenTag'</span>, <span class=\"hljs-string\">'_parseCloseTag'</span>);\nxml_set_character_data_handler(<span class=\"hljs-keyword\">$this</span>-&gt;_parser, <span class=\"hljs-string\">'_parseContent'</span>);\n</code></pre>\n<p>Поскольку было вызвано xml_set_object, колбек функции можно передавать просто строкой, будет считаться, что это методы нашего объекта.</p>\n<p>А вот ядро всего этого, оно позволяет экономить память и продолжать разбор ПРАВИЛЬНО, что очень важно для моей совести:</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-comment\">/**\n * Read row from xml file\n *\n * <span class=\"hljs-doctag\">@return</span> array current row\n */</span>\n<span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_readRow</span><span class=\"hljs-params\">()</span>\n</span>{\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">isset</span>(<span class=\"hljs-keyword\">$this</span>-&gt;_data[<span class=\"hljs-keyword\">$this</span>-&gt;_currentKey]) || <span class=\"hljs-keyword\">$this</span>-&gt;_isInRow &amp;&amp; <span class=\"hljs-keyword\">$this</span>-&gt;_currentKey == <span class=\"hljs-keyword\">$this</span>-&gt;_rowIndex) {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">empty</span>(<span class=\"hljs-keyword\">$this</span>-&gt;_data[<span class=\"hljs-keyword\">$this</span>-&gt;_currentKey])) {\n            <span class=\"hljs-keyword\">$this</span>-&gt;_data = <span class=\"hljs-keyword\">array</span>();\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">$this</span>-&gt;_data = <span class=\"hljs-keyword\">array</span>(\n                <span class=\"hljs-keyword\">$this</span>-&gt;_currentKey =&gt; <span class=\"hljs-keyword\">$this</span>-&gt;_data[<span class=\"hljs-keyword\">$this</span>-&gt;_currentKey]\n            );\n        }\n        <span class=\"hljs-keyword\">do</span> {\n            $isFinal= feof(<span class=\"hljs-keyword\">$this</span>-&gt;_fileHandler);\n            $data   = fread(<span class=\"hljs-keyword\">$this</span>-&gt;_fileHandler, <span class=\"hljs-keyword\">$this</span>-&gt;_bufferSize);\n            $result = xml_parse(<span class=\"hljs-keyword\">$this</span>-&gt;_parser, $data, $isFinal);\n            <span class=\"hljs-keyword\">if</span> (!$result) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Exception</span>(sprintf(<span class=\"hljs-string\">'XML error at line %d column %d'</span>,\n                    xml_get_current_line_number(<span class=\"hljs-keyword\">$this</span>-&gt;_parser),\n                    xml_get_current_column_number(<span class=\"hljs-keyword\">$this</span>-&gt;_parser)\n                ));\n            }\n        } <span class=\"hljs-keyword\">while</span> ((<span class=\"hljs-keyword\">empty</span>(<span class=\"hljs-keyword\">$this</span>-&gt;_data) || <span class=\"hljs-keyword\">$this</span>-&gt;_isInRow &amp;&amp; count(<span class=\"hljs-keyword\">$this</span>-&gt;_data) == <span class=\"hljs-number\">1</span>) &amp;&amp; !$isFinal);\n    }\n..........................................................\n}\n</code></pre>\n<p>дальше последует немного объяснений...</p>\n<p>Класс имеет флаг $_isInRow, который указывает, что при чтении файла мы находимся между открывающимся и закрывающимся тегами product (касательно примера, а вообще свойства класса $_rowTagName).</p>\n<p>Сначала идет проверка, была ли прочитана текущая строка или если она была прочитана не полностью, то читаем и разбираем файл до момента пока массив данных $_data пустой или пока не будем знать на 100%, что прочитали полностью данные об одном продукте.</p>\n<p>P.S.: о подводных камнях и проблемах в работе хотелось бы увидеть в комментариях</p>","headings":[["evrika","Эврика"],["izyuminka","Изюминка"]],"id":"one-by-one-ili-parsim-huge-xml"}