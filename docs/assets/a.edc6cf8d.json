{"title":"Введение Ruby::Rack","summary":"Как оказалось создание web приложения на Ruby без использования фреймворков,\nвроде Rails или Sinatra, не так уж просто. Для этого необходимо полностью\nреализовать поддержку протокола HTTP, т.е. написать парсер заголовков и тела\nзапроса, а также отдавать результат клиенту при помощи обычной функции print.\nНо все же, не все так плохо и есть дорожка выстеленная благими намерениями -\nэто Rack.\n","author":"sstotskyi","categories":["backend","important","backend"],"createdAt":"2017-04-29T20:31:00.000Z","meta":{"keywords":["Ruby","Rack"]},"alias":"vvedenie-rubyrack","content":"<p>Если вдруг кто не знает, у меня есть свой <em>Open-Source</em> проект - бесплатный <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;javascript/show-54-sjfilemanager-evoliutsiia-php-ajax-failovyi-menedzher&quot;}\">AJAX файловый менеджер</app-link>. Начав изучать <em>Ruby</em>, первое что пришло мне в голову - это написать для него <em>backend</em> адаптер (и для проекта хорошо и для меня практика). Конечно же, пришлось зарефакторить <em>JavaScript</em> код, но об этом в другой статье.</p>\n<p>Как оказалось создание <em>web</em> приложения на <em>Ruby</em> без использования фреймворков, вроде <a href=\"http://ru.wikipedia.org/wiki/Ruby_on_Rails\" target=\"_blank\" rel=\"noopener nofollow\"><em>Rails</em></a> или <a href=\"http://ru.wikipedia.org/wiki/Sinatra\" target=\"_blank\" rel=\"noopener nofollow\"><em>Sinatra</em></a>, не так уж просто. Для этого необходимо полностью реализовать поддержку протокола <em>HTTP</em>, т.е. написать парсер заголовков и тела запроса, а также отдавать результат клиенту при помощи обычной функции <em>print</em>. Но все же, не все так плохо и есть дорожка выстеленная благими намерениями - это <em><a href=\"http://en.wikipedia.org/wiki/Rack_(web_server_interface)\" target=\"_blank\" rel=\"noopener nofollow\">Rack</a></em>.</p>\n<h2 id=\"rack-ne-ne-slyshal\"><a name=\"rack-ne-ne-slyshal\" class=\"h-link\" href=\"#\"></a>Rack? Не, не слышал</h2>\n<p><em>Rack</em> - это интерфейс, который создан, чтобы обеспечить минимальное <em>API</em> для подключения веб-серверов поддерживающих <em>Ruby</em> (<em>WEBrick</em>, <em>Mongrel</em> и т.д.) и веб-фреймворками (<em>Rails</em>, <em>Sinatra</em> и др.). В нем реализован базовый функционал для работы с <em>HTTP</em> протоколом: утилиты для парсинга, классы <em>Response,</em> <em>Request</em>, <em>Session</em> и многое другое.</p>\n<p>Вернемся к абстрактным вещам. Если проанализировать взаимодействие сервера и клиента, то можно обнаружить 3 ключевых аспекта: статус запроса, заголовки и тело. Именно это и стало фундаментом <em>Rack Application</em>.</p>\n<p>Что же такое <strong>Rack Application</strong>? Это самый обычный <em>Ruby</em> объект, который отвечает на метод <strong>call</strong>. В этот метод передаются переменные среды (<em>environment variables</em>) и он должен возвратить массив состоящий из 3-х элементов: числового статуса, хеша заголовков и тела ответа. Последний должен отвечать на метод <em>each</em>, которому передается блок.</p>\n<p>Поскольку в <em>Ruby</em> нет интерфейсов и все держится на честном слове, то единственный способ, которым осуществляется проверка наличия метода - это <em>method_defined?</em> и <em>respond_to?</em>. Т.е., <em>Ruby</em> не может проверить сделали ли Вы что-то с переданным блоком или знает ли Ваш код об этом вообще, по-этому нужно быть предельно внимательным. Достаточно поясничать, давайте посмотрим на пример</p>\n<pre><code class=\"hljs language-ruby\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span></span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">call</span><span class=\"hljs-params\">(env)</span></span>\n    [<span class=\"hljs-number\">200</span>, {<span class=\"hljs-string\">'Content-Type'</span> =&gt; <span class=\"hljs-string\">'text/html'</span>}, [<span class=\"hljs-string\">\"This is Rack!\"</span>]]\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n\nrun Application.new\n</code></pre>\n<p>Сохраняем пример в файл <strong>config.ru</strong> (стандартное конфигурационное имя файла для <em>rackup</em>) и в командной строке запускаем сервер:</p>\n<pre><code class=\"hljs language-bash\">rackup config.ru\n</code></pre>\n<p>По логам можно определить на каком порту запустился сервер (в моем случае 9292). Открываем броузер <em>http://localhost:9292</em> и видим строку &quot;<strong>This is Rack!</strong>&quot;. Заголовок <em>Content-Type</em> является обязательным, если Ваше приложение не возвращает такого заголовка, то <em>Rack</em> выбросит эксепшен.</p>\n<p>Отойдя немного от темы, расскажу о существовании сервера <em>shotgun</em>, который работает точно также, как и <em>rackup</em>, но используется для <em>development</em> целей. При запуске сервера <em>Ruby</em> подгружает нужные файлы в память, которые там &quot;живут&quot; все время, т.е. <em>rackup</em> - что-то вроде <em>application server</em>. А это значит, что изменения в любом файле не вступят в силу до тех пор, пока не будет перезагружен сервер. И это становится проблемой во время активной разработки, по этому стоит использовать <em>shotgun</em>, он следит за файлами и автоматически их перегружает. Этот сервер доступен, как обычный <em>Ruby gem</em>, по этому установить его не составит труда.</p>\n<h2 id=\"poleznoe-v-rack-iznutri\"><a name=\"poleznoe-v-rack-iznutri\" class=\"h-link\" href=\"#\"></a>Полезное в Rack изнутри?</h2>\n<p>Как я уже упомянул раньше <em>Rack</em> содержит набор полезных утилит и 3 важнейших для любого <em>web</em> приложения класса: <em>Response</em>, <em>Request</em> и <em>Session</em>.</p>\n<p><strong>Rack::Response</strong> предоставляет интерфейс, который упрощает создание ответа клиенту. Позволяет устанавливать заголовки, куки и создавать тело ответа. Класс достаточно простой, его исходники можно найти на <a href=\"https://github.com/rack/rack/blob/master/lib/rack/response.rb\" target=\"_blank\" rel=\"noopener nofollow\">GitHub</a>-е (а чего там нельзя найти?). Несколько примеров:</p>\n<pre><code class=\"hljs language-ruby\"><span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">'rack'</span>\n<span class=\"hljs-keyword\">require</span> <span class=\"hljs-string\">'rack/response'</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span></span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">call</span><span class=\"hljs-params\">(env)</span></span>\n    response = Rack::Response.new\n\n    <span class=\"hljs-comment\"># Append text to response body</span>\n    response.write <span class=\"hljs-string\">\"This is Rack\"</span>\n    response.write <span class=\"hljs-string\">\"!!!\"</span>\n    <span class=\"hljs-comment\"># Set Content-Type</span>\n    response[<span class=\"hljs-string\">'Content-Type'</span>] = <span class=\"hljs-string\">\"text/html\"</span>\n    <span class=\"hljs-comment\"># Set cookie</span>\n    response.set_cookie(<span class=\"hljs-string\">\"my_cookie\"</span>, <span class=\"hljs-string\">\"Hello Rack\"</span>);\n    <span class=\"hljs-comment\"># [status, headers, body]</span>\n    response.finish\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n\nrun Application.new\n</code></pre>\n<p>Класс <strong>Rack::Request</strong> более интересен, он предоставляет интерфейс для доступа к переменным запроса и упрощает работу с загружаемыми файлами. В качестве единственного параметра для инициализации принимает хеш переменных среды. Умеет делать множество полезных вещей: проверять тип запроса (<em>Head, Delete, Options, Get, Post, Put</em>), парсить <em>QUERY_STRING</em> в хеш, читать куки, возвращать базовый <em>URL</em>, узнать <em>referer</em> или <em>user_agent</em>. Например</p>\n<pre><code class=\"hljs language-ruby\"><span class=\"hljs-comment\"># inside call method</span>\nrequest = Rack::Request.new(env)\n\n<span class=\"hljs-comment\"># hash of all GET &amp; POST parameters</span>\nrequest.params\n\n<span class=\"hljs-comment\"># return \"my_param\"</span>\nrequest[<span class=\"hljs-string\">\"my_param\"</span>]\n\n<span class=\"hljs-comment\"># set \"my_param\"</span>\nrequest[<span class=\"hljs-string\">\"my_param\"</span>] = <span class=\"hljs-string\">\"new value\"</span>\n\n<span class=\"hljs-comment\"># read cookie</span>\nrequest.cookies[<span class=\"hljs-string\">\"my_cookie\"</span>]\n\n<span class=\"hljs-comment\"># file upload</span>\n<span class=\"hljs-keyword\">if</span> request.post?\n  <span class=\"hljs-comment\"># file is hash that consists from all necessary information about uploaded file including TempFile object</span>\n  file = request[<span class=\"hljs-string\">\"my_file\"</span>]\n  <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">200</span>, {<span class=\"hljs-string\">\"Content-Type\"</span> =&gt; <span class=\"hljs-string\">\"text/html\"</span>}, [file[<span class=\"hljs-symbol\">:tempfile</span>].read]]\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p><strong>Rack::Session</strong> реализован, как функционально-независимая часть и предоставляет 3 адаптера для хранения: в куках, в мемкэш сервере и обычный <em>HashPool</em>. Первый не рекомендуется использовать на продакшен серверах в целях безопасности, но вполне годится для девелопмента. К сессии можно обратится через экземпляр класса <em>Rack::Request</em> при помощи метода <em>session</em>, который представляет собой простой хеш.</p>\n<p>Сессия является оберткой для приложения, если говорить более строгими терминами, то класс сессии является декоратором (паттерн декоратор) для _rack application-_а. Например</p>\n<pre><code class=\"hljs language-ruby\">myapp = MyRackApp.new\nsessioned = Rack::Session::Pool.new(myapp,\n  <span class=\"hljs-symbol\">:domain</span> =&gt; <span class=\"hljs-string\">'foo.com'</span>,\n  <span class=\"hljs-symbol\">:expire_after</span> =&gt; <span class=\"hljs-number\">2592000</span>\n)\n\nrun sessioned\n</code></pre>\n<p>Все конечно хорошо, но хотелось бы добавлять новый функционал с минимальным изменением кода и без нагромождений. Для этого в <em>Rack</em> существует понятие <em>middleware</em> (чем по сути и является сам фреймворк). Используя <em>middleware</em> (посредник/фильтр) можно изменить/подготовить запрос перед тем как он попадет в <em>Application</em>, аналогично и с ответом для клиента.</p>\n<h2 id=\"rack-middleware\"><a name=\"rack-middleware\" class=\"h-link\" href=\"#\"></a>Rack Middleware</h2>\n<p>Предыдущий пример можно переписать через <em>middleware</em> и метод <em>use rackup</em> сервера</p>\n<pre><code class=\"hljs language-ruby\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span></span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">call</span><span class=\"hljs-params\">(env)</span></span>\n    request = Rack::Request.new(env)\n\n    request.session[<span class=\"hljs-symbol\">:user_ip</span>] <span class=\"hljs-params\">||</span>= request.ip\n    [<span class=\"hljs-number\">200</span>, {<span class=\"hljs-string\">'Content-Type'</span> =&gt; <span class=\"hljs-string\">'text/html'</span>}, [request.session.inspect]]\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\nuse Rack::Session::Pool\nrun Application.new\n</code></pre>\n<p>Также можно эмулировать работу <em>shotgun</em> сервера при помощи стандартного <strong>Rack::Reloader</strong> <em>middleware</em>.</p>\n<pre><code class=\"hljs language-ruby\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span></span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">call</span><span class=\"hljs-params\">(env)</span></span>\n    request = Rack::Request.new(env)\n\n    request.session[<span class=\"hljs-symbol\">:user_ip</span>] <span class=\"hljs-params\">||</span>= request.ip\n    [<span class=\"hljs-number\">200</span>, {<span class=\"hljs-string\">'Content-Type'</span> =&gt; <span class=\"hljs-string\">'text/html'</span>}, [request.session.inspect]]\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\nuse Rack::Session::Pool\nuse Rack::Reloader\nrun Application.new\n</code></pre>\n<p>В отличии от метода <em>run</em>, методу <em>use</em> нужно передать класс, а не объект. Выглядит достаточно элегантно и гибко.</p>\n<h2 id=\"pishem-svoj-middleware\"><a name=\"pishem-svoj-middleware\" class=\"h-link\" href=\"#\"></a>Пишем свой middleware</h2>\n<p>Для примера можно написать простую авторизацию по <em>IP</em>. Если <em>IP</em> пользователя находится в массиве разрешимых, то он получает доступ к приложению, если нет, то отдаем 404 страничку.</p>\n<pre><code class=\"hljs language-ruby\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">IpAuth</span></span>\n  @@trusted_ips = <span class=\"hljs-string\">%w(127.0.0.1 ::1)</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">initialize</span><span class=\"hljs-params\">(app)</span></span>\n    @app = app\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">call</span><span class=\"hljs-params\">(env)</span></span>\n    request = Rack::Request.new(env);\n\n    <span class=\"hljs-keyword\">if</span> @@trusted_ips.<span class=\"hljs-keyword\">include</span>?(request.ip)\n      @app.call(env)\n    <span class=\"hljs-keyword\">else</span>\n      [<span class=\"hljs-number\">404</span>, {<span class=\"hljs-string\">'Content-Type'</span> =&gt; <span class=\"hljs-string\">\"text/html\"</span>}, [<span class=\"hljs-string\">'Not Found'</span>]]\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Application</span></span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">call</span><span class=\"hljs-params\">(env)</span></span>\n    request = Rack::Request.new(env)\n\n    request.session[<span class=\"hljs-symbol\">:user_ip</span>] <span class=\"hljs-params\">||</span>= request.ip\n    [<span class=\"hljs-number\">200</span>, {<span class=\"hljs-string\">'Content-Type'</span> =&gt; <span class=\"hljs-string\">'text/html'</span>}, [request.session.inspect]]\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n\nuse IpAuth\nuse Rack::Session::Pool\nuse Rack::Reloader\nrun Application.new\n</code></pre>\n<p>В метод <em>initialize</em> передается объект <em>application</em>, в соответствии с цепочкой <em>middleware</em> (т.е., вызовов методов <strong>use</strong>), в конкретном случае <em>IpAuth</em> получит экземпляр класса <em>Rack::Session::Pool</em>. В этом же методе мы просто сохраняем ссылку на приложение, чтобы потом можно было его вызвать в методе <strong>call</strong>. Вот так просто можно добавить авторизацию для своего приложения.</p>\n<p><strong>P.S.</strong>: <em>Rack</em> имеет <a href=\"http://rack.rubyforge.org/doc/\" target=\"_blank\" rel=\"noopener nofollow\">документацию</a>, но это не то, по чему можно было бы нормально изучать фреймворк, по этому чаще смотрю исходники на GitHub.</p>","headings":[["rack-ne-ne-slyshal","Rack? Не, не слышал"],["poleznoe-v-rack-iznutri","Полезное в Rack изнутри?"],["rack-middleware","Rack Middleware"],["pishem-svoj-middleware","Пишем свой middleware"]],"id":"vvedenie-rubyrack"}