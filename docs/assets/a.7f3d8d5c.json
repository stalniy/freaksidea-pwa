{"title":"Что нужно знать новичку в Linux: управление задачами","summary":"Как и любая другая многозадачная система, Linux одновременно выполняет\nнесколько процессов. Вообще, не буду вводить Вас в заблуждение, потому что\nобычный однопроцессорный компьютер может выполнять только одну задачу в данный\nмомент времени, по-этому Linux ставит процессы в очередь на выполнения.\n","author":"sstotskyi","categories":["linux","important"],"createdAt":"2011-10-08T11:36:00.000Z","meta":{"keywords":["linux","управление задачами"]},"alias":"chto-nuzhno-znat-novichku-v-linux-upravlenie-zadachami","content":"<p>Как и любая другая многозадачная система, Linux одновременно выполняет несколько процессов. Вообще, не буду вводить Вас в заблуждение, потому что обычный однопроцессорный компьютер может выполнять только одну задачу в данный момент времени, по-этому Linux ставит процессы в очередь на выполнения.</p>\n<p>Существует несколько основных команд для управлением процессами</p>\n<ul>\n<li><strong>ps</strong> - выводить список запущенных процессов</li>\n<li><strong>kill</strong> - отправляет сигнал на один или несколько процессов (в основном, чтобы &quot;убить&quot; их)</li>\n<li><strong>jobs</strong> - альтернативный путь для просмотра процессов запущенных Вами</li>\n<li><strong>bg</strong> - ставит выполнение процесса в фоновый режим</li>\n<li><strong>fg</strong> - выводит выполнение процесса из фонового режима</li>\n</ul>\n<p>Хотя может показаться, что эти знания достаточно абстрактны, но они могут найти свое практическое применение даже для среднего пользователя, который использует графический интерфейс. Возможно Вы еще не знаете, что большинство графических программ (если не все) можно запустить при помощи командной строки. Для примера попробуем запустить браузер, думаю у большинства linux-оидов стоит или Google Chrome или FireFox</p>\n<pre><code class=\"hljs language-bash\">enej@linux:/home/pub/www/vv$ google-chrome\nCreated new window <span class=\"hljs-keyword\">in</span> existing browser session.\n</code></pre>\n<p>Можно указать URL, который Вы хотите открыть</p>\n<pre><code class=\"hljs language-bash\">enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com\nCreated new window <span class=\"hljs-keyword\">in</span> existing browser session.\n</code></pre>\n<p>У меня уже запущен Хром через графический интерфейс, по-этому браузер сообщает, что создается новое окно в существующей сессии и отдает управление командной строке. Или, например, если нужно открыть графический файловый менеджер с правами рута (пример будет работать для графической оболочки Gnome с установленным Nautilus)</p>\n<pre><code class=\"hljs language-bash\">enej@linux:/home/pub/www/vv$ sudo nautilus /root/\n[sudo] password <span class=\"hljs-keyword\">for</span> enej:\n</code></pre>\n<p>Поскольку процесс был запущен не в фоновом режиме, то в этом окне терминала Вы больше не можете выполнять какие-либо действия (чтобы завершить процесс можно нажать CTRL + C).</p>\n<h2 id=\"fonovyj-rezhim\"><a name=\"fonovyj-rezhim\" class=\"h-link\" href=\"#\"></a>Фоновый режим</h2>\n<p>Для того, чтобы было проще жить, при запуске графических программ или процессов, которые могут долго работать, обычно их выполнение ставят в фоновый режим, например, давайте запустим браузер в фоновом режиме</p>\n<pre><code class=\"hljs language-bash\">enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com &amp;\n[2] 9248\n</code></pre>\n<p>Знак амперсанта (<strong>&amp;</strong>) в конце вызова команды значит, что выполнение процесса нужно поместить в фоновый режим. В таком случае, остается возможность работать с даным окном терминала.</p>\n<p>Но вдруг Вы забыли поставить ампресант в конце вызова, тогда существует другой способ. Нужно сначала остановить выполнение нажав CTRL + Z, тогда получаем управление командной строкой и можем вызвать команду <strong>bg</strong>, которая поставим последний запущенный процесс в фоновый режим. Сказанное на примере</p>\n<pre><code class=\"hljs language-bash\">enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com\n^Z\n[2]+  Stopped                 google-chrome http://freaksidea.com\nenej@linux:/home/pub/www/vv$ <span class=\"hljs-built_in\">bg</span>\n[2]+ google-chrome http://freaksidea.com &amp;\n</code></pre>\n<p>Команда <strong>fg</strong> выводит последний запущенный процесс из фонового режима.</p>\n<h2 id=\"spisok-zapushhennyh-proczessov\"><a name=\"spisok-zapushhennyh-proczessov\" class=\"h-link\" href=\"#\"></a>Список запущенных процессов</h2>\n<p>Поскольку теперь Вы умеете ставить команды в фоновый режим, было хорошо посмотреть их список. Для этого используется команда <strong>jobs</strong> или более мощная <strong>ps</strong></p>\n<pre><code class=\"hljs language-bash\">enej@linux:/home/pub/www/vv$ <span class=\"hljs-built_in\">jobs</span>\n[1]-  Running                 nm-applet &amp;  (wd: ~/bin)\n[2]+  Running                 google-chrome http://freaksidea.com &amp;\nenej@linux:/home/pub/www/vv$ ps\n  PID TTY          TIME CMD\n 2304 pts/0    00:00:02 bash\n11104 pts/0    00:00:01 chrome\n11108 pts/0    00:00:00 chrome\n11110 pts/0    00:00:00 chrome\n11132 pts/0    00:00:00 chrome\n12088 pts/0    00:00:00 ps\n21165 pts/0    00:00:27 nm-applet\n</code></pre>\n<h2 id=\"kak-ubit-proczess\"><a name=\"kak-ubit-proczess\" class=\"h-link\" href=\"#\"></a>Как &quot;убить&quot; процесс?</h2>\n<p>Если процесс перестает отвечать на действия (т.е. завис), его нужно принудительно &quot;убить&quot;. Думаю те кто использует FireFox сталкивались с этим. Для таких задач используется команда <strong>kill</strong>. Но для начала нужно каким-то образом определить процесс. Для этого можно использовать команду <strong>jobs</strong> или <strong>ps</strong>. С помощью первой можно узнать номер процесса, с помощью второй его идентификатор.</p>\n<pre><code class=\"hljs language-bash\">enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com &amp;\n[2] 14789\nenej@linux:/home/pub/www/vv$ <span class=\"hljs-built_in\">jobs</span>\n[1]-  Running                 nm-applet &amp;  (wd: ~/bin)\n[2]+  Running                 google-chrome http://freaksidea.com &amp;\nenej@linux:/home/pub/www/vv$ <span class=\"hljs-built_in\">kill</span> %2\nenej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com &amp;\n[2] 15181\nenej@linux:/home/pub/www/vv$ ps\n  PID TTY          TIME CMD\n 2304 pts/0    00:00:02 bash\n15181 pts/0    00:00:00 chrome\n15238 pts/0    00:00:00 ps\n21165 pts/0    00:00:27 nm-applet\nenej@linux:/home/pub/www/vv$ <span class=\"hljs-built_in\">kill</span> 15181\n</code></pre>\n<p>Команды <strong>fg</strong> и <strong>bg</strong> в качестве первого аргумента могут принимать номер запущеного процесса, для его последуещего ввода/вывода в/из фонового режима.</p>\n<h2 id=\"pobrobnee-o-kill\"><a name=\"pobrobnee-o-kill\" class=\"h-link\" href=\"#\"></a>Побробнее о kill</h2>\n<p>На самом деле команда <strong>kill</strong> используется для отправки разных сигналов процессам. Просто в большинстве случаев этот сигнал говорит команде, что она должна завершится. Если программы правильно написаны, то они прослушивают различные сигналы от операционной системы и отвечают на них. Например, текстовый редактор должен прослушивать любой сигнал, который уведомляет, что пользователей выходит из системы или что компьютер выключается. Когда он (текстовый редактор) &quot;услышал&quot; такой сигнал, он должен сохранить открытые документы перед тем как закончить свою работу. Команда <strong>kill</strong> умеет отсылать несколько типов сигналов, чтобы узнать какие, введите <strong>kill -l</strong>. Ниже приведен список самых часто используемых сигналов (число в скобках - номер сигнала)</p>\n<ul>\n<li><strong>SIGNUP(1)</strong> - изначально был предназначен для того, чтобы информировать программу о потере связи с управляющим терминалом (терминалы часто подключались к системе с помощью модемов, так что название сигнала происходит от hung up – повесить трубку). Сигнал SIGHUP посылается приложению так же и в том случае, если процесс-лидер сессии завершил свою работу. Многие <a href=\"http://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BC%D0%BE%D0%BD_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%29\" target=\"_blank\" rel=\"noopener nofollow\">программы-демоны</a>, у которых нет лидера сессии, так же обрабатывают этот сигнал. В ответ на получение SIGHUP демон обычно перезапускается (или просто повторно читает файл конфигурации). По умолчанию программа, получившая этот сигнал, завершается.</li>\n<li><strong>SIGINT(2)</strong> - обычно посылается процессу, если пользователь терминала дал команду прервать процесс (обычно эта команда - сочетание клавиш Ctrl + C)</li>\n<li><strong>SIGTERM(15)</strong> - вызывает &quot;вежливое&quot; завершение программы. Получив этот сигнал, программа может выполнить необходимые перед завершением операции (например, сохранить открытые документы). Получение SIGTERM свидетельствует не об ошибке в программе, а о желании ОС или пользователя завершить ее.</li>\n<li><strong>SIGKILL(9)</strong> - вызывает принудительное завершение работы программы. Программа не может ни обработать, ни игнорировать этот сигнал.</li>\n</ul>\n<p>По умолчанию команда <strong>kill</strong> отправляет <strong>SIGTERM</strong> сигнал, но также можно указать номер сигнала или его имя. Допустим, что у Вас завис Chrome (у меня иногда флэш плеер перестает адекватно работать)</p>\n<pre><code class=\"hljs language-bash\">enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com &amp;\n[2] 22066\nenej@linux:/home/pub/www/vv$ <span class=\"hljs-built_in\">jobs</span>\n[1]-  Running                 nm-applet &amp;  (wd: ~/bin)\n[2]+  Running                 google-chrome http://freaksidea.com &amp;\nenej@linux:/home/pub/www/vv$ <span class=\"hljs-built_in\">kill</span> -SIGTERM %2\nenej@linux:/home/pub/www/vv$ <span class=\"hljs-built_in\">kill</span> -SIGKILL %2\nenej@linux:/home/pub/www/vv$ <span class=\"hljs-built_in\">kill</span> -9 %2\n</code></pre>\n<p><strong>P.S.</strong>: думаю очень интересным для начинающих будет 2 команды: <strong>notify-send</strong> (отправляет сообщение через графическую оболочку, в Gnome появляется вверху справа) и <strong>espeak</strong> (синтезатор речи). Если какой-то из них у Вас нет, установить можно при помощи команды <strong>apt-get</strong></p>\n<pre><code class=\"hljs language-bash\">enej@linux:/home/pub/www/vv$ sudo apt-get install espeak notify-send\n</code></pre>\n<p>Почитать об интересном их совмещении можно <a href=\"http://habrahabr.ru/blogs/ubuntu/126849/\" target=\"_blank\" rel=\"noopener nofollow\">здесь</a></p>\n<p>По мотивам <a href=\"http://linuxcommand.org\" target=\"_blank\" rel=\"noopener nofollow\">http://linuxcommand.org</a></p>","headings":[["fonovyj-rezhim","Фоновый режим"],["spisok-zapushhennyh-proczessov","Список запущенных процессов"],["kak-ubit-proczess","Как &quot;убить&quot; процесс?"],["pobrobnee-o-kill","Побробнее о kill"]],"id":"chto-nuzhno-znat-novichku-v-linux-upravlenie-zadachami"}