{"title":"Symfony 1.4 - мирим I18n и Searchable Doctrine 1.2 шаблоны","summary":"Большинство программистов, кто работал с Symfony 1.4 и Doctrine 1.2, наверняка\nиспользовали 2 стандартных шаблона для моделей: Searchable и I18n. Но к\nсожалению (из официальных источников) существует баг в Doctrine, который не\nпозволяет использовать вместе эти шаблоны. Посмотрим почему и как это можно\nисправить\n","author":"sstotskyi","categories":["backend"],"createdAt":"2011-10-13T22:49:00.000Z","meta":{"keywords":["Doctrine","symfony","I18n","поиск"]},"alias":"symfony-14---mirim-i18n-i-searchable-doctrine-12-shablony","content":"<p>Большинство программистов, кто работал с Symfony 1.4 и Doctrine 1.2, наверняка использовали 2 стандартных шаблона для моделей: Searchable и I18n. Но к сожалению (из официальных источников) существует баг в Doctrine, который не позволяет использовать вместе эти шаблоны, т.е. нельзя применить первый ко второму используя <em>actAs</em> директиву в конфигурации <em>schema.yml</em>.</p>\n<p>Вот <a href=\"http://www.doctrine-project.org/jira/browse/DC-199\" target=\"_blank\" rel=\"noopener nofollow\">ссылка</a> на баг в Doctrine и в комментариях видим:</p>\n<pre><code class=\"hljs language-html\">this is a known issue with the behaviors and it is a bigger problem that can't be fixed. Some behaviors just won't work together. \n</code></pre>\n<p>Это означает, что разработчики не могут придумать нормального решения, чтобы исправить баг.</p>\n<h2 id=\"ideologiya\"><a name=\"ideologiya\" class=\"h-link\" href=\"#\"></a>Идеология</h2>\n<p>Как говорится на нет и суда нет. Нельзя ну и пусть, не будем спорить с авторами такого гибкого и мощного ORM. Вместо этого</p>\n<pre><code class=\"hljs language-javascript\">CmsContent:\n  actAs:\n    I18n:\n      fields:\n        - title\n        - description\n      <span class=\"hljs-attr\">actAs</span>:\n        Searchable:\n          fields: [title]\n</code></pre>\n<p>напишем</p>\n<pre><code class=\"hljs language-javascript\">CmsContent:\n  actAs:\n    I18n:\n      fields:\n        - title\n        - description\n    <span class=\"hljs-attr\">Searchable</span>:\n      fields: [title_ru, title_en]\n</code></pre>\n<p>т.е. применяем оба шаблона к модели <em>CmsContent</em>.</p>\n<h2 id=\"kopaemsya-v-kode\"><a name=\"kopaemsya-v-kode\" class=\"h-link\" href=\"#\"></a>Копаемся в коде</h2>\n<p>От источника проблемы мы ушли, теперь осталось реализовать поддержку для нашей идеи. Для этого придется погрепать <em>Doctrine_Template_Searchable</em></p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Doctrine_Template_Searchable</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Doctrine_Template</span>\n</span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">__construct</span><span class=\"hljs-params\">(array $options = array<span class=\"hljs-params\">()</span>)</span>\n    </span>{\n          <span class=\"hljs-keyword\">parent</span>::__construct($options);\n          <span class=\"hljs-keyword\">$this</span>-&gt;_plugin = <span class=\"hljs-keyword\">new</span> Doctrine_Search(<span class=\"hljs-keyword\">$this</span>-&gt;_options);\n    }\n\n    <span class=\"hljs-comment\">// another lines</span>\n}\n</code></pre>\n<p>Видим по коду, что шаблон <em>Searchable</em> использует в качестве плагина (т.е. того кто делает основную работу) объект класса <em>Doctrine_Search</em>. Теперь давайте посмотрим на листенер, который вызывается на <em>postUpdate</em> модели <em>CmsContent</em> для создания поискового индекса</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Doctrine_Search_Listener</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Doctrine_Record_Listener</span>\n</span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">postUpdate</span><span class=\"hljs-params\">(Doctrine_Event $event)</span>\n    </span>{\n        $record = $event-&gt;getInvoker();\n        <span class=\"hljs-keyword\">$this</span>-&gt;_search-&gt;updateIndex($record-&gt;toArray());\n    }\n   \n    <span class=\"hljs-comment\">// some another lines</span>\n}\n</code></pre>\n<p>Проанализировав код видим, что в метод <em>updateIndex</em> передается ассоциативный массив данных модели и эти знания очень важны.</p>\n<h2 id=\"reshenie\"><a name=\"reshenie\" class=\"h-link\" href=\"#\"></a>Решение</h2>\n<p>Осталась маленькая проблемка. Мы указали (в файле конфигурации <em>schema.yml</em>), что поиск нужно проводить основываясь на поле <em>title</em> модели <em>CmsContent</em>, но это поле хранится в таблице <em>Translation</em>... Для того чтобы это подкорректировать перепишем метод <em>toArray</em></p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CmsContent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseCmsContent</span> </span>{\n    <span class=\"hljs-comment\">/**\n     * Fix for combining Doctrine_Searchable &amp; Doctrine_I18n\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toArray</span><span class=\"hljs-params\">($deep = true, $prefixKey = false)</span> </span>{\n        $data = <span class=\"hljs-keyword\">parent</span>::toArray($deep, $prefixKey);\n\n        $table = <span class=\"hljs-keyword\">$this</span>-&gt;getTable();\n        <span class=\"hljs-keyword\">if</span> ($table-&gt;hasTemplate(<span class=\"hljs-string\">'Searchable'</span>) &amp;&amp; $table-&gt;hasTemplate(<span class=\"hljs-string\">'I18n'</span>)) {\n            $fields = $table-&gt;getTemplate(<span class=\"hljs-string\">'Searchable'</span>)-&gt;getOption(<span class=\"hljs-string\">'fields'</span>);\n            <span class=\"hljs-comment\">// get langs from somewhere</span>\n            $langs  = <span class=\"hljs-keyword\">array</span>(<span class=\"hljs-string\">'ru'</span>, <span class=\"hljs-string\">'en'</span>);\n            <span class=\"hljs-keyword\">foreach</span> ($langs <span class=\"hljs-keyword\">as</span> $lang) {\n                <span class=\"hljs-keyword\">foreach</span> ($fields <span class=\"hljs-keyword\">as</span> $field) {\n                    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">isset</span>($data[<span class=\"hljs-string\">'Translation'</span>][$lang][$field])) {\n                        $data[$field . <span class=\"hljs-string\">'_'</span> . $lang] = $data[<span class=\"hljs-string\">'Translation'</span>][$lang][$field];\n                    }\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> $data;\n    }\n\n    <span class=\"hljs-comment\">// another lines</span>\n}\n</code></pre>\n<p>Т.е. смотрим если наша таблица имеет и <em>Searchable</em>, и <em>I18n</em> шаблоны, то перепишем поля (которые отвечает за поисковый индекс) из таблицы переводов в массив <em>$data</em>. Теперь наш индекс создается и обновляется.</p>\n<p><strong>P.S.</strong>: знаю это костиль, но все же лучше чем ничего</p>","headings":[["ideologiya","Идеология"],["kopaemsya-v-kode","Копаемся в коде"],["reshenie","Решение"]],"id":"symfony-14-mirim-i18n-i-searchable-doctrine-12-shablony"}