{"title":"CASL. Pursuing Perfection I: Why?","author":"sstotskyi","categories":["backend","important"],"createdAt":"2020-10-20T08:02:00.000Z","meta":{"keywords":["casl","javascript","performance"]},"summary":"<p><img src=\"/media/assets/casl-need-for-sql.jpg\" alt=\"CASL need for SQL\" loading=\"lazy\" width=\"1854\" style=\"max-height: 945px;\" srcset=\"/media/assets/casl-need-for-sql-xs.jpg 375w,/media/assets/casl-need-for-sql-sm.jpg 768w,/media/assets/casl-need-for-sql-md.jpg 1024w,/media/assets/casl-need-for-sql.jpg 1280w\" sizes=\"(max-width: 375px) 375px,(max-width: 768px) 768px,(max-width: 1024px) 1024px,1280px\"></p>\n<p>This is the first part in the series of articles where I plan to share my experience building and optimizing CASL v5:</p>\n","content":"<p><img src=\"/media/assets/casl-need-for-sql.jpg\" alt=\"CASL need for SQL\" loading=\"lazy\" width=\"1854\" style=\"max-height: 945px;\" srcset=\"/media/assets/casl-need-for-sql-xs.jpg 375w,/media/assets/casl-need-for-sql-sm.jpg 768w,/media/assets/casl-need-for-sql-md.jpg 1024w,/media/assets/casl-need-for-sql.jpg 1280w\" sizes=\"(max-width: 375px) 375px,(max-width: 768px) 768px,(max-width: 1024px) 1024px,1280px\"></p>\n<p>This is the first part in the series of articles where I plan to share my experience building and optimizing CASL v5:</p>\n<summary-cut/>\n<ul>\n<li><strong>CASL. Pursuing Perfection I: Why?</strong></li>\n<li>CASL. Pursuing Perfection II: New Engine</li>\n<li>CASL. Pursuing Perfection III: Big O</li>\n<li>CASL. Pursuing Perfection IV: Type Safety</li>\n</ul>\n<p>First time you've heard about CASL? You may want to read &quot;<a href=\"https://casl.js.org/v4/en/guide/intro\" target=\"_blank\" rel=\"noopener nofollow\">What is CASL?</a>&quot;.</p>\n<h2 id=\"why\"><a name=\"why\" class=\"h-link\" href=\"#\"></a>Why?</h2>\n<p><a href=\"https://github.com/stalniy/casl/issues/8\" target=\"_blank\" rel=\"noopener nofollow\">The long standing issue</a> regarding SQL integration was created 2 months after the initial CASL's release and was not addressed for years. To understand why and why it was a challenge, we need to go back to the days when CASL was designed.</p>\n<h3 id=\"a-bit-of-history\"><a name=\"a-bit-of-history\" class=\"h-link\" href=\"#\"></a>A bit of history</h3>\n<p>CASL was heavily inspired by <a href=\"https://github.com/ryanb/cancan\" target=\"_blank\" rel=\"noopener nofollow\">cancan ruby gem</a>. This gem provides 3 ways to define conditions for rules:</p>\n<ul>\n<li>hash maps, <br>\ncan be used for runtime checks and can be transformed to SQL query</li>\n<li>ruby blocks, <br>\nsimilar to lambdas in other languages, only runtime checks</li>\n<li><code>ActiveRecord::Relation</code> and raw SQL queries</li>\n</ul>\n<blockquote>\n<p>Why CASL did not inherited the name of &quot;cancan&quot; is a different story but if you are curious, just read <a href=\"https://github.com/vadimdemedes/cancan/issues/28\" target=\"_blank\" rel=\"noopener nofollow\">here</a>.</p>\n</blockquote>\n<p>Values in hash maps are interpreted as &quot;equal&quot; operation, so <code>{ author_id: 1 }</code> is transformed to <code>post.author_id == 1</code> in runtime and to <code>author_id = 1</code> in SQL.</p>\n<p>At that time, I worked with MongoDB and our use-cases were a bit more complex. MongoDB itself allows to store and query a bit more complex data structures than SQL databases (before JSON data type). That's why I decided to use MongoDB query language to define conditions for permissions. But there was another issue: I needed a way to interpret MongoDB in JavaScript.</p>\n<p>And <strong>thanks to <a href=\"https://github.com/crcn/sift.js\" target=\"_blank\" rel=\"noopener nofollow\">sift.js</a></strong>, library that evaluates MongoDB conditions in runtime, the issue was pretty easy to solve :)</p>\n<p>Eventually, sift.js was used to interpret conditions in JavaScript and the same conditions, without additional processing were used to query the database.</p>\n<p>As I said, there was no additional preprocessing and it was the main reason why there was no official SQL support.</p>\n<h3 id=\"so-no-sql-at-all\"><a name=\"so-no-sql-at-all\" class=\"h-link\" href=\"#\"></a>So, no SQL at all?</h3>\n<p>Frankly speaking, <strong>there is a possibility to use CASL with SQL</strong> databases thanks to <a href=\"https://sequelize.org/\" target=\"_blank\" rel=\"noopener nofollow\">sequelize</a> which accepts &quot;where&quot; conditions that are pretty similar to MongoDB query language. This works pretty well even today but only for cases when all the data required to check conditions is in a single table.</p>\n<p>But as soon as you try to define permissions base on a related table, you are on your own because there is no custom operators support, no AST and no all that stuff which is required for transforming languages from one to another.</p>\n<h2 id=\"finally-solution\"><a name=\"finally-solution\" class=\"h-link\" href=\"#\"></a>Finally. Solution</h2>\n<p>To add better SQL support, I decided to go the same road and ask Craig to implement it :) The details of our conversion can be found in <a href=\"https://github.com/crcn/sift.js/pull/204\" target=\"_blank\" rel=\"noopener nofollow\">this PR</a>.</p>\n<blockquote>\n<p>Craig is the author of sift.js library and I'd like to say a &quot;Big Thank You&quot; for his awesome work!</p>\n</blockquote>\n<p>Unfortunately, due to how sift.js was internally implemented there was no easy way to change it to the form that would satisfy CASL's requirements. Also a lack of free time didn't allow us to work together effectively.</p>\n<p>That's why I decided to implement my own MongoDB query language interpreter, <strong>an interpreter that allows us to use CASL not only with MongoDB but also with SQL, ElasticSearch, Cassandra</strong> and actually whatever is required for your business case!</p>\n<h3 id=\"universal-conditions-ast-ucast\"><a name=\"universal-conditions-ast-ucast\" class=\"h-link\" href=\"#\"></a>Universal Conditions AST (UCAST)</h3>\n<p><a href=\"https://github.com/stalniy/ucast\" target=\"_blank\" rel=\"noopener nofollow\">UCAST</a> is a new conditions checking engine which was specifically implemented for CASL v5. Despite that fact, it can be used on its own and <strong>its goal is to interpret any conditions to any language</strong>. Some examples:</p>\n<ul>\n<li>to transform MongoDB to JavaScript boolean value. In other words, interpret MongoDB conditions in JavaScript runtime on Plain Old JavaScript Objects</li>\n<li><strong>transform MongoDB to SQL!</strong></li>\n<li>transform <a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener nofollow\">json-schema</a> to SQL</li>\n<li>transform MongoDB query to json-schema and vice-versa</li>\n<li>transform an HTTP request to a MongoDB or SQL query</li>\n</ul>\n<p>Hopefully, now it's clear that it provides a way <strong>to transform X query to Y query or interpret X query in JavaScript</strong>. How do you feel about this? I'm excited!</p>\n<h2 id=\"free-perks\"><a name=\"free-perks\" class=\"h-link\" href=\"#\"></a>Free Perks</h2>\n<p>Additionally to database polyglot ability, UCAST makes CASL v5 to check permissions based on attributes in <strong>~2 times faster than in v4</strong>! This was the reason which inspired me to further optimize performance in CASL but this is another story.</p>\n<p>If you would like to test this yourself, please use the latest <a href=\"https://github.com/stalniy/casl/releases/tag/%40casl%2Fability%405.1.0-next.9\" target=\"_blank\" rel=\"noopener nofollow\">@casl/ability@5.1.0-next.9</a> pre-release version.</p>\n<hr>\n<p>Did I deserve <a href=\"https://opencollective.com/casljs/contribute/barista-13740/checkout\" target=\"_blank\" rel=\"noopener nofollow\">a cup of coffee</a>?</p>\n<hr>\n<p>More about ucast, compilers and performance improvements, you will find in the next article. Stay tuned!</p>","headings":[["why","Why?"],["a-bit-of-history","A bit of history"],["so-no-sql-at-all","So, no SQL at all?"],["finally-solution","Finally. Solution"],["universal-conditions-ast-ucast","Universal Conditions AST (UCAST)"],["free-perks","Free Perks"]],"id":"casl-pursuing-perfection-why"}