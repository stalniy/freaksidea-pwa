{"title":"Учимся программировать в Shell: обработка сигналов","summary":"Обработка сигналов также важна, как и обработка ошибок. \"Правильные\" скрипты в\nBash прослушивают и реагируют на появление сигналов. В основном - это сигналы\nпрерывающие выполнение работы скрипта. Например, если скрипт создает\nфайлы-блокировки, то он должен их удалить по завершению выполнения или получив\nодин из сигналов прерывания. Рассмотрим, какие возможности для этого\nпредоставляет нам Bash\n","author":"sstotskyi","categories":["devops","important"],"createdAt":"2011-10-20T21:21:00.000Z","meta":{"keywords":["linux","Bash","прерывания"]},"alias":"uchimsya-programmirovat-v-shell-obrabotka-signalov","content":"<p>Сбой работы скрипта может произойти не только из-за какой-то ошибки, но и из-за сигналов. Рассмотрим следующий пример</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"this script will endlessly loop until you stop it\"</span>\n<span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-keyword\">do</span>\n    : <span class=\"hljs-comment\"># Do nothing</span>\n<span class=\"hljs-keyword\">done</span>\n</code></pre>\n<p>Этот скрипт будет выполнятся до тех пор пока его кто-то или что-то не прервет при помощи сигналов. Такой сигнал можно послать при помощи комбинации клавиш <em>CTRL + C</em>, такой сигнал называется <em>SIGINT</em>.</p>\n<h2 id=\"uborka-za-soboj\"><a name=\"uborka-za-soboj\" class=\"h-link\" href=\"#\"></a>Уборка за собой</h2>\n<p>В большинстве случаев обработку сигналов не нужно писать. Но в некоторых условиях все же является обязательным. Например</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\n<span class=\"hljs-comment\"># Program to print a text file with headers and footers</span>\n\nTEMP_FILE=/tmp/printfile.txt\n\npr <span class=\"hljs-variable\">$1</span> &gt; <span class=\"hljs-variable\">$TEMP_FILE</span>\n\n<span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">\"Print file? [y/n]: \"</span>\n<span class=\"hljs-built_in\">read</span>\n<span class=\"hljs-keyword\">if</span> [ <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$REPLY</span>\"</span> = <span class=\"hljs-string\">\"y\"</span> ]; <span class=\"hljs-keyword\">then</span>\n    lpr <span class=\"hljs-variable\">$TEMP_FILE</span>\n<span class=\"hljs-keyword\">fi</span>\n</code></pre>\n<p>Данный скрипт обрабатывает, переданный в качестве аргумента, файл при помощи команды <strong>pr</strong> и сохраняет результат во временном файле. Потом он спрашивает пользователя нужно ли напечатать файл. Если он (пользователь) ответит да (&quot;y&quot;), то файл отправляется на печать (если у Вас не установлен принтер, то вместо <strong>lpr</strong> можно использовать <strong>less</strong>).</p>\n<p>В этом скрипте можно заметить множество проблем. Поскольку мы передаем файл, то для начала нужно проверить передается ли аргумент вообще и является ли он файлом. Но это вовсе не то, на чем мы сфокусируемся. Основная проблема в том, что если выполнение скрипта будет  прервано сигналом, то на файловой системе останется временной файл.</p>\n<p>Хорошим тоном является удаление временных файлов, если скрипт получил сигнал на прерывание. И <strong>Bash</strong> предоставляет нам возможности определить это событие.</p>\n<h2 id=\"trap\"><a name=\"trap\" class=\"h-link\" href=\"#\"></a>trap</h2>\n<p>Команда <strong>trap</strong> позволяет запустить функцию во время получения какого-то сигнала. Ее синтаксис</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">trap</span> arg signals\n</code></pre>\n<p>&quot;signals&quot; - это список сигналов, которые нужно прослушивать, &quot;arg&quot; - это команда, которую нужно запустить при появлении одного из заданных сигналов. Для нашего примера - это будет выглядеть следующим образом</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\n<span class=\"hljs-comment\"># Program to print a text file with headers and footers</span>\n\nTEMP_FILE=/tmp/printfile.txt\n\n<span class=\"hljs-built_in\">trap</span> <span class=\"hljs-string\">\"rm <span class=\"hljs-variable\">$TEMP_FILE</span>; exit\"</span> SIGHUP SIGINT SIGTERM\n\npr <span class=\"hljs-variable\">$1</span> &gt; <span class=\"hljs-variable\">$TEMP_FILE</span>\n\n<span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">\"Print file? [y/n]: \"</span>\n<span class=\"hljs-built_in\">read</span>\n<span class=\"hljs-keyword\">if</span> [ <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$REPLY</span>\"</span> = <span class=\"hljs-string\">\"y\"</span> ]; <span class=\"hljs-keyword\">then</span>\n    lpr <span class=\"hljs-variable\">$TEMP_FILE</span>\n<span class=\"hljs-keyword\">fi</span>\nrm <span class=\"hljs-variable\">$TEMP_FILE</span>\n</code></pre>\n<p>В скрипте мы прослушиваем 3 сигнала, но можно добавить и больше. Полный список сигналов можно получить выполнив <strong>trap -l</strong>. Сигнала можно указывать не только по имени, но и по их числовым идентификаторам.</p>\n<p>Все же существует сигнал, который нельзя прослушивать - это <em>SIGNKILL (9)</em>. Ядро <em>Linux</em> мгновенно прерывает скрипт, который получает такой сигнал. Обычно это делается когда какой-то процесс завис. Это делается при помощи команды <strong>kill -9 processId</strong>. Но все же не забывайте, что посылая такой сигнал, программа, которую вы хотите остановить никаким образом не сможет отреагировать на него. Например, скрипт, который создает файлы-блокировки не сможет их удалить получив такой сигнал и тогда следующий его запуск будет невозможен. Файлы-блокировки придется удалять вручную и это хорошо если команда сообщит Вам где они находятся.</p>\n<h2 id=\"clean-up-funkcziya\"><a name=\"clean-up-funkcziya\" class=\"h-link\" href=\"#\"></a>Clean Up функция</h2>\n<p>Хотя команда <strong>trap</strong> и позволяет прослушивать появление сигналов, она все же имеет некоторые ограничения - можно передать только простую строку команд на выполнение. Конечно можно разделить их двоеточием, но тогда когда перестанет быть читабельным. Более правильным способом является создание <strong>clean_up</strong> функции, которая выполняет все основные действия. Конечный вариант нашего скрипта выглядит следующим образом</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash\n</span>\n<span class=\"hljs-comment\"># Program to print a text file with headers and footers</span>\n\nTEMP_FILE=/tmp/printfile.txt\n\n<span class=\"hljs-keyword\">function</span> clean_up {\n    <span class=\"hljs-comment\"># Perform program exit housekeeping</span>\n    rm <span class=\"hljs-variable\">$TEMP_FILE</span>\n    <span class=\"hljs-built_in\">exit</span>\n}\n\n<span class=\"hljs-built_in\">trap</span> clean_up SIGHUP SIGINT SIGTERM\n\npr <span class=\"hljs-variable\">$1</span> &gt; <span class=\"hljs-variable\">$TEMP_FILE</span>\n\n<span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">\"Print file? [y/n]: \"</span>\n<span class=\"hljs-built_in\">read</span>\n<span class=\"hljs-keyword\">if</span> [ <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$REPLY</span>\"</span> = <span class=\"hljs-string\">\"y\"</span> ]; <span class=\"hljs-keyword\">then</span>\n    lpr <span class=\"hljs-variable\">$TEMP_FILE</span>\n<span class=\"hljs-keyword\">fi</span>\nclean_up\n</code></pre>\n<h2 id=\"sozdanie-bezopasnyh-vremennyh-fajlov\"><a name=\"sozdanie-bezopasnyh-vremennyh-fajlov\" class=\"h-link\" href=\"#\"></a>Создание &quot;безопасных&quot; временных файлов</h2>\n<p>Наш скрипт можно кое-чем улучшить. Традиционно, в <em>Unix</em>, все временные файлы хранятся в директории <strong>/tmp</strong>. Из-за этого возникает ряд проблем. Имена создаваемых Вами файлов должны быть уникальными, чтобы не испортить работу какой-то другой программы, но и в тоже время их имя должно быть читабельным и понятным для пользователя. Для создания подобных имен можно использовать следующую технику</p>\n<pre><code class=\"hljs language-php\">TEMP_FILE=/tmp/printfile.$$.$RANDOM\n</code></pre>\n<p>Т.е. имя файла осталось тоже самое - <strong>printfile</strong>. Переменная <strong>$$</strong> хранит в себе идентификатор процесса (<em>pid</em>) - это поможет найти процесс, который отвечает за создание и удаление этого файла. Но этого не достаточно, чтобы получить уникальное имя, по-этому добавляем произвольно сгенерированное число при помощи <strong>shell</strong> переменной <em>RANDOM</em>. При помощи этой техники у нас получилось создать одновременно читабельное и уникальное имя временного файла.</p>\n<p>По мотивам <a href=\"http://linuxcommand.org\" target=\"_blank\" rel=\"noopener nofollow\">http://linuxcommand.org</a></p>","headings":[["uborka-za-soboj","Уборка за собой"],["trap","trap"],["clean-up-funkcziya","Clean Up функция"],["sozdanie-bezopasnyh-vremennyh-fajlov","Создание &quot;безопасных&quot; временных файлов"]],"id":"uchimsya-programmirovat-v-shell-obrabotka-signalov"}