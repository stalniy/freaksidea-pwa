{"title":"Наблюдаемые массивы в KnockOut","summary":"Теперь уже известно, что нужно использовать метод observable для свойства,\nчтобы иметь возможность отвечать на его изменения. Если же нужно реагировать\nна изменения в коллекции (массиве), то используюется observableArray\n","author":"sstotskyi","categories":["frontend"],"createdAt":"2012-04-12T12:45:00.000Z","meta":{"keywords":["javascript","knockout","observables"]},"alias":"nablyudaemye-massivy-v-knockout","content":"<p>Теперь уже известно, что нужно использовать метод <strong>observable</strong> для свойства, чтобы иметь возможность отвечать на его изменения. Если же нужно реагировать на изменения в коллекции (массиве), то используюется <strong>observableArray</strong>. Наблюдаемые массивы часто задействованы в ситуациях, когда нужно отображать списки данных с возможностью фильтрации или редактирования. Не нужно путать массивы со свойствами. При добавлении объекта в наблюдаемый массив его свойства не станут наблюдаемые. Основная идея коллекций - это наблюдение за коллекцией, а не за состояниями объектов в ней.</p>\n<p>Создать наблюдаемый массив очень просто</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> observableArray = ko.observableArray([\n    { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Bungle\"</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"Bear\"</span> },\n    { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"George\"</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"Hippo\"</span> },\n    { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Zippy\"</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"Unknown\"</span> }\n]);\n\n<span class=\"hljs-comment\">// or just</span>\n<span class=\"hljs-keyword\">var</span> anotherObservableArray = ko.observableArray([\n    { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Bungle\"</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"Bear\"</span> },\n    { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"George\"</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"Hippo\"</span> },\n    { <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Zippy\"</span>, <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">\"Unknown\"</span> }\n]);\n\nalert(observableArray().length);\nalert(myObservableArray()[<span class=\"hljs-number\">0</span>]);\n</code></pre>\n<p>По аналогии с наблюдаемыми свойствами, метод КО <strong>observableArray</strong> возвращает функцию, по-этому чтобы получить значение массива нужно ее вызвать. В общем, чтобы добавлять/удалять элементы, можно использовать стандартные методы массивов в <em>JavaScript</em>. Но КО предоставляет более богатый функционал. Он предоставляет кроссбраузерное решение для методов вроде <strong>indexOf</strong>, которые появились только в новых версиях браузеров. При использовании методов КО (например, <strong>push</strong>, <strong>slice</strong>) автоматически запускается механизм проверки зависимостей и уведомления всех подписчиков, а также код выглядит более читабельным, что немало важно.</p>\n<h2 id=\"manipulirovanie-nablyudaemymi-kollekcziyami\"><a name=\"manipulirovanie-nablyudaemymi-kollekcziyami\" class=\"h-link\" href=\"#\"></a>Манипулирование наблюдаемыми коллекциями</h2>\n<p>Наблюдаемые массивы предоставляют точно такой же функционал для манипулирования, как и обычные.</p>\n<ul>\n<li><strong>indexOf</strong> - возвращает индекс первого найденного элемента, который равный переданному аргументу. Если элемент не найден - возвращает -1</li>\n<li><strong>slice</strong> - возвращает элементы массива з начального аргумента до последнего myObservableArray.slice(1, 5)</li>\n<li><strong>push</strong> - добавляет новый элемент в массив</li>\n<li><strong>pop</strong> - удаляет последний и возвращает его</li>\n<li><strong>unshift</strong> - вставляет новый элемент в начало массива</li>\n<li><strong>shift</strong> - удаляет первый элемент и возвращает его</li>\n<li><strong>reverse</strong> - возвращает массив в обратном порядке</li>\n<li><strong>sort</strong> - сортирует массив. По умолчанию от А-Я, 0-9. Также в качестве первого параметра можно передать функцию, которая должна возвращать 0, 1 или -1, соответственно когда элементы равны, когда первый больше второго и наоборот</li>\n<li><strong>splice</strong> - удаляет и возвращает удаленные элементы из массива</li>\n</ul>\n<h2 id=\"metody-remove-i-remove-all\"><a name=\"metody-remove-i-remove-all\" class=\"h-link\" href=\"#\"></a>Методы remove и removeAll</h2>\n<p>К сожалению в стандартном наборе методов массивов в <em>JavaScript</em>, нет таких полезных как</p>\n<ul>\n<li>observableArray.remove(someItem) удаляет все значения из массива, которые равны <em>someItem</em> и возвращает их как массив</li>\n<li>myObservableArray.remove(function(item) { return item.age &lt; 18 }) удаляет все значения для которых <em>callback</em> вернет <em>true</em></li>\n<li>myObservableArray.removeAll(['Chad', 132, undefined]) удаляет все значения, которые равны 'Chad', 132, undefined и возвращает их как массив</li>\n</ul>\n<p>Также существуют аналогичные методы <strong>destroy</strong> и <strong>destroyAll</strong>, которые вместо того чтобы удалять элементы добавляют им специальную метку-свойство <strong>_destroy</strong> равное <strong>true</strong>. Элементы с таким свойством не отображаются <strong>foreach</strong> байндингом, что удобно, пользователь не видит элементов, но в массиве они есть.</p>\n<p>Пример использование наблюдаемых массивов можно посмотреть <a href=\"http://knockoutjs.com/examples/simpleList.html\" target=\"_blank\" rel=\"noopener nofollow\">здесь</a>.</p>\n<p><strong>По материалам</strong>: <a href=\"http://knockoutjs.com/documentation/observableArrays.html\" target=\"_blank\" rel=\"noopener nofollow\">KnockOut</a></p>","headings":[["manipulirovanie-nablyudaemymi-kollekcziyami","Манипулирование наблюдаемыми коллекциями"],["metody-remove-i-remove-all","Методы remove и removeAll"]],"id":"nablyudaemye-massivy-v-knockout"}