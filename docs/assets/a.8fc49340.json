{"title":"Magento модели от А до Я: события и rewrite классов","summary":"Стараясь сделать свою систему максимально гибкой и расширяемой разработчики\nMagento предусмотрели возможность перезаписи любых классов, при чем аж двумя\nразными способами.\n","author":"sstotskyi","categories":["backend","important"],"createdAt":"2012-02-26T10:31:00.000Z","meta":{"keywords":["magento","конфигурация","модели"]},"alias":"magento-modeli-ot-a-do-ya-sobytiya-i-rewrite-klassov","content":"<p>Стараясь сделать свою систему максимально гибкой и расширяемой разработчики <em>Magento</em> предусмотрели возможность перезаписи любых классов, при чем аж двумя разными способами. Первый базируется на 3-х скоупах и особенностях автолоадера (назовем его <em>copy-paste</em>), а второй на конфигурации модуля (назовем его <em>extends</em>).</p>\n<h2 id=\"copy-paste\"><a name=\"copy-paste\" class=\"h-link\" href=\"#\"></a>Copy-Paste</h2>\n<p><app-link to=\"page\" params=\"{&quot;id&quot;:&quot;php_and_somethings/show-62-magento-modeli-ot-a-do-ia-modeli-iadra&quot;}\">Из предыдущей статьи</app-link> стало известно о скоупах <em>Magento</em>. Благодаря им переопределять классы можно посредством <em>copy-paste</em> файлов. И потом поменять логику в классе на свое усмотрение. Рассмотрим, что происходить при вызове в коде следующей строки</p>\n<pre><code class=\"hljs language-php\">$product = Mage::getModel(<span class=\"hljs-string\">'catalog/product'</span>);\n</code></pre>\n<p>Как уже известно <em>Magento</em> основываясь на конфигурации динамически создаст имя класса, в данном случае - это <em>Mage_Catalog_Model_Product</em>. Потом создается объект этого класса и вызывается автолоадер. Последний в свой очередь преобразовывает имя класса в строку <em>Mage/Catalog/Model/Product.php</em>. Потом сервер автоматически ищет данный файл среди 3-х скоупов, благодаря такой фиче в <em>PHP</em> как <em>include_path</em>. Если открыть файл <em>app/Mage.php</em>, то можно убедится в том, что <em>Magento</em> изменяет этот параметр.</p>\n<p>При чем проверка идет в следующем порядке: <em>local</em> → <em>community</em> → <em>core</em>. Т.е. если нужно внести, какие-то мелкие изменения в класс продукта, то нужно просто в директории <em>local</em> создать соответствующую структуру каталогов и скопировать файл класса туда. В конкретном случае создаем в <em>app/code/local</em> каталог <strong>Mage</strong>, внутри него <strong>Catalog</strong>, внутри него <strong>Model</strong> и копируем в последнюю директорию файл <em>app/code/core/Mage/Catalog/Model/Product.php</em>. Теперь можно добавить кастом функционал со спокойной душой.</p>\n<h2 id=\"extends\"><a name=\"extends\" class=\"h-link\" href=\"#\"></a>Extends</h2>\n<p>Этот способ предоставляет возможность заменить стандартный класс честно, без <em>copy-paste</em>. В статье о базовой конфигурации модуля я специально пропустил директиву <strong>rewrite</strong>. Ее можно прописывать внутри <em>models</em>, <em>blocks</em> и <em>helpers</em>. Например, для переопределения стандартного класса продукта</p>\n<pre><code class=\"hljs language-xml\">............................................................\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">models</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">catalog</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rewrite</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">product</span>&gt;</span>FI_Catalog_Model_Product<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">product</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rewrite</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">catalog</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">models</span>&gt;</span>\n..........................................................\n</code></pre>\n<p>Если нужен также и стандартный функционал, тогда класс <strong>FI_Catalog_Model_Product</strong> должен быть потомком <strong>Mage_Catalog_Model_Product</strong>.</p>\n<p>Нужно правильно указать директивы (теги), чтобы <em>rewrite</em> был применен. Принцип такой же как и в <em>Magento path</em>. Т.е. сначала указываем имя модуля (<em>catalog</em> - имя ноды можно посмотреть в конфигурации модуля в секции для моделей), потом <em>rewrite</em> и следующий тег состоит из пути к файлу относительно модуля (вместо слэша нижнее подчеркивание), внутри которого задается имя класса, который будет использоваться вместо стандартного.</p>\n<p>Например, чтобы перезаписать класс <strong>Mage_Adminhtml_Sales_Order_Create</strong>, в конфигурации (в секции <em>models</em>) пропишем следующие строки</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">adminhtml</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rewrite</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">sales_order_create</span>&gt;</span>FI_Sales_Model_Adminhtml_Sales_Order_Create<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">sales_order_create</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">rewrite</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">adminhtml</span>&gt;</span>\n</code></pre>\n<p>Тогда при выполнении строки</p>\n<pre><code class=\"hljs language-php\">$createModel = Mage::getModel(<span class=\"hljs-string\">'adminhtml/sales_order_create'</span>);\n</code></pre>\n<p><em>Magento</em> сначала проверит есть ли <em>rewrite</em> для этой модели если есть, то использует имя заданного класса, если нету составит динамически. Все это относится к хелперам и блокам.</p>\n<p>Этот метод лучше предыдущего по нескольким причинам:</p>\n<ul>\n<li>отсутствие <em>copy-paste</em></li>\n<li>меньше проблем с обновлением ядра</li>\n<li><em>rewrite</em> является частью модуля, как и сам класс</li>\n</ul>\n<h2 id=\"pochemu-rewrite-y-zlo\"><a name=\"pochemu-rewrite-y-zlo\" class=\"h-link\" href=\"#\"></a>Почему rewrite-ы зло?</h2>\n<p>Оба эти метода имеют очень большой минус! Это конфликт сторонних расширений. Например, 2 модуля имеют <em>rewrite</em> на один и тот же класс. Тогда будет утеряна часть функционала, что не очень хорошо. Конечно это можно исправить изменив код в одном из модулей, но тогда будут проблемы с обновлением этого расширения, что тоже плохо.</p>\n<p>Как любят говорить в универе, а потом и на работе - ЗАБУДЬТЕ ВСЕ ТО, ЧТО ВЫ ЗНАЛИ! Так и здесь такой способ существует, но лучше его не использовать. Можно только в редких случаях, когда Вы уверены, что в будущем это не принесет гору хлопот.</p>\n<p>Вместо того, чтобы перезаписывать стандартные классы нужно использовать события.</p>\n<h2 id=\"sobytiya-v-magento\"><a name=\"sobytiya-v-magento\" class=\"h-link\" href=\"#\"></a>События в Magento</h2>\n<p>В Magento реализован <a href=\"http://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)\" target=\"_blank\" rel=\"noopener nofollow\"><em>Observer pattern</em></a>, при помощи которого в нужных местах можно генерировать произвольное событие. А потом посредством конфигурации создавать наблюдателя за любым событием. Этот патерн позволяет делать независимые модули, которые внедряют свой функционал посредством событий. Это очень удобно, например, для реализации сохранения комментарии при сохранении заказа.</p>\n<p>Как приатачить наблюдателя на событие написано <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;php_and_somethings/show-59-magento-konfighuratsiia-ot-a-do-ia-bazovye-nastroiki-modulia&quot;}\">в статье о конфигурации модуля</app-link>.</p>\n<p>Если речь идет о моделях, то вместо того чтобы перезаписывать их желательно найти событие, которое Вам поможет решить проблему. В большинстве случаев такое существует.</p>\n<p>Выбросить событие очень просто</p>\n<pre><code class=\"hljs language-php\">$arrayOfEventParams = <span class=\"hljs-keyword\">array</span>(\n    <span class=\"hljs-string\">'key'</span>   =&gt; <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-string\">'value'</span> =&gt; <span class=\"hljs-string\">'test'</span>\n);\nMage::dispatchEvent(<span class=\"hljs-string\">'my_event_name'</span>, $arrayOfEventParams);\n</code></pre>\n<p>В метод класса наблюдателя передается объект <strong>Varien_Event_Observer</strong>, который содержит в себе объект события, получить который можно вызвав метод <strong>getEvent</strong>. Внутри последнего находятся параметры переданные вторым аргументом методу <strong>dispatchEvent</strong>. Так как класс события является потомком <strong>Varien_Object</strong>, то к данным можно обратится посредством геттеров</p>\n<pre><code class=\"hljs language-php\">$key   = $observer-&gt;getEvent-&gt;getKey();   <span class=\"hljs-comment\"># = 2</span>\n$value = $observer-&gt;getEvent-&gt;getValue(); <span class=\"hljs-comment\"># = test</span>\n</code></pre>\n<p>Приведу пример метода из модуля <strong>Mage_Catalog</strong>. Метод удаляет таблицы при удалении стора (<em>store</em>)</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Mage_Catalog_Model_Observer</span>\n</span>{\n............................................................\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">storeDelete</span><span class=\"hljs-params\">(Varien_Event_Observer $observer)</span>\n    </span>{\n        <span class=\"hljs-keyword\">if</span> (Mage::helper(<span class=\"hljs-string\">'catalog/category_flat'</span>)-&gt;isEnabled(<span class=\"hljs-keyword\">true</span>)) {\n            $store = $observer-&gt;getEvent()-&gt;getStore();\n            Mage::getResourceModel(<span class=\"hljs-string\">'catalog/category_flat'</span>)-&gt;deleteStores($store-&gt;getId());\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>;\n    }\n............................................................\n}\n</code></pre>\n<h2 id=\"sobytiya-v-blokah\"><a name=\"sobytiya-v-blokah\" class=\"h-link\" href=\"#\"></a>События в блоках</h2>\n<p>В моделях можно встретить множество событий. К сожалению (или так сразу задумывалось разработчиками) событий в блоках достаточно мало. События в блоках в общем-то сказать и не нужны. Ответ на вопрос почему очень прост. Структура страницы определяется при помощи <em>layout update</em> файлов, о чем было рассказано <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;php_and_somethings/show-49-magento-konfighuratsiia-ot-a-do-ia-layout-updates&quot;}\">в одной из предыдущих глав</app-link>. Существует целых 2 способа, как можно изменить функционал блока не используя события:</p>\n<ul>\n<li>используя директиву <em>remove</em> удалить блок и добавить свой, который будет потомком старого (можем переопределить любой метод, изменить поведение)</li>\n<li>если можно обойтись публичными методами, то можно просто добавить свой новый блок (как соседа, к тому который нужно изменить) и потом реализовать все изменения в методе <strong>_prepareLayout</strong></li>\n</ul>\n<p>Например, в административном интерфейсе, на странице списка продуктов, нужно добавить кнопку экспорта продуктов. Решая такую задачу первое, что пришло мне в голову использовать событие <strong>core_block_abstract_prepare_layout_after</strong>. Это событие вызывается на каждом блоке, который определен на странице, т.е. нужно еще и добавить проверку по имени блока, чтобы знать, что кнопка будет добавлена в правильное место.</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FI_ImportExport_Model_Observer</span>\n</span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addExportButton</span><span class=\"hljs-params\">(Varien_Event_Observer $observer)</span>\n    </span>{\n        $block = $observer-&gt;getEvent()-&gt;getBlock();\n        <span class=\"hljs-keyword\">if</span> ($block-&gt;getNameInLayout() != <span class=\"hljs-string\">'products_list'</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">$this</span>;\n        }\n\n        $block-&gt;addButton(<span class=\"hljs-string\">'export'</span>, <span class=\"hljs-keyword\">array</span>(\n            <span class=\"hljs-string\">'label'</span>   =&gt; Mage::helper(<span class=\"hljs-string\">'fi_importexport'</span>)-&gt;__(<span class=\"hljs-string\">'Export'</span>),\n            <span class=\"hljs-string\">'onclick'</span> =&gt; <span class=\"hljs-string\">\"setLocation('{$block-&gt;getUrl('*/sync/export')}'); Element.show('loading-mask');\"</span>\n        ));\n    }\n}\n</code></pre>\n<p>Это была одна из самых плохих моих идей.</p>\n<p>Немного подумав, я понял что проще добавить новый блок, а в <em>layout</em>, в тоже самое место, где находится <em>products_list</em>, но чтобы он создался уже после него.</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">layout</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">adminhtml_catalog_product_index</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">reference</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">block</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"fi_importexport/button\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"export.button\"</span> <span class=\"hljs-attr\">after</span>=<span class=\"hljs-string\">\"products_list\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">reference</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">adminhtml_catalog_product_index</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">layout</span>&gt;</span>\n</code></pre>\n<p>Блок-кнопка ничего не выводит, так как является потомком абстрактного класса ядра. Сама реализация последнего достаточно проста</p>\n<pre><code class=\"hljs language-php\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FI_ImportExport_Block_Button</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Mage_Core_Block_Abstract</span>\n</span>{\n    <span class=\"hljs-keyword\">protected</span> $_addButtonTo = <span class=\"hljs-string\">'products_list'</span>;\n\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_prepareLayout</span><span class=\"hljs-params\">()</span>\n    </span>{\n        <span class=\"hljs-keyword\">if</span> ($list = <span class=\"hljs-keyword\">$this</span>-&gt;getLayout()-&gt;getBlock(<span class=\"hljs-keyword\">$this</span>-&gt;_addButtonTo)) {\n            $list-&gt;addButton(<span class=\"hljs-string\">'export'</span>, <span class=\"hljs-keyword\">array</span>(\n                <span class=\"hljs-string\">'label'</span>   =&gt; Mage::helper(<span class=\"hljs-string\">'fi_importexport'</span>)-&gt;__(<span class=\"hljs-string\">'Export Products'</span>),\n                <span class=\"hljs-string\">'onclick'</span> =&gt; <span class=\"hljs-string\">\"setLocation('\"</span> . <span class=\"hljs-keyword\">$this</span>-&gt;getUrl(<span class=\"hljs-string\">'adminhtml/sync/export'</span>) . <span class=\"hljs-string\">\"')\"</span>\n            ));\n        }\n    }\n</code></pre>\n<p>Данный способ намного меньше нагружает систему, по-этому эффективнее.</p>\n<p><strong>P.S.</strong>: в комментариях можно предлагать темы для следующих статей.</p>","headings":[["copy-paste","Copy-Paste"],["extends","Extends"],["pochemu-rewrite-y-zlo","Почему rewrite-ы зло?"],["sobytiya-v-magento","События в Magento"],["sobytiya-v-blokah","События в блоках"]],"id":"magento-modeli-ot-a-do-ya-sobytiya-i-rewrite-klassov"}