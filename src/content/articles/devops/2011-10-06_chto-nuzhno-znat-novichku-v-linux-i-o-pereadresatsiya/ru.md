---
title: 'Что нужно знать новичку в Linux: i/o переадресация'
summary: |
  Одной из основных и самых мощных возможностей командной строки, является
  перенаправления потоков. Простыми словами - это возможность передачи
  результата выполнения одной команды другой или чтение/запись в файл
author: sstotskyi
categories:
  - devops
  - important
createdAt: 2011-10-06T14:09:00.000Z
meta:
  keywords:
    - linux
    - input
    - output
alias: chto-nuzhno-znat-novichku-v-linux-i-o-pereadresatsiya
---

Как Вы уже увидели большинство команд, таких как **ls**, выдают информацию на дисплей. Однако, используя специальные обозначения можно перенаправить результат вывода большинства команд в файл, на устройство или передать как входной поток для другой команды

## Стандартный вывод (Standard Output)

Большинство команд в командной строке для чтобы отобразить результат роботы на мониторе пользователя отсылают данные на стандартный вывод. По умолчанию, стандартный вывод перенаправляет данные на дисплей. Чтобы переадресовать поток в файл используется символ "**\>**"

```bash
enej@linux:~$ ls > file_list.txt
```

В этом примере выполняется команда **ls** и результат ее выполнения записывается в **file\_list.txt** (если файл существует, то он будет перезаписан!). Если Вы хотите, чтобы результат записывался в конец файла, а не перезаписывал его используйте символы "**\>>**"

```php
enej@linux:~$ ls >> file_list.txt
```

Поскольку результат работы команды был перенаправлен в файл, то на экране вы ничего не увидите. Если файла не существовало на момент выполнения команды он будет создан.

## Стандартный ввод (Standard Input)

Многие команды умеют принимать аргумент из стандартного ввода. Обычно стандартный ввод - это данные введенные пользователем с клавиатуры, но как и стандартный вывод может быть перенаправлен. Чтобы отослать файл на стандартный ввод используется символ "**<**"

```bash
enej@linux:~$ sort < file_list.txt
```

В данном примере команда **sort** (man sort) читает файл из стандартного ввода и сортирует его строки. Забавно будет выглядеть, если перенаправить результат работы в другой файл

```bash
enej@linux:~$ sort < file_list.txt > sorted_file_list.txt
```

Будьте осторожны с такими конструкциями, потому что они плохо читаемые и можно ошибиться с порядком перенаправления. Обязательным условием является, то что операторы перенаправления ("**\>**", "**<**") должны следовать после всех опций и аргументов команды.

## Пайпы (Pipes)

Наиболее полезным и мощным инструментом является создание цепочки команды, которые передают результат своего вывода на стандартный ввод другой команды. Это делается при помощи пайпа ("**|**"). Один из любимых примеров

```bash
enej@linux:~$ ls -l | less
```

Здесь результат работы команды **ls** перенаправляется на стандартный ввод команды **less**. Используя подобный трюк, можно вывод любой команды сделать прокручиваемым. Составляя такие цепочки команд можно получить достаточно полезные конструкции, например

*   10 самых новых файлов в текущей директории.

    ```bash
    enej@linux:~/bin$ ls -lt | head
    ```

*   список папок и их размер отсортированных от наибольшего к наименьшему

    ```bash
    enej@linux:~/bin$ du | sort -nr
    ```

*   к-во файлов в директории и ее поддиректориях

    ```bash
    enej@linux:~/bin$ find . -type f -print | wc -l
    ```


## Фильтры

Существует группа команд, которые удобно использовать для фильтрации данных. Обычно они читают информацию из стандартного ввода, фильтруют/преобразовывают ее и выводят на стандартный вывод. Вот несколько из них

*   **sort** - сортирует стандартный ввод и передает результат на стандартный вывод
*   **uniq** - получает сортированный поток данных на стандартный ввод и удаляет повторяющиеся строки
*   **grep** - одна из часто используемых и очень мощных команд. Читает данные из стандартного ввода, фильтрует их по определенному шаблону ([регулярному выражению](http://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)) и выдает результат. Кстати слово **грепать** пошло от имени этой команды и по своему существу означает "искать".
*   **fmt** - читает текст из стандартного ввода и выводит отформатированный текст
*   **pr** - читает текст из стандартного ввода и разбивает его на страницы, добавляя также колонтитулы. Используется перед отправкой данных на принтер
*   **head** - возвращает несколько первых строк из стандартного ввода (по умолчанию 10)
*   **tail** - возвращает несколько последних строк. Очень полезная для просмотра лог файлов
*   **tr** - транслитерирует символы. Заменяет один символ на другой, например, полезно для конвертации конца строки из DOS формата в Unix формат
*   **sed** - это по сути целый язык. В самом простом случае используется для поиска и замены строк в соответствии с регулярным выражением
*   **awk** - очень мощный язык программирования. Используется для написания сложных фильтров и преобразований

## Несколько трюков

В Linux существует достаточно мощная команда **ltr**, которая читает данные из стандартного ввода и отправляет их на принтер. Вот несколько примеров

```php
enej@linux:~/bin$ cat poorly_formatted_report.txt | fmt | pr | lpr
enej@linux:~/bin$ cat unsorted_list_with_dupes.txt | sort | uniq | pr | lpr
```

Команда **cat** читает весь файл и отправляет его на стандартный вывод, куда тот в свою очередь переадресовывается на команду форматирования и потом отправляется на принтер.

Очень полезным является возможность просмотра внутренностей tar архивированного файла

```bash
tar tzvf name_of_file.tar.gz | less
```

**P.S.**: не забываем о прекрасном менуеле в Linux!
