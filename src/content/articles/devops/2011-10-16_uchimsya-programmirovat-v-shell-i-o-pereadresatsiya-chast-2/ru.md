---
title: 'Учимся программировать в Shell: i/o переадресация. Часть 2'
summary: |
  Зная об управляющих конструкциях стоит вновь вернутся к потоковой
  переадресации. Циклы, как и почти все команды в Linux, умеют работать со
  стандартным вводом и выводом. Это позволяет читать файлы построчно или
  записывать в массив.
author: sstotskyi
categories:
  - devops
  - important
createdAt: 2011-10-16T15:33:00.000Z
meta:
  keywords:
    - linux
    - input
    - output
    - Bash
alias: uchimsya-programmirovat-v-shell-i-o-pereadresatsiya-chast-2
---

Циклы, как и почти все команды в Linux, умеют работать со стандартным вводом и выводом. Это позволяет читать файлы построчно или записывать их в массивы. Но прежде стоит разобраться с командой **read**

## Интерактивные скрипты

Для получения данных введенных пользователем с клавиатуры используется команда **read**. Она читает ввод с клавиатуры и присваивает его переменной. Например

```bash
#!/bin/bash

echo -n "Enter some text > "
read text
echo "You entered: $text"
```

Как видно в 3 строке кода вызывается **echo** с флагом "**\-n**", который указывает на то, что после вывода текста на экран не нужно перемещать курсор на следующую строку. Потом команда **read** останавливает выполнение скрипта и ждет ввода данных с клавиатуры. Пример скрипта в действии

```bash
enej@linux:~/tmp$ ./test.sh
Enter some text > bla
You entered: bla
```

Если не передать аргумент для **read**, то ввод будет присвоен переменной окружения _REPLY_. Эта команда также может принимать опции. Самые часто используемые - это "_\-t_", "_\-s_" и "_\-d_". Опция _\-t_ позволяет указать _timeout_ в секундах, после которого команда отдаст управление назад в скрипт. Например

```bash
#!/bin/bash

echo -n "Hurry up and type something! > "
if read -t 3 response; then
    echo "Great, you made it in time!"
else
    echo "Sorry, you are too slow!"
fi
```

Флаг _\-s_ - скрывает ввод. Это нужно для получения каких-то конфиденциальных данных, например пароля. Опция _\-d_ - указывает символ при появлении которого чтение ввода нужно завершить, по умолчанию - это символ переноса строки.

## Практикуемся

Создавать строки, которые содержат символы переноса "\\n" мы умеем 2 способами, но они содержат некоторые недостатки

*   одинарные кавычки (нет возможности интерполировать переменные)
*   echo -e "some string \\nnewline" (можно интерполировать, но строка становится не читабельной)

Благодаря команде **read** и **HERE DOC** синтаксису, который отправляет текст на стандартный ввод команды, можно реализовать третий способ

```bash
#!/bin/bash

name='Sergiy Stotskiy';

read -d '' text <<-_HERE_DOC
Hi ${name}.

How are you?
_HERE_DOC

echo "$text";
```

То же самое можно сделать и при помощи конструкции **$()**

```php
#!/bin/bash

name='Sergiy Stotskiy';

text=$(cat <<-_HERE_DOC
Hi ${name}.

How are you?
_HERE_DOC
);
echo "$text";
```

Но по-моему так менее читабельно. Запустив этот скрипт получим

```bash
enej@linux:~/tmp$ ./test.sh
Hi Sergiy Stotskiy.

How are you?
```

Также команду **read** можно использовать вместе с циклами для чтения файла построчно. Напишем скрипт, который читает сам себя

```bash
#!/bin/bash

while read line;do
  echo $line;
done < $0
```

Здесь на стандартный ввод циклу передается весь файл скрипта, потом команда **read** читает данные до момента появления символа переноса строки, т.е. одну строчку из файла.

Результат работы цикла также можно перенаправить в файл

```bash
#!/bin/bash

while read line;do
  echo $line;
done < $0 > /tmp/bla
```

В данном случае по сути написан простой скрипт для копирования файла. Запустите его и посмотрите что получится
