---
title: 'Учимся программировать в Shell: основные ошибки и методы устранения'
summary: |
  Прежде чем продолжить изучение управляющих конструкций, рассмотрим основные
  ошибки при написании скриптов и методы их устранения
author: sstotskyi
categories:
  - linux
  - important
createdAt: 2011-10-15T12:26:00.000Z
meta:
  keywords:
    - linux
    - Bash
alias: uchimsya-programmirovat-v-shell-osnovnye-oshibki-i-metody-ustraneniya
---

Прежде чем продолжить изучение управляющих конструкций, рассмотрим основные ошибки при написании скриптов и методы их устранения. Для этого создадим тестовый скрипт _problem.sh_

```bash
#!/bin/bash

option=5;

if [ $option = "5" ]; then
  echo "Option = 5";
else
  echo "Option != 5";
fi
```

Если запустить этот код, то увидим, что Option равно 5, т.е. вроде все хорошо. Но немного изменив его, убедимся в обратном. Установим значение переменной _option_ в **null** (3 строка)

```bash
#!/bin/bash

option=;

if [ $option = "5" ]; then
  echo "Option = 5";
else
  echo "Option != 5";
fi
```

Запустив этот вариант скрипта - увидим

```bash
enej@linux:~/tmp$ /bin/bash problem.sh 
problem.sh: line 5: [: =: unary operator expected
Option != 5
```

С криками WTF лезем в исходник и долго смотрим на 5 строку кода, проверяем синтаксис команды **if** и все же не можем найти никакой ошибки. В чем же дело? Чтобы разобраться нужно взглянуть на скрипт глазами младенца **Bash**. Посмотрим на 5 строку.

В первом ее варианте, когда _option_ равнялась 5, он видел

```bash
if [ 5 = "5" ]; then
```

А во втором

```bash
if [ = "5" ];then
```

О! Теперь все ясно. Ведь конструкция в последнем варианте синтаксически невалидна. Как же быть? В одном из предыдущих топиков рассматривалась интерполяция переменных в двойных кавычках, давайте применим ее здесь, т.е. (меняем 5 строку)

```php
if [ "$option" = "5" ]; then
```

Тогда **Bash** увидит следующее

```bash
if [ "" = "5" ]; then
```

Все правильно, все хорошо, скрипт выполняется и говорит, что _option_ неравно 5.

Еще одной проблемой является пропущенная кавычка. Например, уберите из строки 6 закрывающую кавычку и запустите скрипт

```bash
enej@linux:~/tmp$ /bin/bash problem.sh 
problem.sh: line 8: unexpected EOF while looking for matching `"'
problem.sh: line 10: syntax error: unexpected end of file
```

**Bash** говорит нам, что проблема в 8 строке, но взглянув на нее, ничего особенного не увидим. По-этому будьте внимательны и всегда используйте текстовый редактор с подсветкой кода, тогда такие ошибки зразу бросаются в глаза.

## Техника поиска ошибок

Иногда, очень сложно найти ошибку в коде, особенно если она логическая, а не синтаксическая. По-этому поделюсь некоторыми методами, которые использую сам

*   комментирование блоков кода. Суть метода состоит в комментировании нескольких строк кода и запустить скрипт вновь. Если проблема исчезла, значит она находится в закомментированном блоке, например, в случае с пропущенной кавычкой: если закомментировать блок else и запустим программу, то увидим, что ошибка не исчезла, значить проблема не в нем и тогда продолжаем комментировать дальше или что-то другое.
*   вывод переменных. С помощью команды **echo**, выводим любые переменные из скрипта, чтобы посмотреть, является ли их значение ожидаем для нас.
*   дебагинг. Вы наверно думаете, что я прекрасный **Bash** программист раз умею смотреть на код его глазами? Но здесь никакой магии. Вы можете смотреть тоже! При помощи опции **\-x** можно установить debug режим интерпретатора, при котором на своем экране можно увидеть ход выполнения скрипта. Например, рассмотрим наш вариант неработающего скрипта, тот где _option_ равно **null**
    
    ```bash
    #!/bin/bash
    
    option=;
    
    # enable debug mode
    set -x;
    if [ $option = "5" ]; then
      echo "Option = 5";
    else
      echo "Option != 5";
    fi
    
    # disable debug mode
    set +x;
    ```
    
    и вот что увидим запустив скрипт
    
    ```bash
    enej@linux:~/tmp$ /bin/bash problem.sh 
    + '[' = 1 ']'
    problem.sh: line 6: [: =: unary operator expected
    + echo 'Option != 1'
    Option != 1
    ```
    
    т.е. именно то, что мы уже знаем.

По мотивам [http://linuxcommand.org](http://linuxcommand.org)