---
title: 'Учимся программировать в Shell: обработка ошибок'
summary: |
  Разница между хорошо написанной программой и плохо - это возможность
  "справляться" с непредвиденными ситуациями. Как мы уже знаем любая хорошо
  написанная программа возвращает exit-статус операционной системе после
  окончания работы. Для написания правильных программ нужно всегда делать
  проверку exit-статуса, особенно в тех случаях, когда что-то может пойти
  кардинально и невозвратимо не в ту сторону
author: sstotskyi
categories:
  - linux
  - important
createdAt: 2011-10-19T21:24:00.000Z
meta:
  keywords:
    - linux
    - Bash
    - ошибки
alias: uchimsya-programmirovat-v-shell-obrabotka-oshibok
---

Разница между хорошо написанной программой и плохо - это возможность "справляться" с непредвиденными ситуациями. Как мы уже знаем любая хорошо написанная программа возвращает _exit-статус_ операционной системе после окончания работы. Для написания правильных программ нужно всегда делать проверку _exit-статуса_, особенно в тех случаях, когда что-то может пойти кардинально и невозвратимо не в ту сторону. Вот пример очень плохой программы

```bash
# Example of a really bad idea

cd $some_directory
rm *
```

На первый взгляд все вроде хорошо. Заходим в какую-то директорию и удаляем из нее все файлы. НО, что если по каким-то причинам этот каталог не будет существовать? Тогда наш скрипт удалит все файлы из текущей рабочей директории. А это плохо!

## Проверка exit-статуса

Существует несколько способов проверить _exit-статус_. Одним из них является проверка переменной окружения **$?**, которая возвращает _exit-статус_ последней выполненной команды. Например

```bash
enej@linux:~/tmp$ true; echo $?
0
enej@linux:~/tmp$ false; echo $?
1
```

Да-да, в **Linux** есть такие команды как **true** и **false**. Эти команды ничего не делают, просто возвращают соответственный _exit-статус_ и мы уже знаем какой. Обладая новыми знаниями давайте перепишем наш скрипт

```bash
# Check the exit status

cd $some_directory
if [ "$?" = "0" ]; then
    rm *
else
    echo "Cannot change directory!" 1>&2
    exit 1
fi
```

Здесь можно увидеть еще одну незнакомую конструкцию **1>&2** - она означает переадресацию данных на стандартную ошибку (standard error). Теперь скрипт проверяет _exit-статус_ команды **cd** и ничего страшного не произойдет, если он вдруг будет не нулевым.

Это конечно же, рабочий вариант, но его можно переписать более изящно

```bash
# A better way

if cd $some_directory; then
    rm *
else
    echo "Could not change directory! Aborting." 1>&2
    exit 1
fi
```

Но а для гурманов и любителей вкусняшек

```bash
cd $some_directory && rm *
```

## And и OR строки

Предыдущий пример в мэнуале по **Bash** имеет даже свое название - _AND строка_. Выполнение команд, можно объеденять в AND и/или OR строки. Например

```bash
command1 && command2
```

command2 выполнится только при условии, если command1 вернет нулевой _exit-статус_ или

```bash
command1 || command2
```

command2 выполнится только при условии, если command1 вернет не нулевой _exit-статус._ Посмотрим на простом примере

```bash
enej@linux:~/tmp$ true || echo 'echo executed';
enej@linux:~/tmp$ false || echo 'echo executed';
echo executed
enej@linux:~/tmp$ true && echo 'echo executed';
echo executed
enej@linux:~/tmp$ false && echo 'echo executed';
```

_Exit-статус_ и фишки вроде выполнения строки команд - это конечно хорошо, но что если в нашем пример выше переменная **some\_directory** будет пустой? Тогда **Bash** подумает, что **cd** запускается без параметров и поменяет текущую директорию на рабочий каталог пользователя, который запустил скрипт и удалит там все файлы. А это совсем как плохо! По-этому проверяйте не только выполнение команд, но и переменные, которые вы им передаете.

## Error exit функция

При написании скриптов хорошим тоном является создание функции отвечающей за обработку ошибку (error handler). Перепишем наш скрипт с учетом этого

```bash
# An error exit function

function error_exit {
  echo "$1" 1>&2
  exit 1
}

# Using error_exit

if cd $some_directory; then
  rm *
else
  error_exit "Cannot change directory!  Aborting."
fi
```

Теперь все ошибки выводим при помощи **error\_exit** функции, в данном случае она просто выводит текст ошибки. Будет полезно немного улучшить эту функцию добавив имя файла в котором произошла ошибка (это понадобится, когда ваш скрипт будет состоять более чем из одного файла), а также номер строки в которой она произошла (номер строки хранится в переменной окружения _LINENO)._ Напишем простой пример использования

```php
#!/bin/bash

PROGNAME=$(basename $0)

function error_exit {
  echo "${PROGNAME}: ${1:-"Unknown Error"}" 1>&2
  exit 1
}

echo "Example of error with line number and message"
error_exit "$LINENO: An error has occurred."
```

Как видно из кода, если не передать текст ошибки в функцию, то будет использоваться значение по умолчанию - _Unknow error_.

Никогда не забывайте обрабатывать ошибки в своих программах!

По мотивам [http://linuxcommand.org](http://linuxcommand.org)