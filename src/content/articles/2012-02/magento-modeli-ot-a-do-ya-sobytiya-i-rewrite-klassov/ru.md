---
title: 'Magento модели от А до Я: события и rewrite классов'
summary: |
  Стараясь сделать свою систему максимально гибкой и расширяемой разработчики
  Magento предусмотрели возможность перезаписи любых классов, при чем аж двумя
  разными способами.
author: sstotskyi
categories:
  - backend
  - important
createdAt: 2012-02-26T10:31:00.000Z
meta:
  keywords:
    - magento
    - конфигурация
    - модели
alias: magento-modeli-ot-a-do-ya-sobytiya-i-rewrite-klassov
---

Стараясь сделать свою систему максимально гибкой и расширяемой разработчики _Magento_ предусмотрели возможность перезаписи любых классов, при чем аж двумя разными способами. Первый базируется на 3-х скоупах и особенностях автолоадера (назовем его _copy-paste_), а второй на конфигурации модуля (назовем его _extends_).

## Copy-Paste

[Из предыдущей статьи](../magento-modeli-ot-a-do-ya-modeli-yadra) стало известно о скоупах _Magento_. Благодаря им переопределять классы можно посредством _copy-paste_ файлов. И потом поменять логику в классе на свое усмотрение. Рассмотрим, что происходить при вызове в коде следующей строки

```php
$product = Mage::getModel('catalog/product');
```

Как уже известно _Magento_ основываясь на конфигурации динамически создаст имя класса, в данном случае - это _Mage\_Catalog\_Model\_Product_. Потом создается объект этого класса и вызывается автолоадер. Последний в свой очередь преобразовывает имя класса в строку _Mage/Catalog/Model/Product.php_. Потом сервер автоматически ищет данный файл среди 3-х скоупов, благодаря такой фиче в _PHP_ как _include\_path_. Если открыть файл _app/Mage.php_, то можно убедится в том, что _Magento_ изменяет этот параметр.

При чем проверка идет в следующем порядке: _local_ → _community_ → _core_. Т.е. если нужно внести, какие-то мелкие изменения в класс продукта, то нужно просто в директории _local_ создать соответствующую структуру каталогов и скопировать файл класса туда. В конкретном случае создаем в _app/code/local_ каталог **Mage**, внутри него **Catalog**, внутри него **Model** и копируем в последнюю директорию файл _app/code/core/Mage/Catalog/Model/Product.php_. Теперь можно добавить кастом функционал со спокойной душой.

## Extends

Этот способ предоставляет возможность заменить стандартный класс честно, без _copy-paste_. В статье о базовой конфигурации модуля я специально пропустил директиву **rewrite**. Ее можно прописывать внутри _models_, _blocks_ и _helpers_. Например, для переопределения стандартного класса продукта

```xml
............................................................
<models>
    <catalog>
        <rewrite>
            <product>FI_Catalog_Model_Product</product>
        </rewrite>
    </catalog>
</models>
..........................................................
```

Если нужен также и стандартный функционал, тогда класс **FI\_Catalog\_Model\_Product** должен быть потомком **Mage\_Catalog\_Model\_Product**.

Нужно правильно указать директивы (теги), чтобы _rewrite_ был применен. Принцип такой же как и в _Magento path_. Т.е. сначала указываем имя модуля (_catalog_ - имя ноды можно посмотреть в конфигурации модуля в секции для моделей), потом _rewrite_ и следующий тег состоит из пути к файлу относительно модуля (вместо слэша нижнее подчеркивание), внутри которого задается имя класса, который будет использоваться вместо стандартного.

Например, чтобы перезаписать класс **Mage\_Adminhtml\_Sales\_Order\_Create**, в конфигурации (в секции _models_) пропишем следующие строки

```xml
<adminhtml>
    <rewrite>
        <sales_order_create>FI_Sales_Model_Adminhtml_Sales_Order_Create</sales_order_create>
    </rewrite>
</adminhtml>
```

Тогда при выполнении строки

```php
$createModel = Mage::getModel('adminhtml/sales_order_create');
```

_Magento_ сначала проверит есть ли _rewrite_ для этой модели если есть, то использует имя заданного класса, если нету составит динамически. Все это относится к хелперам и блокам.

Этот метод лучше предыдущего по нескольким причинам:

*   отсутствие _copy-paste_
*   меньше проблем с обновлением ядра
*   _rewrite_ является частью модуля, как и сам класс

## Почему rewrite-ы зло?

Оба эти метода имеют очень большой минус! Это конфликт сторонних расширений. Например, 2 модуля имеют _rewrite_ на один и тот же класс. Тогда будет утеряна часть функционала, что не очень хорошо. Конечно это можно исправить изменив код в одном из модулей, но тогда будут проблемы с обновлением этого расширения, что тоже плохо.

Как любят говорить в универе, а потом и на работе - ЗАБУДЬТЕ ВСЕ ТО, ЧТО ВЫ ЗНАЛИ! Так и здесь такой способ существует, но лучше его не использовать. Можно только в редких случаях, когда Вы уверены, что в будущем это не принесет гору хлопот.

Вместо того, чтобы перезаписывать стандартные классы нужно использовать события.

## События в Magento

В Magento реализован [_Observer pattern_](http://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)), при помощи которого в нужных местах можно генерировать произвольное событие. А потом посредством конфигурации создавать наблюдателя за любым событием. Этот патерн позволяет делать независимые модули, которые внедряют свой функционал посредством событий. Это очень удобно, например, для реализации сохранения комментарии при сохранении заказа.

Как приатачить наблюдателя на событие написано [в статье о конфигурации модуля](../../2011-11/magento-konfighuratsiia-ot-a-do-ia-bazovye-nastroiki-modulia).

Если речь идет о моделях, то вместо того чтобы перезаписывать их желательно найти событие, которое Вам поможет решить проблему. В большинстве случаев такое существует.

Выбросить событие очень просто

```php
$arrayOfEventParams = array(
    'key'   => 2,
    'value' => 'test'
);
Mage::dispatchEvent('my_event_name', $arrayOfEventParams);
```

В метод класса наблюдателя передается объект **Varien\_Event\_Observer**, который содержит в себе объект события, получить который можно вызвав метод **getEvent**. Внутри последнего находятся параметры переданные вторым аргументом методу **dispatchEvent**. Так как класс события является потомком **Varien\_Object**, то к данным можно обратится посредством геттеров

```php
$key   = $observer->getEvent->getKey();   # = 2
$value = $observer->getEvent->getValue(); # = test
```

Приведу пример метода из модуля **Mage\_Catalog**. Метод удаляет таблицы при удалении стора (_store_)

```php
class Mage_Catalog_Model_Observer
{
............................................................
    public function storeDelete(Varien_Event_Observer $observer)
    {
        if (Mage::helper('catalog/category_flat')->isEnabled(true)) {
            $store = $observer->getEvent()->getStore();
            Mage::getResourceModel('catalog/category_flat')->deleteStores($store->getId());
        }
        return $this;
    }
............................................................
}
```

## События в блоках

В моделях можно встретить множество событий. К сожалению (или так сразу задумывалось разработчиками) событий в блоках достаточно мало. События в блоках в общем-то сказать и не нужны. Ответ на вопрос почему очень прост. Структура страницы определяется при помощи _layout update_ файлов, о чем было рассказано [в одной из предыдущих глав](../../2011-10/magento-konfighuratsiia-ot-a-do-ia-layout-updates). Существует целых 2 способа, как можно изменить функционал блока не используя события:

*   используя директиву _remove_ удалить блок и добавить свой, который будет потомком старого (можем переопределить любой метод, изменить поведение)
*   если можно обойтись публичными методами, то можно просто добавить свой новый блок (как соседа, к тому который нужно изменить) и потом реализовать все изменения в методе **\_prepareLayout**

Например, в административном интерфейсе, на странице списка продуктов, нужно добавить кнопку экспорта продуктов. Решая такую задачу первое, что пришло мне в голову использовать событие **core\_block\_abstract\_prepare\_layout\_after**. Это событие вызывается на каждом блоке, который определен на странице, т.е. нужно еще и добавить проверку по имени блока, чтобы знать, что кнопка будет добавлена в правильное место.

```php
class FI_ImportExport_Model_Observer
{
    public function addExportButton(Varien_Event_Observer $observer)
    {
        $block = $observer->getEvent()->getBlock();
        if ($block->getNameInLayout() != 'products_list') {
            return $this;
        }

        $block->addButton('export', array(
            'label'   => Mage::helper('fi_importexport')->__('Export'),
            'onclick' => "setLocation('{$block->getUrl('*/sync/export')}'); Element.show('loading-mask');"
        ));
    }
}
```

Это была одна из самых плохих моих идей.

Немного подумав, я понял что проще добавить новый блок, а в _layout_, в тоже самое место, где находится _products\_list_, но чтобы он создался уже после него.

```xml
<layout>
    <adminhtml_catalog_product_index>
        <reference name="content">
            <block type="fi_importexport/button" name="export.button" after="products_list" />
        </reference>
    </adminhtml_catalog_product_index>
</layout>
```

Блок-кнопка ничего не выводит, так как является потомком абстрактного класса ядра. Сама реализация последнего достаточно проста

```php
class FI_ImportExport_Block_Button extends Mage_Core_Block_Abstract
{
    protected $_addButtonTo = 'products_list';

    protected function _prepareLayout()
    {
        if ($list = $this->getLayout()->getBlock($this->_addButtonTo)) {
            $list->addButton('export', array(
                'label'   => Mage::helper('fi_importexport')->__('Export Products'),
                'onclick' => "setLocation('" . $this->getUrl('adminhtml/sync/export') . "')"
            ));
        }
    }
```

Данный способ намного меньше нагружает систему, по-этому эффективнее.

**P.S.**: в комментариях можно предлагать темы для следующих статей.
