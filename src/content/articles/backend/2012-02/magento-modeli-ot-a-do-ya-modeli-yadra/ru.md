---
title: 'Magento модели от А до Я: модели ядра'
summary: |
  Поскольку Magento построена, как MVC приложение, то было бы логичным найти в
  базовом функционале подобие ORM или ActiverRecord. Для четкого разделения
  функицонала модели разделены на 2 типа: отвечающие за бизнес логику и за
  предоставление данных.
author: sstotskyi
categories:
  - backend
  - important
createdAt: 2012-02-24T18:49:00.000Z
meta:
  keywords:
    - magento
    - модели
alias: magento-modeli-ot-a-do-ya-modeli-yadra
---

Поскольку Magento построена, как MVC приложение, то было бы логичным найти в базовом функционале подобие _[ORM](http://ru.wikipedia.org/wiki/ORM)_ или _[ActiverRecord](http://ru.wikipedia.org/wiki/ActiveRecord)_. Для четкого разделения функицонала модели разделены на 2 типа: отвечающие за бизнес логику и за предоставление данных. Последние обычно работают с базой данных, но это может быть и что угодно другое (_csv_, _plain text_, _etc_.). Бизнес и ресурс модели связаны между собой посредством [конфигурации модуля](http://freaksidea.com/php_and_somethings/show-59-magento-konfighuratsiia-ot-a-do-ia-bazovye-nastroiki-modulia "Magento module configuration"). Для работы с базой и определения бизнес логики существуют 3 абстрактных класса: **Mage\_Core\_Model\_Abstract**, **Mage\_Core\_Model\_Mysql4\_Abstract**, **Mage\_Core\_Model\_Mysql4\_Collection\_Abstract**. Начиная с версии 1.6 в именах моделей _Mysql4_ заменено на _Resource_ в связи с реализацией поддержки разных СУБД в Magento.

## Бизнес модели

Обычно все бизнес модели наследуются от _Mage\_Core\_Model\_Abstract._ Поскольку в последнем реализован базовый функционал работы с ресурс моделью. Сам же класс наследует весь функционал _Varien\_Object._ Это очень удобно, потому что он реализовывает магические методы доступа к данным. Любая таблица имеет набор полей и строк. Одна бизнес модель - одна строка в базе. Например для блоков сайта существует таблица **cms\_block**. Она имеет поле _title_. Чтобы получить его значение для определенного блока достаточно написать

```php
echo $cmsBlock->getTitle();
```

Аналогично со всеми другими полями. Нужно придерживаться правила: в базе, в именах сложных полей, слова разделять при помощи нижнего подчеркивания, каждое слово с маленькой буквы, например _is\_active_. Тогда в коде через бизнес моделей к этому полю можно обратится при помощи выражения

```php
echo $cmsBlock->getIsActive();
```

Класс имеет несколько интересных свойств: **$\_eventPrefix**, **$\_eventObject** и **$\_isObjectNew**. Первый позволяет задать префикс для событий в классе наследнике (по умолчанию значение равно _core\_abstract_), второй задает имя параметра в объекте события для получения модели (по умолчанию _object_), а третий определяет является ли объект новым созданным или загруженым из ресурс модели (обычно это база данных).

Класс выбрасывает следующие события:

*   _model\_load\_before_, _$\_eventPrefix + ' \_load\_before_' - вызываются в момент загрузки модели, вызов метода **load**
*   _model\_load\_after, $\_eventPrefix + '+load\_after'_ - вызываются после загрузки модели
*   _model\_save\_commit\_after, $\_eventPrefix + '\_save\_commit\_after'_ - вызывается внутри ресурс модели, перед комитом транзакции
*   _model\_save\_before, $\_eventPrefix + '\_save\_before'_ - вызывается перед сохранением данных, вызов метода **save**
*   model\_save\_after, $\_eventPrefix + '\_save\_after' - вызывается после сохранения модели
*   _model\_delete\_before, $\_eventPrefix + '\_delete\_before'_ - вызывается перед удалением данных, вызов метода **delete**
*   _model\_delete\_after, $\_eventPrefix + 'delete\_after'_ - вызывается после удаление данных
*   _$\_eventPrefix + '\_clear'_ - вызывается во время очистки объекта от циклических ссылок, вызов метода **clearInstance** (появился с версии 1.5.1.0)

Во всех случаях когда подряд вызывается 2 события, во втором в качестве параметров передается массив, который можно изменять при помощи защищенной ф-ции _\_getEventData_ в каждом классе наследнике отдельно.

Бизнес модель имеет несколько основных открытых методов, о которых я уже упомянул:

*   **load** - загружает данные в модель. Принимает 2 параметра: значение по которому нужно искать (primary или unique поле) и второй, необязательный, имя поля по которому нужно искать, по умолчанию используется поле primary key
*   **save** - сохраняет данные
*   **delete** - удаляет данные, в случае с СУБД, строку из базы
*   **isObjectNew** - проверяет является ли объект загруженым из базы или создан. Не рекомендую использовать его для проверки! По скольку он возвращает установлено ли значение идентификатора для модели (строки базы, primary key). Для проверки лучше использовать метод **getOrigData()** - возвращает массив  реальных не измененных данных, которые находятся в базе для этой модели. Если массив пуст значит объект "новый", если нет - значит нет
*   **hasDataChanges** - проверяет изменились ли данные
*   **cleanModelCache** - чистит кэш для этой модели по тегам
*   **clearInstance** - удаляет циклические ссылки для модели (в основном используется для моделей продуктов). Когда Вы уверенны, что объект продукта больше не нужен вызывайте этот метод. Это предотвратит возможные утечки памяти (метод доступный с версии 1.5.1.0)
*   **getResource** - возвращает ресурс модель

Например, для моделей _CMS_ блоков

```php
$block = Mage::getModel('cms/block')
    ->setStoreId(Mage::app()->getStore()->getId())
    ->load(12);

echo $block->getId(); # 12

$block->setTitle('Test CMS Block')
    ->save();

$block = Mage::getModel('cms/block')->setId(33);

var_dump($block->isObjectNew()); # false, ERROR!

$isObjectNew = empty($block->getOrigData());
var_dump($isObjectNew); # true
```

## Ресурс модели

Ресурс модели предоставляют интерфейс для получения данных. Для выборки данных используется [_Zend\_Db\_Select_](http://framework.zend.com/manual/ru/zend.db.select.html). Для инициализации модели в классе есть защищенный метод **\_init**, который принимает 2 параметра: _table-path_ (например _catalog/product_) и имя _PRIMARY_ поля (уникального идентификатора строки в таблице).

В качестве примера можно посмотреть, как это сделано в модуле _Mage\_Cms_ для блоков

```php
class Mage_Cms_Model_Mysql4_Block extends Mage_Core_Model_Mysql4_Abstract
{
    protected function _construct()
    {
        $this->_init('cms/block', 'block_id');
    }
............................................................
}
```

Получить реальное имя таблицы (так как она называется в базе данных) можно при помощи метода **getTable()**, который принимает единственный параметр _table-path_.

В _Magento_ за чтение и запись отвечают разные объекты соединений. Получить доступ к ним внутри класса можно при помощи методов **\_getReadAdapter** и **\_getWriteAdapter** соответственно. Объект _SELECT_\-а можно получить только при помощи _read_ соединения, а вставка и обновление данных происходит при участии _write_ соединения. Например, класс имеет защищенный метод **\_getLoadSelect**, который возвращает объект _SELECT_\-а, так давайте посмотрим что там внутри

```php
$select = $this->_getReadAdapter()->select()
   ->from($this->getMainTable())
   ->where($this->getMainTable().'.'.$field.'=?', $value);
```

Эта строка вызывается для загрузки данных в методе **load**, который принимает 3 параметра: объект бизнес модели, значение поля, по-которому ищем и третий необязательный имя поля по-которому ищем. Если последний параметр не передать, то в качестве поля по-которому будет происходить поиск будет использован _PRIMARY KEY_.

Также класс имеет метод **save** с единственным параметром - объект бизнес модели. Внутри него происходят разные проверки, например, на уникальность некоторых полей, что нужно делать _update_ или _insert_, определяются поля таблицы при помощи запроса _DESCRIBE TABLE_ (выполнение запроса кэшируется). Метод **delete** также принимает только один параметр - бизнес модель.

В отличии от бизнес модели, ресурс модель предоставляет не события при выполнении [_CRUD_](http://ru.wikipedia.org/wiki/CRUD) методов, а хуки. Каждый из последних в качестве параметра принимают бизнес модель. Просто перечислим их, по названиях можно догадаться когда они вызываются

*   _\_afterLoad_
*   _\_beforeSave_
*   _\_afterSave_
*   _\_beforeDelete_
*   _\_afterDelete_

Данный класс также имеет еще одно полезное свойство - **$\_serializableFields**. Это массив. В нем можно указать, какие поля в базе хранятся в сериализированом виде и при загрузке модели они автоматически будут десереализированы. Структура массива следующая

```php
/**
 * Structure: array(
 *     <field_name> => array(
 *         <default_value_for_serialization>,
 *         <default_for_unserialization>,
 *         <whether_to_unset_empty_when serializing> // optional parameter
 *     ),
 * )
 *
 */
```

При сохранении данных будет произведено обратное действие над такими полями. Это позволяет не думать о формате хранения и сосредоточится на бизнес логике.

Также при помощи метода **addUniqueField** можно добавить имена уникальных полей и при сохранении _Magento_ проверит их уникальность. Но это не очень удобный способ.

## Псевдо-ресурс модели

К этому типу было решено (мною) отнести классы коллекций. Так как они находятся среди ресурс моделей (по причине того, что они делают запрос в базу на выборку множества строк), но по сути являются контейнером для бизнес моделей, которые в свою очередь зависят от ресурс моделей. Какой-то замкнутый круг. Я думаю, что это кодоляп. Разработчики не захотели усложнять коллекции, по-этому в таких классах можно увидеть смешанную бизнес и ресурс логику.

Класс коллекции **Mage\_Core\_Model\_Mysql4\_Collection\_Abstract** является потомком **Varien\_Data\_Collection\_Db**, который рассматривался [в предыдущей статье](http://freaksidea.com/php_and_somethings/show-61-magento-modeli-ot-a-do-ia-3-kita). Как и ресурс модель он инициализируется при помощи метода **\_init**, который принимает один обязательный параметр _Magento-path_ бизнес модели и второй необязательный _Magento-path_ ресурс модели, если не задан, то второй равен первому.

Имя основной таблицы можно получить при помощи метода **getMainTable()** (аналогичный существует в классе ресурс модели). Объект запроса можно получить вызвав метод **getSelect()**. В классе _Zend\_Db\_Select_ реализован магический метод **\_\_toString**, который превращает объект в строку _SQL_ запроса.

Для выборки значения в котором присутствуют _SQL_ ф-ции реализован интересный метод **addExpressionFieldToSelect**. Но использовать его я не рекомендую. Лучше написать отдельный метод для коллекции чем мешать логику. Приведу _php-doc_ из источников

```php
/**
 * Add attribute expression (SUM, COUNT, etc)
 *
 * Example: ('sub_total', 'SUM({{attribute}})', 'revenue')
 * Example: ('sub_total', 'SUM({{revenue}})', 'revenue')
 *
 * For some functions like SUM use groupByAttribute.
 *
 * @param string $alias
 * @param string $expression
 * @param array $fields
 * @return Mage_Eav_Model_Entity_Collection_Abstract <- кодоляп =)
 */
```

Есть метод **removeFieldFromSelect** при помощи которого можно удалить поле из запроса.

Получить ресурс модель можно вызвав метод **getResource**. Получить все идентификаторы можно при помощи метода **getAllIds**. Также существует метод **save**, который в цикле вызывает сохранение для всех моделей находящихся в коллекции.

Класс выбрасывает 4 события:

*   _core\_collection\_abstract\_load\_before_, _$\_eventPrefix + '\_load\_before'_
*   _core\_collection\_abstract\_load\_after, $\_eventPrefix + '\_load\_after'_

## Magento path

Несколько раз я уже упомянул о таком понятии как _Magento path_. На самом деле это что-то на подобии _xpath_ к настройкам модуля в зависимости от метода, которому он передается. Помним что в настройках модуля есть такие директивы как: _blocks_ и _models_. И обычно в параметре _class_ прописано что-то вроде %module\_name%\_Block и %module\_name%\_Model соответственно. Таким образом мы указываем Magento префиксы для классов моделей и блоков.

_Magento path_ состоит из 2 частей: названия модуля и пути к объекту. Рассмотрим пример

```php
$product = Mage::getModel('catalog/product'); # create model
$block   = Mage::app()->getLayout()->createBlock('core/template'); # create block
```

И в настройках для моделей модуля _Mage\_Catalog_

```xml
<models>
    <catalog>
        <class>Mage_Catalog_Model</class>
        <resourceModel>catalog_resource_eav_mysql4</resourceModel>
    </catalog>
............................................................
</models>
```

_Magento_ смотрит секцию моделей (_models_) и ищет там директиву **catalog**. Если нашла берет то, что внутри параметра **class**, как префикс имени класса. Все первые буквы слов после слэша, которые разделены символом нижнего подчеркивания, приводятся к верхнему регистру и конкатенируются с префиксом, т.е. в данном примере получается, что имя класса равно _Mage\_Catalog\_Model\_Product_. Аналогично все происходит и с блоками.

_Magento path_ был придуман для уменьшения имен классов и удобности написания. Имена классов являются такими длинными, потому что по сути указывают путь на файловой системе где они лежат (если заменить символ нижнего подчеркивания на слэш), а это в свою очередь удобно для реализации простого автолоадера классов.

## Скоупы Magento

В _Magento_ существует 3 скоупа (3 разные директории) для кода: _app/code/community_, _app/code/core_, _app/code/local_. Первый предназначен для сторонних расширений скаченных и установленных при помощи _magento connect_ менеджера. Второй - это ядро _Magento,_ классы в этом скоупе не рекомендуется менять. И третий для своих локальных наработок и модификаций. Наличие этих скоупов дает возможность переопределять (при необходимости) классы ядра или расширения.

Каждый из этих скоупов также имеет под область видимости. Наверно так сложно все было придумано во избежание конфликтов имен. Обычно эта под область имеет сокращенное имя компании, которая разработала данный код или псевдоним автора. В общем никакой особой смысловой нагрузки это имя не несет.

**P.S.**: в следующей статье рассмотрим возможность перезаписи классов и проблемы связанные с этим