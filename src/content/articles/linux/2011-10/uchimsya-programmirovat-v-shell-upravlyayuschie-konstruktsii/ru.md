---
title: 'Учимся программировать в Shell: управляющие конструкции'
summary: |
  Куда же во времена великих и могучих без управляющих конструкций. Почти ни
  один язык не обходится без этого. Это относится и к Bash
author: sstotskyi
categories:
  - linux
  - important
createdAt: 2011-10-13T22:50:00.000Z
meta:
  keywords:
    - Bash
alias: uchimsya-programmirovat-v-shell-upravlyayuschie-konstruktsii
---

Чтобы писать скрипты, которые состоят не просто из последовательного набора команд, но и те которые умеют "думать" и "принимать решения" основываясь на состоянии среды - необходимо знать управляющие конструкции. **Bash** предоставляет несколько команд, с помощью которых можно управлять логикой работы программы: if, exit, for, while, until, case, break, continue.

## Ветвление - if

**if** - одна из самых простых команд, позволяет делать ветвление логики основываясь на условии. Эта команда имеет 3 формы

```bash
# First form

if condition ; then
    commands
fi

# Second form

if condition ; then
    commands
else
    commands
fi

# Third form

if condition ; then
    commands
elif condition ; then
    commands
fi
```

В первом случае, если условие истинно, то выполняются команды внутри, если нет - ничего не происходит.

Во втором случае, если условие истинно, то  выполнятся команды из первой части (между if и else), если нет - из второй (между else и fi).

В третьем случае, если первое условие истинно, то выполняются команды из первой части, если нет, то проверяется второе условие если оно истинно, то выполняются команды из его части, если и это условие не истинно, то ничего не происходит.

Что же такое **condition** в Bash? К большому удивлению здесь все наоборот, не так как в других языках программирования. Чтобы в этом разобраться для начала нужно рассмотреть другую базовою команду.

## Выход - exit

Правильно написанные **Unix** приложения всегда возвращают операционной системе статус завершения их работы (успешно или нет). Это делается при помощи _exit статуса_. _exit статус -_ это целое число в пределах от 0 до 255. "0" - значит, что команда завершилась успешно; все другое означает, что произошла ошибка. Это позволяет обнаруживать возникновение ошибки в процессе выполнения скрипта и изменять в зависимости от этого его поведение.

Очевидно, что обрабатывать ошибки не только является хорошим тоном, но и очень полезно! Например, перед тем как читать файл нужно проверить права на чтение и выдать пользователю понятную ошибку, в случае если их нет.

По-этому, чтобы быть хорошими программистами, всегда нужно устанавливать _exit статус_. Для этого используется команда **exit**. Эта команда мгновенно останавливает выполнение скрипта и возвращает в качестве _exit статуса_ переданный аргумент, например

```bash
# Fail
exit 1;

# or Success
exit 0;
```

## Простые true/false условия - test

Чаще всего команда **test** используется совместно с **if**, но это далеко не правило или ограничение. Эта команда работает просто, если **expression** = true, то команда возвращает _exit статус_ 0, если равно false - возвращает 1. Команда имеет 2 формы записи

```bash
# First form

test expression

# Second form

[ expression ]
```

Если использовать ее в управляющих конструкциях, то второй вариант удобней, если же при выполнения цепочки команд, то понятней и удобней использовать первый. Например

```bash
if [ -f "/path/to/some/file" ]; then
    echo "File exists"
else
    echo "File does not exist"
fi
```

Или же, если файла не существует, создать его

```bash
test -f "/path/to/some/file" || touch "/path/to/some/file";
```

Команда **test** имеет множество разных флагов. В примере выше _\-f_ означает проверку: является ли аргумент файлом. Если условие истинно, то **test** возвращает 0 и выполняется команда **echo**, которая сообщает что переданная строка - это файл , если нет - 1 и выполняется другая команда **echo**, после **else**. Вот список основных **expression**\-ов для команды test

*   _\-d file_ - true, если file является каталогом
*   _\-e file_ - true, если file существует
*   _\-f file_ - true, если file является обычным файлом
*   _\-L file_ - true, если file является символьной ссылкой
*   _\-r file_ - true, если у Вас есть права на чтения файла file
*   _\-w file_ - true, если у Вас есть права на запись файла file
*   _\-x file_ - true, если у Вас есть права на выполнение файла file
*   _file1 -nt file2_ - true, если file1 новее file2 (основываясь на дате модификации)
*   _file1 -ot file2_ - true, если file1 старее file2
*   _\-z string_ - true, если строка пустая
*   _\-n string_ - true, если строка не пустая
*   _string1 = string2_ - true, если строки равны
*   _string1 != string2_ - true, если строки не равны

Прежде чем идти дальше стоит рассмотреть еще несколько нюансов:

1.  Пробелы после "**\[**" и перед "**\]**" обязательны, иначе получите ошибку
2.  "**;**" - является разделителем команд, например

    ```bash
    clear; ls
    ```

    очистит экран терминала и выполнит команду **ls**

Вообще разделителем команд также является символ новой строки, по-этому команду if можно записать в другом виде

```php
# First form
if [ -f "/path/to/some/file" ]
then
    echo "File exists"
else
    echo "File does not exist"
fi

# Second form
if [ -f "/path/to/some/file" ]
then echo "File exists"
else echo "File does not exist"
fi

# Unreadable form
if [ -f "/path/to/some/file" ]; then echo "File exists"; else echo "File does not exist"; fi;
```

## Практикуемся - проверка на суперпользователя

Что если скрипт, который Вы написали для своего выполнения нуждается в правах суперпользователя? Ведь если обычный пользователь запустит его, то он увидит кучу нечитабельных ошибок. Сразу оговорюсь, что использовать **sudo** внутри скрипта - плохая идея. По-этому нужно сделать проверку, является ли пользователь рутом.

Команда **id** поможет нам в этом. Эта команда возвращает информацию о текущем пользователе, а если установить флаг _\-u_, то вернет уникальный идентификатор пользователя. А в рут идентификатор равен 0. Тогда напишем скрипт основываясь на этом

```bash
if [ $(id -u) != "0" ]; then
    echo "You must be the superuser to run this script"
    exit 1
fi
```

**P.S.**: продолжение следует! Кому не терпится - **man bash**
