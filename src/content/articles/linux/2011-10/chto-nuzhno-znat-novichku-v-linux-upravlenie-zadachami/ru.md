---
title: 'Что нужно знать новичку в Linux: управление задачами'
summary: |
  Как и любая другая многозадачная система, Linux одновременно выполняет
  несколько процессов. Вообще, не буду вводить Вас в заблуждение, потому что 
  обычный однопроцессорный компьютер может выполнять только одну задачу в данный
  момент времени, по-этому Linux ставит процессы в очередь на выполнения.
author: sstotskyi
categories:
  - linux
  - important
createdAt: 2011-10-08T11:36:00.000Z
meta:
  keywords:
    - linux
    - управление
    - задачи
alias: chto-nuzhno-znat-novichku-v-linux-upravlenie-zadachami
---

Как и любая другая многозадачная система, Linux одновременно выполняет несколько процессов. Вообще, не буду вводить Вас в заблуждение, потому что обычный однопроцессорный компьютер может выполнять только одну задачу в данный момент времени, по-этому Linux ставит процессы в очередь на выполнения.

Существует несколько основных команд для управлением процессами

*   **ps** - выводить список запущенных процессов
*   **kill** - отправляет сигнал на один или несколько процессов (в основном, чтобы "убить" их)
*   **jobs** - альтернативный путь для просмотра процессов запущенных Вами
*   **bg** - ставит выполнение процесса в фоновый режим
*   **fg** - выводит выполнение процесса из фонового режима

Хотя может показаться, что эти знания достаточно абстрактны, но они могут найти свое практическое применение даже для среднего пользователя, который использует графический интерфейс. Возможно Вы еще не знаете, что большинство графических программ (если не все) можно запустить при помощи командной строки. Для примера попробуем запустить браузер, думаю у большинства linux-оидов стоит или Google Chrome или FireFox

```bash
enej@linux:/home/pub/www/vv$ google-chrome 
Created new window in existing browser session.
```

Можно указать URL, который Вы хотите открыть

```bash
enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com
Created new window in existing browser session.
```

У меня уже запущен Хром через графический интерфейс, по-этому браузер сообщает, что создается новое окно в существующей сессии и отдает управление командной строке. Или, например, если нужно открыть графический файловый менеджер с правами рута (пример будет работать для графической оболочки Gnome с установленным Nautilus)

```bash
enej@linux:/home/pub/www/vv$ sudo nautilus /root/
[sudo] password for enej: 
```

Поскольку процесс был запущен не в фоновом режиме, то в этом окне терминала Вы больше не можете выполнять какие-либо действия (чтобы завершить процесс можно нажать CTRL + C).

## Фоновый режим

Для того, чтобы было проще жить, при запуске графических программ или процессов, которые могут долго работать, обычно их выполнение ставят в фоновый режим, например, давайте запустим браузер в фоновом режиме

```bash
enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com &
[2] 9248
```

Знак амперсанта (**&**) в конце вызова команды значит, что выполнение процесса нужно поместить в фоновый режим. В таком случае, остается возможность работать с даным окном терминала.

Но вдруг Вы забыли поставить ампресант в конце вызова, тогда существует другой способ. Нужно сначала остановить выполнение нажав CTRL + Z, тогда получаем управление командной строкой и можем вызвать команду **bg**, которая поставим последний запущенный процесс в фоновый режим. Сказанное на примере

```bash
enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com 
^Z
[2]+  Stopped                 google-chrome http://freaksidea.com
enej@linux:/home/pub/www/vv$ bg
[2]+ google-chrome http://freaksidea.com &
```

Команда **fg** выводит последний запущенный процесс из фонового режима.

## Список запущенных процессов

Поскольку теперь Вы умеете ставить команды в фоновый режим, было хорошо посмотреть их список. Для этого используется команда **jobs** или более мощная **ps**

```bash
enej@linux:/home/pub/www/vv$ jobs
[1]-  Running                 nm-applet &  (wd: ~/bin)
[2]+  Running                 google-chrome http://freaksidea.com &
enej@linux:/home/pub/www/vv$ ps
  PID TTY          TIME CMD
 2304 pts/0    00:00:02 bash
11104 pts/0    00:00:01 chrome
11108 pts/0    00:00:00 chrome
11110 pts/0    00:00:00 chrome
11132 pts/0    00:00:00 chrome
12088 pts/0    00:00:00 ps
21165 pts/0    00:00:27 nm-applet
```

## Как "убить" процесс?

Если процесс перестает отвечать на действия (т.е. завис), его нужно принудительно "убить". Думаю те кто использует FireFox сталкивались с этим. Для таких задач используется команда **kill**. Но для начала нужно каким-то образом определить процесс. Для этого можно использовать команду **jobs** или **ps**. С помощью первой можно узнать номер процесса, с помощью второй его идентификатор.

```bash
enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com &
[2] 14789
enej@linux:/home/pub/www/vv$ jobs
[1]-  Running                 nm-applet &  (wd: ~/bin)
[2]+  Running                 google-chrome http://freaksidea.com &
enej@linux:/home/pub/www/vv$ kill %2
enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com &
[2] 15181
enej@linux:/home/pub/www/vv$ ps
  PID TTY          TIME CMD
 2304 pts/0    00:00:02 bash
15181 pts/0    00:00:00 chrome
15238 pts/0    00:00:00 ps
21165 pts/0    00:00:27 nm-applet
enej@linux:/home/pub/www/vv$ kill 15181
```

Команды **fg** и **bg** в качестве первого аргумента могут принимать номер запущеного процесса, для его последуещего ввода/вывода в/из фонового режима.

## Побробнее о kill

На самом деле команда **kill** используется для отправки разных сигналов процессам. Просто в большинстве случаев этот сигнал говорит команде, что она должна завершится. Если программы правильно написаны, то они прослушивают различные сигналы от операционной системы и отвечают на них. Например, текстовый редактор должен прослушивать любой сигнал, который уведомляет, что пользователей выходит из системы или что компьютер выключается. Когда он (текстовый редактор) "услышал" такой сигнал, он должен сохранить открытые документы перед тем как закончить свою работу. Команда **kill** умеет отсылать несколько типов сигналов, чтобы узнать какие, введите **kill -l**. Ниже приведен список самых часто используемых сигналов (число в скобках - номер сигнала)

*   **SIGNUP(1)** - изначально был предназначен для того, чтобы информировать программу о потере связи с управляющим терминалом (терминалы часто подключались к системе с помощью модемов, так что название сигнала происходит от hung up – повесить трубку). Сигнал SIGHUP посылается приложению так же и в том случае, если процесс-лидер сессии завершил свою работу. Многие [программы-демоны](http://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BC%D0%BE%D0%BD_%28%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%29), у которых нет лидера сессии, так же обрабатывают этот сигнал. В ответ на получение SIGHUP демон обычно перезапускается (или просто повторно читает файл конфигурации). По умолчанию программа, получившая этот сигнал, завершается.
*   **SIGINT(2)** - обычно посылается процессу, если пользователь терминала дал команду прервать процесс (обычно эта команда - сочетание клавиш Ctrl + C)
*   **SIGTERM(15)** - вызывает "вежливое" завершение программы. Получив этот сигнал, программа может выполнить необходимые перед завершением операции (например, сохранить открытые документы). Получение SIGTERM свидетельствует не об ошибке в программе, а о желании ОС или пользователя завершить ее.
*   **SIGKILL(9)** - вызывает принудительное завершение работы программы. Программа не может ни обработать, ни игнорировать этот сигнал.

По умолчанию команда **kill** отправляет **SIGTERM** сигнал, но также можно указать номер сигнала или его имя. Допустим, что у Вас завис Chrome (у меня иногда флэш плеер перестает адекватно работать)

```bash
enej@linux:/home/pub/www/vv$ google-chrome http://freaksidea.com &
[2] 22066
enej@linux:/home/pub/www/vv$ jobs
[1]-  Running                 nm-applet &  (wd: ~/bin)
[2]+  Running                 google-chrome http://freaksidea.com &
enej@linux:/home/pub/www/vv$ kill -SIGTERM %2
enej@linux:/home/pub/www/vv$ kill -SIGKILL %2
enej@linux:/home/pub/www/vv$ kill -9 %2
```

**P.S.**: думаю очень интересным для начинающих будет 2 команды: **notify-send** (отправляет сообщение через графическую оболочку, в Gnome появляется вверху справа) и **espeak** (синтезатор речи). Если какой-то из них у Вас нет, установить можно при помощи команды **apt-get**

```bash
enej@linux:/home/pub/www/vv$ sudo apt-get install espeak notify-send
```

Почитать об интересном их совмещении можно [здесь](http://habrahabr.ru/blogs/ubuntu/126849/)

По мотивам [http://linuxcommand.org](http://linuxcommand.org)