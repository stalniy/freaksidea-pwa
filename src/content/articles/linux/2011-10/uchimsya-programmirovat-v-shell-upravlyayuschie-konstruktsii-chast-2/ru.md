---
title: 'Учимся программировать в Shell: управляющие конструкции. Часть 2'
summary: |
  Те кто работал командами Linux очень часто видели команды, которым можно
  передавать флаги и аргументы. Такой функционал можно организовать при помощи
  управляющих конструкций, таких как while и case. Давайте знакомится ближе
author: sstotskyi
categories:
  - linux
  - important
createdAt: 2011-10-16T13:24:00.000Z
meta:
  keywords:
    - Bash
alias: uchimsya-programmirovat-v-shell-upravlyayuschie-konstruktsii-chast-2
---

Для тех кто в танке начало [здесь](/linux/show-45-uchimsia-proghrammirovat-v-shell-upravliaiushchie-konstruktsii). Итак, продолжаем рассматривать управляющие конструкции, осталось: case, for, while, until, break, continue.

Мы уже знаем команду **if** и то, что с ее помощью можно делать ветвление логики в программе. Но если нужно проверить несколько вариантов, то можно получить очень не читаемый код, так называемое нагромождение if-ов

```bash
if [ "$type" = "1" ]; then
    echo '$type = 1'
else
    if [ "$type" = "2" ]; then
        echo '$type = 2'
    else
        if [ "$type" = "3" ]; then
            echo '$type = 3'
        else
            echo "WTF?"
        fi
    fi
fi
```

Выглядит мягко говоря не очень. По-этому, как и в большинстве других языков, **Bash** имеет более изящную конструкцию множественного ветвления **case**

```bash
case "$type" in
    1 ) echo 'type = 1'
        ;;
    2 ) echo 'type = 2'
        ;;
    3 ) echo 'type = 3'
        ;;
    * ) echo 'WTF?'
esac
```

Синтаксис команды следующий

```bash
case word in
    patterns ) statements ;;
esac
```

Команда выполняет действия из той ветки, в которой _word_ подходит под _patterns_ (шаблоны). Шаблон может быть просто строкой или более сложным вроде **\[A-Z\] | \[0-9\]**, **\[!abc\]**. Более детально о шаблонах можно почитать [здесь](/linux/show-33-chto-nuzhno-znat-novichku-v-linux-manipuliatsiia-failami). Нужно понимать, что проверка на совпадения начинается с первого шаблона и потом идет к следующему, по-этому _pattern_ **\***, который совпадает со всем, нужно писать в последнем случае. Это что-то вроде _default_ в **case** из других языков программирования вроде PHP.

## Арифметические операции

Прежде чем идти дальше нужно рассмотреть арифметические операции, т.е. работу с числами. Для работы с целыми числами **Bash** предоставляет конструкцию **$((arifmetic\_operation))**, например

```bash
#!/bin/bash

num=0
echo $((num + 1));
```

Выведет 1 на экран. Чтобы убедится, что с дробными числами эта конструкция не работает запустим такой скрипт

```bash
#!/bin/bash

num=5
echo $((num / 2));
```

На экране увидим **2**, вместо **2.5**.

Но не стоит волноваться. Для работы с числами в Linux есть полноценная команда, она даже предоставляет возможности для программирования. Называется она **bc** (An arbitrary precision calculator language). Благодаря тому, что команда умеет читать данные из стандартного ввода, на нее можно отправлять арифметические операции в виде простого текста. Перепишем предыдущий пример

```bash
#!/bin/bash

num=5
echo "scale = 5; $num / 2" | bc;
```

где **scale** - это внутренняя переменная в **bc**, которая указывает количество знаков после запятой. Получаем желаемый результат

```bash
enej@linux:~/tmp$ /bin/bash test.sh
2.50000
```

## Циклы и повторяющиеся действия

Это последняя группа управляющих конструкций в **Bash**. Циклы позволяют выполнять одни и те же команды несколько раз до наступления определенного условия. Например, команда **while** выполняется до тех пор пока условие не станет истинным

```bash
#!/bin/bash

number=0
while [ $number -lt 10 ]; do
    echo "Number = $number"
    number=$((number + 1))
done
```

Обратите внимание, что блок кода, который нужно повторить несколько раз нужно заключить между словами **do** и **done**. В большинстве случаев повторяющийся блок кода как-то влияет на условие в цикле, в нашем случае увеличивает значение _number_ на единицу, иначе бы получился бесконечный цикл. Но бесконечные цикли - это тоже хорошо, большинство [программ-демонов](http://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BC%D0%BE%D0%BD_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0)) работают постоянно благодаря бесконечным циклам. Условия цикла проверяется каждый раз перед тем как выполнить тело цикла.

Следующий цикл **until** - работает по точно такому же принципу за исключением того, что что выполняется до того момента пока условие остается ложным, например

```bash
#!/bin/bash

number=0
until [ $number -ge 10 ]; do
    echo "Number = $number"
    number=$((number + 1))
done
```

Более интересным является цикл **for**

```bash
for variable in words; do
    statements
done
```

Выполняется до тех пор пока есть слова. Каждая часть из **words** присваивается переменной, например

```bash
#!/bin/bash

for i in word1 word2 word3; do
    echo $i
done
```

Получим

```bash
enej@linux:~/tmp$ /bin/bash test.sh
word1
word2
word3
```

Благодаря тому, что этот цикл работает со словами, его можно использовать во многих случаях. Например, пройтись по все файлам из директории, заменить в каждом из них что-то и записать назад

```bash
#!/bin/bash

for file in $(ls); do
    cat $file | sed 's/bla/pra/' > /tmp/$(basename $file);
    mv /tmp/$(basename $file) $file;
done
```

Будьте осторожны! Если Вы заменяете какой-то текст в файле, то запись сначала нужно сделать во временный файл, иначе Ваш файл окажется пустым.

## Практикуемся

В качестве примера давайте рассмотрим написание скрипта, который умеет работать с переданными ему опциями и аргументами.

```bash
#!/bin/bash

apache_vhost_dir="/var/www";
hostname='default';
document_root="$hostname";
host_sufix='.local';
args=();
count=0;

while [ -n "$1" ];do
   case "$1" in
      -h )
         hostname=$2;
      ;;
      -r )
         document_root=$hostname/$2;
      ;;
      -s )
         host_sufix=$2;
      ;;
      *  )
         args[$count]=$1;
         args[$((count+1))]=$2;
         count=$((count+2));
   esac;
   shift; shift;
done;

document_root="$apache_vhost_dir/$document_root";

echo "Host name: $hostname";
echo "Document root: $document_root";
echo "Host sufix: $host_sufix";
echo "Arguments: ${args[@]}";

exit 0;
```

Это часть скрипта, который я написал для автоматизация создания проектов. Запустим его

```bash
enej@linux:~/tmp$ ./test.sh -h test -r www arg1 arg2 arg3
Host name: test
Document root: /var/www/test/www
Host sufix: .local
Arguments: arg1 arg2 arg3
```

Как видим наш скрипт поддерживает как опции так и аргументы. Проанализируем его работу.

Сначала создаем переменные со значениями по умолчанию, это позволяет не указывать все опции. Дальше начинаем цикл до тех пор пока первый аргумент скрипта не равен пустой строке. Дальше проверяем его, если это одна из допустимых опций, то записываем ее значение в специальную переменную, если же нет - то считаем, что это аргумент и записываем его в массив. Потом вызываем два раза команду **shift**. Эта команда удаляет первый элемент из массива аргументов **$@**. Поскольку первый аргумент - это имя опции и хранить его нам не нужно, а второй, значение опции - мы записали в переменную, то удаляем два первых элемента из массива.

По мотивам [http://linuxcommand.org](http://linuxcommand.org)
